<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java面向对象总结</title>
    <url>/2020/12/29/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="Java面向对象三大特性脑图"><a href="#Java面向对象三大特性脑图" class="headerlink" title="Java面向对象三大特性脑图"></a>Java面向对象三大特性脑图</h2><p><img src="/2020/12/29/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93/OOP%E6%80%BB%E7%BB%93.jpg" alt></p>
<h2 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h2><p><code>X instance of Y</code></p>
<ul>
<li><p>编译通过的条件</p>
<p>X是Y的子类，X和Y的类型应该去看定义的左边，而不是new的右边所指向的东西</p>
</li>
<li><p>比较结果</p>
<p>X指向的类（看右边引用）是Y的子类</p>
</li>
</ul>
<p><strong>类型之间的转换</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类 -------&gt; 子类</span><br><span class="line">高类 -------&gt; 低类</span><br><span class="line">    必须使用强制类型装换</span><br><span class="line">  </span><br><span class="line">子类 -------&gt; 父类</span><br><span class="line">低 -------&gt; 高</span><br><span class="line">    不需要强制类型转换，但是会丢失子类的方法</span><br></pre></td></tr></table></figure>

<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><h3 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h3><p>静态的：可以直接通过<code>类名.变量名</code>格式直接访问，无论实例化多少对象，都只有一个！</p>
<p>//多线程</p>
<p>非静态的：必须先实例化类，才能使用</p>
<h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><p>静态的：可直接调用（类加载时就加载了static修饰的）</p>
<p>非静态的：必须先实例化类，才能通过实例的对象使用</p>
<h3 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态代码块</span><br><span class="line"><span class="keyword">static</span>&#123;&#125; —— 最先执行，只执行一次，第一次加载类时执行</span><br><span class="line">匿名代码块：</span><br><span class="line">&#123;&#125; 	-- 先于构造器之前执行</span><br></pre></td></tr></table></figure>

<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><strong>本质还是类！！！</strong></p>
<p>抽象（封装继承多态）的抽象</p>
<p>抽象类是一种约束~~</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1.不能new这个抽线类，只能有子类实现</p>
<p>2.抽线类可以写普通方法</p>
<p>3.抽象方法必须存在于抽象类中</p>
<p><strong>4.存在构造器</strong></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong>递进关系：</strong></p>
<p>普通类：只有具体实现</p>
<p>抽象类：具体实现，规范（抽象方法）都可以有</p>
<p><strong>接口：只有规范</strong></p>
<p>声明类的关键字：<code>class</code></p>
<p>声明接口的关键字：<code>interface</code>（本质就不是类了）</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>其中定义一个方法默认有的修饰符：<code>public abstract</code></p>
<p>定义变量默认有的修饰符：<code>public static final</code></p>
<p><code>implements</code>关键字实现，可多继承，侧面实现了多继承！！！</p>
<p>继承时必须重写接口中所有方法</p>
<h2 id="扩展概念——内部类"><a href="#扩展概念——内部类" class="headerlink" title="扩展概念——内部类"></a>扩展概念——内部类</h2><p>一个类的内部去定义一个新的类</p>
<h3 id="1-成员内部类"><a href="#1-成员内部类" class="headerlink" title="1.成员内部类"></a>1.成员内部类</h3><p>类作为类的成员之一</p>
<p>内部类可以获得外部类的私有属性（通过方法）</p>
<p>内部类实例化方法：先实例化外部类，再使用外部类来实例化内部类</p>
<h3 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2.静态内部类"></a>2.静态内部类</h3><p>static修饰之后就不能用外部类私有属性了</p>
<p>原因：static最先加载，都还不知道私有属性是啥！！！</p>
<h3 id="3-一个java类"><a href="#3-一个java类" class="headerlink" title="3.一个java类"></a>3.一个java类</h3><p>可以有多个<code>class</code>类但只能有一个<code>public class</code>类</p>
<h3 id="4-局部内部类"><a href="#4-局部内部类" class="headerlink" title="4.局部内部类"></a>4.局部内部类</h3><p>方法中定义类</p>
<h3 id="5-匿名内部类"><a href="#5-匿名内部类" class="headerlink" title="5.匿名内部类"></a>5.匿名内部类</h3><p>接口也可new但是必须重写方法</p>
]]></content>
      <categories>
        <category>第一阶段学习</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2020/12/28/Git/</url>
    <content><![CDATA[<h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p><strong>Git是一个分布式版本管理控制系统</strong></p>
<p>Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。世界各地的人为Linux编写代码，而在2002年以前都是由Linus本人通过手工方式合并代码！</p>
<p>代码库过大，手工管理难度大，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper授权Linux社区免费使用这个版本控制系统。开发Samba的Andrew试图破解BitKeeper的协议，被BitMover公司发现了，于是BitMover公司怒了，要收回Linux社区的免费使用权。</p>
<p>然后Linus自己用C语言花了两周自己写了一个分布式版本控制系统，这就是Git！</p>
<p>~~太强了！！！</p>
<p><img src="/2020/12/28/Git/3.png" alt></p>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p>
<p>Windows安装git</p>
<p><img src="/2020/12/28/Git/1.png" alt></p>
<p>下载后右键菜单多出两个东西。</p>
<p><code>Git Bush Here</code>就是命令行使用<code>git</code></p>
<h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>使用命令<code>$ git init</code>把当前目录变成Git可以管理的版本库，目录多出一个<code>.git</code>文件夹</p>
<p><img src="/2020/12/28/Git/2.png" alt></p>
<p>这个目录是Git来跟踪管理版本库的</p>
<p><strong>把文件添加到版本库</strong></p>
<p>所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等。</p>
<p>而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的。</p>
<p>如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p>
<p>因为文本是有编码的，使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p>
<p>千万不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符！！！</p>
<p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库</p>
<p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库</p>
<p><img src="/2020/12/28/Git/4.png" alt></p>
<p><code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明</p>
<h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>现在更改readme.md文件内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A test：change the file</span><br></pre></td></tr></table></figure>

<p>使用<code>$git status</code>指令查看仓库状态，会显示readme.txt被修改过，但是未提交</p>
<p>然后使用<code>$git diff</code>指令可以查看修改了什么内容：</p>
<p><img src="/2020/12/28/Git/5.png" alt></p>
<p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>代码管理工具</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>注解</title>
    <url>/2020/12/28/%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><p>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”，如<code>@Override</code></p>
<p><strong>注释和注解的区别：</strong></p>
<p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p>
<h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h2><p><strong>从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。</strong></p>
<p>Java的注解可以分为三类：</p>
<p>第一类是由编译器使用的注解，例如：</p>
<ul>
<li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li>
<li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li>
</ul>
<p>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</p>
<p>第二类是由工具处理<code>.class</code>文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p>
<p>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p>
<h2 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h2><p>Java语言使用<code>@interface</code>语法来定义注解（<code>Annotation</code>），它的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public @interface Report &#123;</span><br><span class="line">    int type() default 0;</span><br><span class="line">    String level() default &quot;info&quot;;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解的参数类似无参数方法，可以用<code>default</code>设定一个默认值。最常用的参数应当命名为<code>value</code>。</p>
<p>定义一个注解Demo程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> check &#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> <span class="keyword">default</span> 1000</span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@check</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解定义了并没有任何实际意义</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p>
<h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p>
<ul>
<li>类或接口：<code>ElementType.TYPE</code>；</li>
<li>字段：<code>ElementType.FIELD</code>；</li>
<li>方法：<code>ElementType.METHOD</code>；</li>
<li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li>
<li>方法参数：<code>ElementType.PARAMETER</code>。</li>
</ul>
<p>例如，定义注解可用在方法上，我们必须添加一个<code>@Target(ElementType.METHOD)</code></p>
<p>实际上<code>@Target</code>定义的<code>value</code>是<code>ElementType[]</code>数组，只有一个元素时，可以省略数组的写法。</p>
<h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p><code>@Retention</code>定义了<code>Annotation</code>的生命周期：</p>
<ul>
<li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li>
<li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li>
<li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li>
</ul>
<h3 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h3><p>使用<code>@Repeatable</code>这个元注解可以定义<code>Annotation</code>是否可重复。</p>
<h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效.</p>
<h2 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h2><p>只需要考虑如何读取<code>RUNTIME</code>类型的注解。</p>
<p>因为注解定义后也是一种<code>class</code>，所有的注解都继承自<code>java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。</p>
<p>Java提供的使用反射API读取<code>Annotation</code>的方法包括：</p>
<p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p>
<ul>
<li><code>Class.isAnnotationPresent(Class)</code></li>
<li><code>Field.isAnnotationPresent(Class)</code></li>
<li><code>Method.isAnnotationPresent(Class)</code></li>
<li><code>Constructor.isAnnotationPresent(Class)</code></li>
</ul>
<p>使用反射API读取Annotation：</p>
<ul>
<li><code>Class.getAnnotation(Class)</code></li>
<li><code>Field.getAnnotation(Class)</code></li>
<li><code>Method.getAnnotation(Class)</code></li>
<li><code>Constructor.getAnnotation(Class)</code></li>
</ul>
<p>定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。</p>
]]></content>
      <categories>
        <category>Java进阶学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2020/12/28/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。</p>
<p>正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例。</p>
<p><strong><u>所以反射是为了解决运行期间，对某一个实例一无所知的情况下，如何获取并调用其中的方法</u></strong></p>
<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>Java中除了几种基本数据类型，即小写字母开头的关键字<code>int，byte</code>之外，其他类型全部都是class类型</p>
<p>例如<code>String，Object，Exception，Integer</code></p>
<p>因此可以认为：<code>class</code>的本质是数据类型</p>
<p><code>class</code>是由JVM在执行过程中动态加载的。JVM在第一次读取到一种<code>class</code>类型时，将其加载进内存。</p>
<p>每加载一种<code>class</code>，JVM就为其创建一个<code>Class</code>类型的实例，并关联起来。注意：这里的<code>Class</code>类型是一个名叫<code>Class</code>的<code>class</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以<code>String</code>类为例，当JVM加载<code>String</code>类时，它首先读取<code>String.class</code>文件到内存，然后，为<code>String</code>类创建一个<code>Class</code>实例并关联起来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class cls &#x3D; new Class(String);</span><br><span class="line">&#x2F;*</span><br><span class="line">*这个Class实例是JVM内部创建的</span><br><span class="line">*Class类的构造方法是private</span><br><span class="line">*只有JVM能创建Class实例，我们自己的Java程序是无法创建Class实例的。</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p>所以，JVM持有的每个<code>Class</code>实例都指向一个数据类型（<code>class</code>或<code>interface</code>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.lang.String&quot;  │</span><br><span class="line">└───────────────────────────┘</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; Random</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.util.Random&quot;  │</span><br><span class="line">└───────────────────────────┘</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; Runnable</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.lang.Runnable&quot;│</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>一个<code>Class</code>实例包含了该<code>class</code>的所有完整信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.lang.String&quot;  │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│package &#x3D; &quot;java.lang&quot;      │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│super &#x3D; &quot;java.lang.Object&quot; │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│interface &#x3D; CharSequence...│</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│field &#x3D; value[],hash,...   │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│method &#x3D; indexOf()...      │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>由于JVM为每个加载的<code>class</code>创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。</p>
<p>这种通过<code>Class</code>实例获取<code>class</code>信息的方法称为反射（Reflection）。</p>
<h3 id="获取class的Class实例"><a href="#获取class的Class实例" class="headerlink" title="获取class的Class实例"></a>获取class的Class实例</h3><ul>
<li>通过一个class的静态变量</li>
<li>通过实例对象的getClass方法</li>
<li>知道完整类名，用Class.forName方法获取</li>
</ul>
<p>因为<code>Class</code>实例在JVM中是唯一的，所以，上述方法获取的<code>Class</code>实例是同一个实例。可以用<code>==</code>比较两个<code>Class</code>实例：</p>
<p>Demo程序如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"通过class的静态变量class获取:"</span>);</span><br><span class="line">        Class cls1 = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(cls1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"通过class实例对象的getClass方法获取:"</span>);</span><br><span class="line">        Class cls2 = <span class="string">""</span>.getClass();</span><br><span class="line">        System.out.println(cls2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"如果知道一个class的完整类名，可以通过静态方法Class.forName()获取："</span>);</span><br><span class="line">        Class cls3 = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">        System.out.println(cls3);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"比较Class实例："</span>);</span><br><span class="line">        System.out.println(<span class="string">"cls1==cls2 ? "</span> + (cls1 == cls2));</span><br><span class="line">        System.out.println(<span class="string">"cls1==cls3 ? "</span> + (cls1 == cls3));</span><br><span class="line">        System.out.println(<span class="string">"cls2==cls3 ? "</span> + (cls2 == cls3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2020/12/28/%E5%8F%8D%E5%B0%84/1.png" alt></p>
<p>因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个<code>Object</code>实例时，我们可以通过反射获取该<code>Object</code>的<code>class</code>信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void printObjectInfo(Object obj) &#123;</span><br><span class="line">    Class cls &#x3D; obj.getClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Demo2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String类</span></span><br><span class="line">        printClassInfo(<span class="string">""</span>.getClass());</span><br><span class="line">        <span class="comment">//实现多线程的接口类</span></span><br><span class="line">        printClassInfo(Runnable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//时间日期类</span></span><br><span class="line">        printClassInfo(java.time.Month<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//数组不等于String类</span></span><br><span class="line">        printClassInfo(String[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//基本类型</span></span><br><span class="line">        printClassInfo(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassInfo</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Class name: "</span> + cls.getName());</span><br><span class="line">        System.out.println(<span class="string">"Simple name: "</span> + cls.getSimpleName());</span><br><span class="line">        <span class="keyword">if</span> (cls.getPackage() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Package name: "</span> + cls.getPackage().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"is interface: "</span> + cls.isInterface());</span><br><span class="line">        System.out.println(<span class="string">"is enum: "</span> + cls.isEnum());</span><br><span class="line">        System.out.println(<span class="string">"is array: "</span> + cls.isArray());</span><br><span class="line">        System.out.println(<span class="string">"is primitive: "</span> + cls.isPrimitive());</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String类</span></span><br><span class="line">        printClassInfo(<span class="string">""</span>.getClass());</span><br><span class="line">        <span class="comment">//实现多线程的接口类</span></span><br><span class="line">        printClassInfo(Runnable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//时间日期类</span></span><br><span class="line">        printClassInfo(java.time.Month<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//数组不等于String类</span></span><br><span class="line">        printClassInfo(String[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//基本类型</span></span><br><span class="line">        printClassInfo(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassInfo</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Class name: "</span> + cls.getName());</span><br><span class="line">        System.out.println(<span class="string">"Simple name: "</span> + cls.getSimpleName());</span><br><span class="line">        <span class="keyword">if</span> (cls.getPackage() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Package name: "</span> + cls.getPackage().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"is interface: "</span> + cls.isInterface());</span><br><span class="line">        System.out.println(<span class="string">"is enum: "</span> + cls.isEnum());</span><br><span class="line">        System.out.println(<span class="string">"is array: "</span> + cls.isArray());</span><br><span class="line">        System.out.println(<span class="string">"is primitive: "</span> + cls.isPrimitive());</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2020/12/28/%E5%8F%8D%E5%B0%84/2.png" alt></p>
<p>如果获取到了一个<code>Class</code>实例，我们就可以通过该<code>Class</code>实例来创建对应类型的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取String的Class实例:</span></span><br><span class="line">Class cls = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">// 创建一个String实例:</span></span><br><span class="line">String s = (String) cls.newInstance();</span><br></pre></td></tr></table></figure>

<p>上述代码相当于<code>new String()</code>。通过<code>Class.newInstance()</code>可以创建类实例，它的局限是：<strong>只能调用<code>public</code>的无参数构造方法</strong>。带参数的构造方法，或者非<code>public</code>的构造方法都无法通过<code>Class.newInstance()</code>被调用。</p>
<h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。</p>
<h2 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h2><p>对任意的一个<code>Object</code>实例，只要我们获取了它的<code>Class</code>，就可以获取它的一切信息。</p>
<p><strong>这就是“反射”</strong></p>
<p><code>Class</code>类提供了以下几个方法来获取字段：</p>
<ul>
<li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li>
<li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li>
<li>Field[] getFields()：获取所有public的field（包括父类）</li>
<li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li>
</ul>
<p>一个<code>Field</code>对象包含了一个字段的所有信息：</p>
<ul>
<li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li>
<li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li>
<li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<p>字段可以访问、获取、设置。</p>
<h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>通过<code>Class</code>实例的方法可以获取<code>Method</code>实例：<code>getMethod()</code>，<code>getMethods()</code>，<code>getDeclaredMethod()</code>，<code>getDeclaredMethods()</code>；</p>
<p>通过<code>Method</code>实例可以获取方法信息：<code>getName()</code>，<code>getReturnType()</code>，<code>getParameterTypes()</code>，<code>getModifiers()</code>；</p>
<p>通过<code>Method</code>实例可以调用某个对象的方法：<code>Object invoke(Object instance, Object... parameters)</code>；</p>
<p>通过设置<code>setAccessible(true)</code>来访问非<code>public</code>方法；</p>
<p>通过反射调用方法时，仍然遵循多态原则。</p>
<h2 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h2><p><code>Constructor</code>对象封装了构造方法的所有信息；</p>
<p>通过<code>Class</code>实例的方法可以获取<code>Constructor</code>实例：<code>getConstructor()</code>，<code>getConstructors()</code>，<code>getDeclaredConstructor()</code>，<code>getDeclaredConstructors()</code>；</p>
<p>通过<code>Constructor</code>实例可以创建一个实例对象：<code>newInstance(Object... parameters)</code>； 通过设置<code>setAccessible(true)</code>来访问非<code>public</code>构造方法。</p>
<h2 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h2><p>通过<code>Class</code>对象可以获取继承关系：</p>
<ul>
<li><code>Class getSuperclass()</code>：获取父类类型；</li>
<li><code>Class[] getInterfaces()</code>：获取当前类实现的所有接口。</li>
</ul>
<p>通过<code>Class</code>对象的<code>isAssignableFrom()</code>方法可以判断一个向上转型是否可以实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>反射技术内容其实很多，目前暂时先建立概念框架，以及简单Demo，这种技术用的多的是在框架中，等到学习Java第一个框架——集合框架再研究深一点！！！</p>
]]></content>
      <categories>
        <category>Java进阶学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2020/12/28/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>其实Java中的泛型也就是C++中的模板类。C++中用的最多的就是STL中。之所以用到泛型其实就是使得一个函数的功能更强大，或者说一个类的功能更强大。比如写一个函数比较两个元素大小，在C++中有float类型，int类型，double甚至string时每种格式数据都需要写一个函数，很麻烦。</p>
<p>什么是泛型？为什么要使用泛型？</p>
<p><strong>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</strong></p>
<p><strong>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）</strong>。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>在JDK1.5版本之前没有泛型，因此可以定义一个可以接收任何对象的List，</p>
<p><img src="/2020/12/28/%E6%B3%9B%E5%9E%8B/1.png" alt></p>
<p>定义一个ArrayList，格式是Object，所有类的父类</p>
<p><img src="/2020/12/28/%E6%B3%9B%E5%9E%8B/2.png" alt></p>
<p>上述问题是运行是产生问题。</p>
<p>为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>泛型只在编译阶段有效。编译之后程序会采取去泛型化的措施，也就是说Java中的泛型，只在编译阶段有效。</p>
<p>在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p>
<p><strong>型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p>
<h2 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h2><p>泛型的三种使用方法：泛型类，泛型接口，泛型方法</p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>在类的定义中使用类，然后就可让类中的操作都能使用泛型。最典型的就是Java各种容器类——List，Set，Map</p>
<p>一个泛型类例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Fanxing;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;       <span class="comment">// 此处可以随便写标识符号，T是type的简称</span></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K akey,V avalue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = akey;</span><br><span class="line">        <span class="keyword">this</span>.value = avalue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span></span>&#123;<span class="comment">//作为方法返回类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Point&lt;Integer,String&gt; p = <span class="keyword">new</span> Point&lt;Integer,String&gt;();</span><br><span class="line">        p.set(<span class="number">1</span>,<span class="string">"one"</span>);</span><br><span class="line">        System.out.println(p.getValue());</span><br><span class="line">        fun(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Point&lt;?,?&gt; temp)</span></span>&#123;<span class="comment">//通配符 ？</span></span><br><span class="line">        System.out.println(temp.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>声明方法是在类名后面用尖括号把会用到的标识符号列出来。</p>
<p>然后在类中就可以直接使用这些标识符，作为变量类型或者方法的返回类型都可以。</p>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Fanxing;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;        <span class="comment">// 在接口上定义泛型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span> </span>; <span class="comment">// 定义抽象方法，抽象方法的返回值就是泛型类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfoImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;   <span class="comment">// 定义泛型接口的子类</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;             <span class="comment">// 定义属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InfoImpl</span><span class="params">(T avar)</span></span>&#123;     <span class="comment">// 通过构造方法设置属性内容</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = avar;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;<span class="comment">//实现接口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arsg[])</span></span>&#123;</span><br><span class="line">        Info&lt;String&gt; i =<span class="keyword">new</span> InfoImpl&lt;String&gt;(<span class="string">"Codefriday"</span>) ;</span><br><span class="line">        System.out.println(<span class="string">"作者："</span> + i.getVar()) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>第一个泛型类例子中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span><span class="comment">//作为方法返回类型</span></span></span><br></pre></td></tr></table></figure>

<p>并不是一个泛型方法，这只是类中一个普通成员方法，下面引用泛型方法：</p>
<pre><code>public class Test1 {
    public &lt;T&gt; void testMethod(T t){

    }
}</code></pre><p>类型参数位置在返回类型之前</p>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>除了用 <code>&lt;T&gt;</code>表示泛型外，还有 <code>&lt;?&gt;</code>这种形式。<strong>？</strong> 被称为通配符。</p>
<p>通配符有 3 种形式。</p>
<ol>
<li><code>&lt;?&gt;</code>被称作无限定的通配符。</li>
<li><code>&lt;? extends T&gt;</code>被称作有上限的通配符。</li>
<li><code>&lt;? super T&gt;</code>被称作有下限的通配符。</li>
</ol>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p><strong>泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除</strong>。</p>
<h3 id="带来的局限性"><a href="#带来的局限性" class="headerlink" title="带来的局限性"></a>带来的局限性</h3><p>类型擦除，是泛型能够与之前的 java 版本代码兼容共存的原因。但也因为类型擦除，它会抹掉很多继承相关的特性，这是它带来的局限性。</p>
<h2 id="泛型中值得注意的地方"><a href="#泛型中值得注意的地方" class="headerlink" title="泛型中值得注意的地方"></a>泛型中值得注意的地方</h2><h3 id="不接受-8-种基本数据类型"><a href="#不接受-8-种基本数据类型" class="headerlink" title="不接受 8 种基本数据类型"></a>不接受 8 种基本数据类型</h3><p>原因：只接受对象！！！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int-&gt;integer</span><br><span class="line"></span><br><span class="line">boolean-&gt;Boolean</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>泛型其实就是方便编程以及减小代码冗余度，但是只是编译阶段起作用。</p>
<p>抽离了数据类型与代码逻辑，本意是提高程序代码的简洁性和可读性，并提供可能的编译时类型转换安全检测功能。</p>
]]></content>
      <categories>
        <category>Java进阶学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据结构</title>
    <url>/2020/12/27/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我有过数据结构的基础，学C++时都实现了一遍数据结构，所以相当于做记录，更偏向实际应用。</p>
<p>本博客相当于是笔记，只为了给自己以后方便查资料等，并不是自己写的内容，因为我也是正在学。</p>
<p>基本复制来的加上自己手敲代码给自己加深印象。</p>
<p>资源来自<a href="https://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟网</a></p>
<h2 id="Java-数据结构"><a href="#Java-数据结构" class="headerlink" title="Java 数据结构"></a>Java 数据结构</h2><p>Java工具包提供了强大的数据结构。在Java中的数据结构主要包括以下几种接口和类：</p>
<ul>
<li>枚举（Enumeration）</li>
<li>位集合（BitSet）</li>
<li>向量（Vector）</li>
<li>栈（Stack）</li>
<li>字典（Dictionary）</li>
<li>哈希表（Hashtable）</li>
<li>属性（Properties）</li>
</ul>
<h3 id="枚举（Enumeration）"><a href="#枚举（Enumeration）" class="headerlink" title="枚举（Enumeration）"></a>枚举（Enumeration）</h3><p>枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。 枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。</p>
<p>例如，枚举定义了一个叫nextElement 的方法，该方法用来得到一个包含多元素的数据结构的下一个元素。</p>
<p>Enumeration接口中定义了一些方法，通过这些方法可以枚举（一次获得一个）对象集合中的元素。</p>
<p>这种传统接口已被迭代器取代，虽然Enumeration 还未被遗弃，但在现代代码中已经被很少使用了。尽管如此，它还是使用在诸如Vector和Properties这些传统类所定义的方法中，除此之外，还用在一些API类，并且在应用程序中也广泛被使用。 下表总结了一些Enumeration声明的方法：</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="center"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="center"><strong>boolean hasMoreElements( )</strong>  测试此枚举是否包含更多的元素。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="center"><strong>Object nextElement( )</strong> 如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素。</td>
</tr>
</tbody></table>
<p>实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">package hello;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumerationTest</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Enumeration&lt;String&gt; days;</span><br><span class="line">        Vector&lt;String&gt; week = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">        week.add(<span class="string">"Sunday"</span>);</span><br><span class="line">        week.add(<span class="string">"Monday"</span>);</span><br><span class="line">        week.add(<span class="string">"Tuesday"</span>);</span><br><span class="line">        week.add(<span class="string">"Wednesday"</span>);</span><br><span class="line">        week.add(<span class="string">"Thursday"</span>);</span><br><span class="line">        week.add(<span class="string">"Friday"</span>);</span><br><span class="line">        week.add(<span class="string">"Saturday"</span>);</span><br><span class="line">        days = week.elements();</span><br><span class="line">        <span class="keyword">while</span>(days.hasMoreElements())&#123;</span><br><span class="line">            System.out.println(days.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2020/12/27/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.png" alt></p>
<h3 id="位集合（BitSet）"><a href="#位集合（BitSet）" class="headerlink" title="位集合（BitSet）"></a>位集合（BitSet）</h3><p>位集合类实现了一组可以单独设置和清除的位或标志。</p>
<p>该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一”位”，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。</p>
<p>一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。这和位向量（vector of bits）比较类似。</p>
<p>这是一个传统的类，但它在Java 2中被完全重新设计。</p>
<p>BitSet定义了两个构造方法。</p>
<p>第一个构造方法创建一个默认的对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BitSet()</span><br></pre></td></tr></table></figure>

<p>第二个方法允许用户指定初始大小。所有位初始化为0。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BitSet(int size)</span><br></pre></td></tr></table></figure>

<h3 id="向量（Vector）"><a href="#向量（Vector）" class="headerlink" title="向量（Vector）"></a>向量（Vector）</h3><p>向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。</p>
<p>和数组一样，Vector对象的元素也能通过索引访问。</p>
<p>使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。</p>
<p>Vector 类实现了一个动态数组。和 ArrayList 很相似，但是两者是不同的：</p>
<ul>
<li>Vector 是同步访问的。</li>
<li>Vector 包含了许多传统的方法，这些方法不属于集合框架。</li>
</ul>
<p>Vector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。</p>
<p>Vector 类支持 4 种构造方法。</p>
<p>第一种构造方法创建一个默认的向量，默认大小为 10：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vector()</span><br></pre></td></tr></table></figure>

<p>第二种构造方法创建指定大小的向量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vector(int size)</span><br></pre></td></tr></table></figure>

<p>第三种构造方法创建指定大小的向量，并且增量用 incr 指定。增量表示向量每次增加的元素数目。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vector(int size,int incr)</span><br></pre></td></tr></table></figure>

<p>第四种构造方法创建一个包含集合 c 元素的向量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vector(Collection c)</span><br></pre></td></tr></table></figure>

<p>一堆接口：比较两个接口，其他接口用到再写：</p>
<p> int size()   返回此向量中的组件数。</p>
<p> Enumeration elements()  返回此向量的组件的枚举。</p>
<p>int capacity() 返回此向量的当前容量。</p>
<p><strong>容量可以构造时指定，而size表示容器中现在有的对象个数。</strong></p>
<h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><p>栈（Stack）实现了一个后进先出（LIFO）的数据结构。</p>
<p>你可以把栈理解为对象的垂直分布的栈，当你添加一个新元素时，就将新元素放在其他元素的顶部。</p>
<p>当你从栈中取元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。</p>
<p><strong>除了由Vector定义的所有方法，自己也定义了一些方法：</strong></p>
<p>堆栈只定义了默认构造函数，用来创建一个空栈。 堆栈除了包括由Vector定义的所有方法，也定义了自己的一些方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stack()</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">boolean empty()  测试堆栈是否为空。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Object peek( ) 查看堆栈顶部的对象，但不从堆栈中移除它。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">Object pop( ) 移除堆栈顶部的对象，并作为此函数的值返回该对象。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">Object push(Object element) 把项压入堆栈顶部。</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">int search(Object element) 返回对象在堆栈中的位置，以 1 为基数。</td>
</tr>
</tbody></table>
<h3 id="字典（Dictionary）"><a href="#字典（Dictionary）" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h3><p>字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。</p>
<p>当你想要通过特定的键而不是整数索引来访问数据的时候，这时候应该使用Dictionary。</p>
<p>由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。</p>
<p>类似于C++的map</p>
<p>Dictionary 类是一个抽象类，用来存储键/值对，作用和Map类相似。</p>
<p>给出键和值，你就可以将值存储在Dictionary对象中。一旦该值被存储，就可以通过它的键来获取它。所以和Map一样， Dictionary 也可以作为一个键/值对列表。</p>
<p>Dictionary定义的抽象方法如下表所示：</p>
<table>
<thead>
<tr>
<th align="center"><strong>序号</strong></th>
<th align="center"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><strong>Enumeration elements( )</strong> 返回此 dictionary 中值的枚举。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><strong>Object get(Object key)</strong> 返回此 dictionary 中该键所映射到的值。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><strong>boolean isEmpty( )</strong> 测试此 dictionary 是否不存在从键到值的映射。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><strong>Enumeration keys( )</strong> 返回此 dictionary 中的键的枚举。</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><strong>Object put(Object key, Object value)</strong> 将指定 key 映射到此 dictionary 中指定 value。</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><strong>Object remove(Object key)</strong> 从此 dictionary 中移除 key （及其相应的 value）。</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><strong>int size( )</strong> 返回此 dictionary 中条目（不同键）的数量。</td>
</tr>
</tbody></table>
<p>Dictionary类已经过时了。在实际开发中，你可以实现Map接口来获取键/值的存储功能。</p>
<h3 id="哈希表（Hashtable）"><a href="#哈希表（Hashtable）" class="headerlink" title="哈希表（Hashtable）"></a>哈希表（Hashtable）</h3><p>Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。</p>
<p>例如，在地址列表的哈希表中，你可以根据邮政编码作为键来存储和排序数据，而不是通过人名。</p>
<p>哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。</p>
<h4 id="Java-Hashtable-类"><a href="#Java-Hashtable-类" class="headerlink" title="Java Hashtable 类"></a>Java Hashtable 类</h4><p>Hashtable是原始的java.util的一部分， 是一个Dictionary具体的实现 。</p>
<p>然而，Java 2 重构的Hashtable实现了Map接口，因此，Hashtable现在集成到了集合框架中。它和HashMap类很相似，但是它支持同步。</p>
<p>像HashMap一样，Hashtable在哈希表中存储键/值对。当使用一个哈希表，要指定用作键的对象，以及要链接到该键的值。</p>
<p>然后，该键经过哈希处理，所得到的散列码被用作存储在该表中值的索引。</p>
<p>Hashtable定义了四个构造方法。第一个是默认构造方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hashtable()</span><br></pre></td></tr></table></figure>

<p>第二个构造函数创建指定大小的哈希表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hashtable(int size)</span><br></pre></td></tr></table></figure>

<p>第三个构造方法创建了一个指定大小的哈希表，并且通过fillRatio指定填充比例。</p>
<p>填充比例必须介于0.0和1.0之间，它决定了哈希表在重新调整大小之前的充满程度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hashtable(int size,float fillRatio)</span><br></pre></td></tr></table></figure>

<p>第四个构造方法创建了一个以M中元素为初始化元素的哈希表。</p>
<p>哈希表的容量被设置为M的两倍。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hashtable(Map m)</span><br></pre></td></tr></table></figure>

<h3 id="属性（Properties）"><a href="#属性（Properties）" class="headerlink" title="属性（Properties）"></a>属性（Properties）</h3><p>Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。</p>
<p>Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。</p>
<h4 id="Java-Properties-类"><a href="#Java-Properties-类" class="headerlink" title="Java Properties 类"></a>Java Properties 类</h4><p>Properties 继承于 Hashtable。表示一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。</p>
<p>Properties 类被许多 Java 类使用。例如，在获取环境变量时它就作为 System.getProperties() 方法的返回值。</p>
<p>Properties 定义如下实例变量.这个变量持有一个 Properties 对象相关的默认属性列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Properties defaults;</span><br></pre></td></tr></table></figure>

<p>Properties类定义了两个构造方法. 第一个构造方法没有默认值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Properties()</span><br></pre></td></tr></table></figure>

<p>第二个构造方法使用propDefault 作为默认值。两种情况下，属性列表都为空：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Properties(Properties propDefault)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>先大致过一遍，后面搞项目练手时不至于遇到就卡住！</p>
]]></content>
      <categories>
        <category>Java进阶学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象</title>
    <url>/2020/12/27/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<a id="more"></a>

<p>JAVA是一门纯面向对象的语言。</p>
<h2 id="1-Java-继承"><a href="#1-Java-继承" class="headerlink" title="1.Java 继承"></a>1.Java 继承</h2><h3 id="1-1继承的概念"><a href="#1-1继承的概念" class="headerlink" title="1.1继承的概念"></a>1.1继承的概念</h3><p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p>
<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<p>所以继承需要符合的关系是：is-a，父类更通用，子类更具体。</p>
<h3 id="1-2类的继承格式"><a href="#1-2类的继承格式" class="headerlink" title="1.2类的继承格式"></a>1.2类的继承格式</h3><p>在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类 </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3为什么需要继承"><a href="#1-3为什么需要继承" class="headerlink" title="1.3为什么需要继承"></a>1.3为什么需要继承</h3><p>一个简单例子：</p>
<p>不使用继承，代码重复：</p>
<p><img src="/2020/12/27/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.png" alt></p>
<p><img src="/2020/12/27/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2.png" alt></p>
<p>使用继承之后：</p>
<p><img src="/2020/12/27/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3.png" alt></p>
<p>从这两段代码可以看出来，代码存在重复了，导致后果就是代码量大且臃肿，而且维护性不高(维护性主要是后期需要修改的时候，就需要修改很多的代码，容易出错)，所以要从根本上解决这两段代码的问题，就需要继承，将两段代码中相同的部分提取出来组成 一个父类.</p>
<h3 id="1-4继承类型"><a href="#1-4继承类型" class="headerlink" title="1.4继承类型"></a>1.4继承类型</h3><p>需要注意的是 Java 不支持多继承，但支持多重继承。(C++支持多继承)</p>
<p><img src="/2020/12/27/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/E:%5CBlog%5Csource_posts%5CJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%5C4.png" alt></p>
<h3 id="1-5继承的特性"><a href="#1-5继承的特性" class="headerlink" title="1.5继承的特性"></a>1.5继承的特性</h3><ul>
<li>子类拥有父类非 private 的属性、方法。</li>
<li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
<li>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</li>
<li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li>
</ul>
<h3 id="1-6-继承关键字"><a href="#1-6-继承关键字" class="headerlink" title="1.6 继承关键字"></a>1.6 继承关键字</h3><p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 <strong>java.lang</strong> 包中，所以不需要 <strong>import</strong>）祖先类。</p>
<h4 id="1-6-1extends关键字"><a href="#1-6-1extends关键字" class="headerlink" title="1.6.1extends关键字"></a>1.6.1extends关键字</h4><p>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p>
<h4 id="1-6-2implements关键字"><a href="#1-6-2implements关键字" class="headerlink" title="1.6.2implements关键字"></a>1.6.2implements关键字</h4><p>使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p>
<h4 id="1-6-3super-与-this-关键字"><a href="#1-6-3super-与-this-关键字" class="headerlink" title="1.6.3super 与 this 关键字"></a>1.6.3super 与 this 关键字</h4><p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p>
<p>this关键字：指向自己的引用。</p>
<h4 id="1-6-4final关键字"><a href="#1-6-4final关键字" class="headerlink" title="1.6.4final关键字"></a>1.6.4final关键字</h4><p>final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：</p>
<h4 id="1-6-5-构造器"><a href="#1-6-5-构造器" class="headerlink" title="1.6.5 构造器"></a>1.6.5 构造器</h4><p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 <strong>super</strong> 关键字调用父类的构造器并配以适当的参数列表。</p>
<p>如果父类构造器没有参数，则在子类的构造器中不需要使用 <strong>super</strong> 关键字调用父类构造器，系统会自动调用父类的无参构造器。</p>
<h2 id="2-Java-重写-Override-与重载-Overload"><a href="#2-Java-重写-Override-与重载-Overload" class="headerlink" title="2.Java 重写(Override)与重载(Overload)"></a>2.Java 重写(Override)与重载(Overload)</h2><h3 id="2-1重写-Override"><a href="#2-1重写-Override" class="headerlink" title="2.1重写(Override)"></a>2.1重写(Override)</h3><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong></p>
<p>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p>
<p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。</p>
<p>在编译阶段，只检查参数的引用类型。</p>
<p>然而在运行时，Java 虚拟机(JVM)指定对象的类型并且运行该对象的方法。</p>
<h4 id="2-1-1方法的重写规则"><a href="#2-1-1方法的重写规则" class="headerlink" title="2.1.1方法的重写规则"></a>2.1.1方法的重写规则</h4><ul>
<li>参数列表与被重写方法的参数列表必须完全相同。</li>
<li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</li>
<li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</li>
<li>父类的成员方法只能被它的子类重写。</li>
<li>声明为 final 的方法不能被重写。</li>
<li>声明为 static 的方法不能被重写，但是能够被再次声明。</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li>
<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li>
<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li>
<li>构造方法不能被重写。</li>
<li>如果不能继承一个类，则不能重写该类的方法。</li>
</ul>
<h4 id="2-1-2Super-关键字的使用"><a href="#2-1-2Super-关键字的使用" class="headerlink" title="2.1.2Super 关键字的使用"></a>2.1.2Super 关键字的使用</h4><p>当需要在子类中调用父类的被重写方法时，要使用 super 关键字。</p>
<h3 id="2-2重载-Overload"><a href="#2-2重载-Overload" class="headerlink" title="2.2重载(Overload)"></a>2.2重载(Overload)</h3><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>
<p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>
<p>最常用的地方就是构造器的重载。</p>
<h4 id="2-2-1重载规则"><a href="#2-2-1重载规则" class="headerlink" title="2.2.1重载规则:"></a>2.2.1重载规则:</h4><ul>
<li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li>
<li>被重载的方法可以改变返回类型；</li>
<li>被重载的方法可以改变访问修饰符；</li>
<li>被重载的方法可以声明新的或更广的检查异常；</li>
<li>方法能够在同一个类中或者在一个子类中被重载。</li>
<li>无法以返回值类型作为重载函数的区分标准。</li>
</ul>
<h3 id="2-3重写与重载之间的区别"><a href="#2-3重写与重载之间的区别" class="headerlink" title="2.3重写与重载之间的区别"></a>2.3重写与重载之间的区别</h3><table>
<thead>
<tr>
<th align="center">区别点</th>
<th align="center">重载方法</th>
<th align="center">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数列表</td>
<td align="center">必须修改</td>
<td align="center">一定不能修改</td>
</tr>
<tr>
<td align="center">返回类型</td>
<td align="center">可以修改</td>
<td align="center">一定不能修改</td>
</tr>
<tr>
<td align="center">异常</td>
<td align="center">可以修改</td>
<td align="center">可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td align="center">访问</td>
<td align="center">可以修改</td>
<td align="center">一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody></table>
<h3 id="2-4总结："><a href="#2-4总结：" class="headerlink" title="2.4总结："></a>2.4总结：</h3><p>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p>
<ul>
<li>(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</li>
<li>(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</li>
<li>(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li>
</ul>
<p><img src="/2020/12/27/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/5.png" alt></p>
<h2 id="3-Java-多态"><a href="#3-Java-多态" class="headerlink" title="3.Java 多态"></a>3.Java 多态</h2><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>
<p>多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：</p>
<h3 id="3-1多态的优点"><a href="#3-1多态的优点" class="headerlink" title="3.1多态的优点"></a>3.1多态的优点</h3><ul>
<li><ol>
<li>消除类型之间的耦合关系</li>
</ol>
</li>
<li><ol start="2">
<li>可替换性</li>
</ol>
</li>
<li><ol start="3">
<li>可扩充性</li>
</ol>
</li>
<li><ol start="4">
<li>接口性</li>
</ol>
</li>
<li><ol start="5">
<li>灵活性</li>
</ol>
</li>
<li><ol start="6">
<li>简化性</li>
</ol>
</li>
</ul>
<h3 id="3-2多态存在的三个必要条件"><a href="#3-2多态存在的三个必要条件" class="headerlink" title="3.2多态存在的三个必要条件"></a>3.2多态存在的三个必要条件</h3><ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象：<strong>Parent p = new Child();</strong></li>
</ul>
<p><img src="/2020/12/27/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/6.png" alt></p>
<h3 id="3-3虚函数"><a href="#3-3虚函数" class="headerlink" title="3.3虚函数"></a>3.3虚函数</h3><p>虚函数的存在是为了多态。</p>
<p>Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。</p>
<h3 id="3-4多态的实现方式"><a href="#3-4多态的实现方式" class="headerlink" title="3.4多态的实现方式"></a>3.4多态的实现方式</h3><h4 id="方式一：重写"><a href="#方式一：重写" class="headerlink" title="方式一：重写"></a>方式一：重写</h4><h4 id="方式二：接口"><a href="#方式二：接口" class="headerlink" title="方式二：接口"></a>方式二：接口</h4><h4 id="方式三：抽象类和抽象方法"><a href="#方式三：抽象类和抽象方法" class="headerlink" title="方式三：抽象类和抽象方法"></a>方式三：抽象类和抽象方法</h4><h2 id="4-Java-抽象类"><a href="#4-Java-抽象类" class="headerlink" title="4.Java 抽象类"></a>4.Java 抽象类</h2><h3 id="4-1抽象类"><a href="#4-1抽象类" class="headerlink" title="4.1抽象类"></a>4.1抽象类</h3><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p>
<p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p>
<p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p>
<p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p>
<p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<p>抽象类不能实例化：</p>
<p><img src="/2020/12/27/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/7.png" alt></p>
<h3 id="4-2抽象方法"><a href="#4-2抽象方法" class="headerlink" title="4.2抽象方法"></a>4.2抽象方法</h3><p>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p>
<p>Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p>
<p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p>
<p><strong>声明抽象方法会造成以下两个结果：</strong></p>
<ul>
<li>如果一个类包含抽象方法，那么该类必须是抽象类。</li>
<li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li>
</ul>
<p>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p>
<h3 id="4-3抽象类总结规定"><a href="#4-3抽象类总结规定" class="headerlink" title="4.3抽象类总结规定"></a>4.3抽象类总结规定</h3><ul>
<li><ol>
<li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li>
</ol>
</li>
<li><ol start="2">
<li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
</ol>
</li>
<li><ol start="3">
<li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li>
</ol>
</li>
<li><ol start="4">
<li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li>
</ol>
</li>
<li><ol start="5">
<li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li>
</ol>
</li>
</ul>
<h2 id="5-Java-封装"><a href="#5-Java-封装" class="headerlink" title="5.Java 封装"></a>5.Java 封装</h2><p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。</p>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>
<p>要访问该类的代码和数据，必须通过严格的接口控制。</p>
<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p>
<p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>
<h3 id="5-1封装的优点"><a href="#5-1封装的优点" class="headerlink" title="5.1封装的优点"></a>5.1封装的优点</h3><ul>
<li><ol>
<li>良好的封装能够减少耦合。</li>
</ol>
</li>
<li><ol start="2">
<li>类内部的结构可以自由修改。</li>
</ol>
</li>
<li><ol start="3">
<li>可以对成员变量进行更精确的控制。</li>
</ol>
</li>
<li><ol start="4">
<li>隐藏信息，实现细节。</li>
</ol>
</li>
</ul>
<h3 id="5-2实现Java封装的步骤"><a href="#5-2实现Java封装的步骤" class="headerlink" title="5.2实现Java封装的步骤"></a>5.2实现Java封装的步骤</h3><h4 id="5-2-1修改属性的可见性来限制对属性的访问（一般限制为private），例如："><a href="#5-2-1修改属性的可见性来限制对属性的访问（一般限制为private），例如：" class="headerlink" title="5.2.1修改属性的可见性来限制对属性的访问（一般限制为private），例如："></a>5.2.1修改属性的可见性来限制对属性的访问（一般限制为private），例如：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中，将 <strong>name</strong> 和 <strong>age</strong> 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。</p>
<h4 id="5-2-2对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如："><a href="#5-2-2对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：" class="headerlink" title="5.2.2对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如："></a>5.2.2对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用 <strong>this</strong> 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。</p>
<h2 id="6-Java-接口"><a href="#6-Java-接口" class="headerlink" title="6.Java 接口"></a>6.Java 接口</h2><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p>
<p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p>
<p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>
<h3 id="6-1接口与类相似点："><a href="#6-1接口与类相似点：" class="headerlink" title="6.1接口与类相似点："></a>6.1接口与类相似点：</h3><ul>
<li>一个接口可以有多个方法。</li>
<li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li>
<li>接口的字节码文件保存在 .class 结尾的文件中。</li>
<li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li>
</ul>
<h3 id="6-2接口与类的区别："><a href="#6-2接口与类的区别：" class="headerlink" title="6.2接口与类的区别："></a>6.2接口与类的区别：</h3><ul>
<li>接口不能用于实例化对象。</li>
<li>接口没有构造方法。</li>
<li>接口中所有的方法必须是抽象方法。</li>
<li>接口不能包含成员变量，除了 static 和 final 变量。</li>
<li>接口不是被类继承了，而是要被类实现。</li>
<li>接口支持多继承。</li>
</ul>
<h3 id="6-3接口特性"><a href="#6-3接口特性" class="headerlink" title="6.3接口特性"></a>6.3接口特性</h3><ul>
<li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</li>
<li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</li>
<li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li>
</ul>
<h3 id="6-4抽象类和接口的区别"><a href="#6-4抽象类和接口的区别" class="headerlink" title="6.4抽象类和接口的区别"></a>6.4抽象类和接口的区别</h3><ul>
<li><ol>
<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li>
</ol>
</li>
<li><ol start="2">
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li>
</ol>
</li>
<li><ol start="3">
<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li>
</ol>
</li>
<li><ol start="4">
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ol>
</li>
</ul>
<h3 id="6-5接口的声明"><a href="#6-5接口的声明" class="headerlink" title="6.5接口的声明"></a>6.5接口的声明</h3><p>规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[可见度] interface 接口名称 [extends 其他的接口名] &#123;</span><br><span class="line">        <span class="comment">// 声明变量</span></span><br><span class="line">        <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口有以下特性：</p>
<ul>
<li>接口是隐式抽象的，当声明一个接口的时候，不必使用<strong>abstract</strong>关键字。</li>
<li>接口中每一个方法也是隐式抽象的，声明时同样不需要<strong>abstract</strong>关键字。</li>
<li>接口中的方法都是公有的。</li>
</ul>
<h3 id="6-6接口的实现"><a href="#6-6接口的实现" class="headerlink" title="6.6接口的实现"></a>6.6接口的实现</h3><p>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。</p>
<p>类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。</p>
<p>实现一个接口的语法，可以使用这个公式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...</span><br></pre></td></tr></table></figure>

<p>重写接口中声明的方法时，需要注意以下规则：</p>
<ul>
<li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li>
<li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li>
<li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li>
</ul>
<p>在实现接口的时候，也要注意一些规则：</p>
<ul>
<li>一个类可以同时实现多个接口。</li>
<li>一个类只能继承一个类，但是能实现多个接口。</li>
<li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li>
</ul>
<h3 id="6-7接口的继承"><a href="#6-7接口的继承" class="headerlink" title="6.7接口的继承"></a>6.7接口的继承</h3><p>一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。</p>
<h3 id="6-8接口的多继承"><a href="#6-8接口的多继承" class="headerlink" title="6.8接口的多继承"></a>6.8接口的多继承</h3><p>在Java中，类的多继承是不合法，但接口允许多继承。</p>
<p>在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hockey</span> <span class="keyword">extends</span> <span class="title">Sports</span>, <span class="title">Event</span></span></span><br></pre></td></tr></table></figure>

<h3 id="6-9标记接口"><a href="#6-9标记接口" class="headerlink" title="6.9标记接口"></a>6.9标记接口</h3><p>最常用的继承接口是没有包含任何方法的接口。</p>
<p>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</p>
<p>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p>
<p>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventListener</span></span></span><br><span class="line"><span class="class"></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p>
<ul>
<li><p>建立一个公共的父接口：</p>
<p>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p>
</li>
<li><p>向一个类添加数据类型：</p>
<p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p>
</li>
</ul>
<h2 id="7-Java-枚举-enum"><a href="#7-Java-枚举-enum" class="headerlink" title="7.Java 枚举(enum)"></a>7.Java 枚举(enum)</h2><p>Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。</p>
<p>Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 <strong>,</strong> 来分割。</p>
<p>例如定义一个颜色的枚举类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Color </span><br><span class="line">&#123; </span><br><span class="line">    RED, GREEN, BLUE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 执行输出结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Color c1 = Color.RED;</span><br><span class="line">        System.out.println(c1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：RED</p>
<h3 id="7-1内部类中使用枚举"><a href="#7-1内部类中使用枚举" class="headerlink" title="7.1内部类中使用枚举"></a>7.1内部类中使用枚举</h3><p>枚举类也可以声明在内部类中</p>
<h3 id="7-2迭代枚举元素"><a href="#7-2迭代枚举元素" class="headerlink" title="7.2迭代枚举元素"></a>7.2迭代枚举元素</h3><p>可以使用 for 语句来迭代枚举元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Color myVar : Color.values()) &#123;</span><br><span class="line">      System.out.println(myVar);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和C++中的枚举区别很大</p>
<h3 id="7-3在-switch-中使用枚举类"><a href="#7-3在-switch-中使用枚举类" class="headerlink" title="7.3在 switch 中使用枚举类"></a>7.3在 switch 中使用枚举类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Color myVar = Color.BLUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(myVar) &#123;</span><br><span class="line">      <span class="keyword">case</span> RED:</span><br><span class="line">        System.out.println(<span class="string">"红色"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> GREEN:</span><br><span class="line">         System.out.println(<span class="string">"绿色"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> BLUE:</span><br><span class="line">        System.out.println(<span class="string">"蓝色"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4values-ordinal-和-valueOf-方法"><a href="#7-4values-ordinal-和-valueOf-方法" class="headerlink" title="7.4values(), ordinal() 和 valueOf() 方法"></a>7.4values(), ordinal() 和 valueOf() 方法</h3><p>enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。</p>
<p>values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：</p>
<ul>
<li>values() 返回枚举类中所有的值。</li>
<li>ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。</li>
<li>valueOf()方法返回指定字符串值的枚举常量。</li>
</ul>
<h2 id="8-Java-包-package"><a href="#8-Java-包-package" class="headerlink" title="8.Java 包(package)"></a>8.Java 包(package)</h2><p>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。</p>
<p>C++中使用using namespace的编译指令区别！！！</p>
<h3 id="8-1包的作用"><a href="#8-1包的作用" class="headerlink" title="8.1包的作用"></a>8.1包的作用</h3><ul>
<li>1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</li>
<li>2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li>
<li>3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li>
</ul>
<p>Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。</p>
<p>包语句的语法格式为：</p>
<p><code>package pkg1[．pkg2[．pkg3…]];</code></p>
<h3 id="8-2创建包"><a href="#8-2创建包" class="headerlink" title="8.2创建包"></a>8.2创建包</h3><p><img src="/2020/12/27/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/8.png" alt></p>
<p>然后可以把自己的包打包成jar包，并调用</p>
<h3 id="8-3import-关键字"><a href="#8-3import-关键字" class="headerlink" title="8.3import 关键字"></a>8.3import 关键字</h3><p>为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 “import” 语句可完成此功能。</p>
<p>在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为：<br><code>port package1[.package2…].(classname|*);</code></p>
<h3 id="8-4package-的目录结构"><a href="#8-4package-的目录结构" class="headerlink" title="8.4package 的目录结构"></a>8.4package 的目录结构</h3><p>类放在包中会有两种主要的结果：</p>
<ul>
<li>包名成为类名的一部分，正如我们前面讨论的一样。</li>
<li>包名必须与相应的字节码所在的目录结构相吻合。</li>
</ul>
<p>下面是管理你自己 java 中文件的一种简单方式：</p>
<ul>
<li>将类、接口等类型的源码放在一个文本中，这个文件的名字就是这个类型的名字，并以.java作为扩展名。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名 :  Car.java</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">package</span> vehicle;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 类实现  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来，把源文件放在一个目录中，这个目录要对应类所在包的名字。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">....\vehicle\Car.java</span><br></pre></td></tr></table></figure>

<ul>
<li><p>现在，正确的类名和路径将会是如下样子：</p>
<ul>
<li>类名 -&gt; vehicle.Car</li>
<li>路径名 -&gt; vehicle\Car.java (在 windows 系统中)</li>
</ul>
<p>通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是 runoob.com，所有的包名都以 com.runoob 开头。包名中的每一个部分对应一个子目录。</p>
<p>例如：有一个 <strong>com.runoob.test</strong> 的包，这个包包含一个叫做 Runoob.java 的源文件，那么相应的，应该有如下面的一连串子目录：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">....\com\runoob\test\Runoob.java</span><br></pre></td></tr></table></figure>

<ul>
<li>编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类型的名字，并加上 .class 作为扩展后缀。 例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名: Runoob.java</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">package</span> com.runoob.test;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runoob</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Google</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>现在，我们用-d选项来编译这个文件，如下：</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$javac -d . Runoob.java</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>这样会像下面这样放置编译了的文件：</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\com\runoob\test\Runoob.class</span><br><span class="line">.\com\runoob\test\Google.class</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>你可以像下面这样来导入所有 <strong>\com\runoob\test\</strong> 中定义的类、接口等：</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.runoob.test.*;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>编译之后的 .class 文件应该和 .java 源文件一样，它们放置的目录应该跟包的名字对应起来。但是，并不要求 .class 文件的路径跟相应的 .java 的路径一样。你可以分开来安排源码和类的目录。</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;path-one&gt;\sources\com\runoob\test\Runoob.java</span><br><span class="line">&lt;path-two&gt;\classes\com\runoob\test\Google.class</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这样，你可以将你的类目录分享给其他的编程人员，而不用透露自己的源码。用这种方法管理源码和类文件可以让编译器和java 虚拟机（JVM）可以找到你程序中使用的所有类型。</p>
<p>类目录的绝对路径叫做 <strong>class path</strong>。设置在系统变量 <strong>CLASSPATH</strong> 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。</p>
<p><path- two>\classes 是 class path，package 名字是 com.runoob.test,而编译器和 JVM 会在 <path-two>\classes\com\runoob\test 中找 .class 文件。</path-two></path-></p>
<p>一个 class path 可能会包含好几个路径，多路径应该用分隔符分开。默认情况下，编译器和 JVM 查找当前目录。JAR 文件按包含 Java 平台相关的类，所以他们的目录默认放在了 class path 中。</p>
<h3 id="8-5设置-CLASSPATH-系统变量"><a href="#8-5设置-CLASSPATH-系统变量" class="headerlink" title="8.5设置 CLASSPATH 系统变量"></a>8.5设置 CLASSPATH 系统变量</h3><p>就像安装JDK时设置系统变量一样用自己的包！！！</p>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础语法</title>
    <url>/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="Java-源程序与编译型运行区别"><a href="#Java-源程序与编译型运行区别" class="headerlink" title="Java 源程序与编译型运行区别"></a>Java 源程序与编译型运行区别</h2><p><img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/1.png" alt></p>
<h2 id="Java-对象和类"><a href="#Java-对象和类" class="headerlink" title="Java 对象和类"></a>Java 对象和类</h2><p>Java作为一种面向对象语言。支持以下基本概念：</p>
<ul>
<li>多态</li>
<li>继承</li>
<li>封装</li>
<li>抽象</li>
<li>类</li>
<li>对象</li>
<li>实例</li>
<li>方法</li>
<li>重载</li>
</ul>
<h3 id="对象和类的概念。"><a href="#对象和类的概念。" class="headerlink" title="对象和类的概念。"></a>对象和类的概念。</h3><ul>
<li><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>
<li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li>
</ul>
<h3 id="一个类可以包含以下类型变量："><a href="#一个类可以包含以下类型变量：" class="headerlink" title="一个类可以包含以下类型变量："></a>一个类可以包含以下类型变量：</h3><ul>
<li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>
<li><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。</p>
<p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puppy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这个构造器仅有一个参数：name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h3><p>当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。</p>
<ul>
<li>一个源文件中只能有一个 public 类</li>
<li>一个源文件可以有多个非 public 类</li>
<li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。</li>
<li>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。</li>
<li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。</li>
<li>import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li>
</ul>
<h2 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h2><p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。</p>
<p>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。</p>
<p><img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/2.png" alt></p>
<p>因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p>
<p>Java 的两大数据类型:</p>
<ul>
<li>内置数据类型</li>
<li>引用数据类型</li>
</ul>
<h3 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h3><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>
<p><strong>byte：</strong></p>
<ul>
<li>byte 数据类型是8位、有符号的，以二进制补码表示的整数；</li>
<li>最小值是 <strong>-128（-2^7）</strong>；</li>
<li>最大值是 <strong>127（2^7-1）</strong>；</li>
<li>默认值是 <strong>0</strong>；</li>
<li>byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；</li>
<li>例子：byte a = 100，byte b = -50。</li>
</ul>
<p><strong>short：</strong></p>
<ul>
<li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li>
<li>最小值是 <strong>-32768（-2^15）</strong>；</li>
<li>最大值是 <strong>32767（2^15 - 1）</strong>；</li>
<li>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li>
<li>默认值是 <strong>0</strong>；</li>
<li>例子：short s = 1000，short r = -20000。</li>
</ul>
<p><strong>int：</strong></p>
<ul>
<li>int 数据类型是32位、有符号的以二进制补码表示的整数；</li>
<li>最小值是 <strong>-2,147,483,648（-2^31）</strong>；</li>
<li>最大值是 <strong>2,147,483,647（2^31 - 1）</strong>；</li>
<li>一般地整型变量默认为 int 类型；</li>
<li>默认值是 <strong>0</strong> ；</li>
<li>例子：int a = 100000, int b = -200000。</li>
</ul>
<p><strong>long：</strong></p>
<ul>
<li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li>
<li>最小值是 <strong>-9,223,372,036,854,775,808（-2^63）</strong>；</li>
<li>最大值是 <strong>9,223,372,036,854,775,807（2^63 -1）</strong>；</li>
<li>这种类型主要使用在需要比较大整数的系统上；</li>
<li>默认值是 <strong>0L</strong>；</li>
<li>例子： long a = 100000L，Long b = -200000L。<br>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。</li>
</ul>
<p><strong>float：</strong></p>
<ul>
<li>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li>
<li>float 在储存大型浮点数组的时候可节省内存空间；</li>
<li>默认值是 <strong>0.0f</strong>；</li>
<li>浮点数不能用来表示精确的值，如货币；</li>
<li>例子：float f1 = 234.5f。</li>
</ul>
<p><strong>double：</strong></p>
<ul>
<li>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；</li>
<li>浮点数的默认类型为double类型；</li>
<li>double类型同样不能表示精确的值，如货币；</li>
<li>默认值是 <strong>0.0d</strong>；</li>
<li>例子：double d1 = 123.4。</li>
</ul>
<p><strong>boolean：</strong></p>
<ul>
<li>boolean数据类型表示一位的信息；</li>
<li>只有两个取值：true 和 false；</li>
<li>这种类型只作为一种标志来记录 true/false 情况；</li>
<li>默认值是 <strong>false</strong>；</li>
<li>例子：boolean one = true。</li>
</ul>
<p><strong>char：</strong></p>
<ul>
<li>char类型是一个单一的 16 位 Unicode 字符；</li>
<li>最小值是 <strong>\u0000</strong>（即为 0）；</li>
<li>最大值是 <strong>\uffff</strong>（即为65、535）；</li>
<li>char 数据类型可以储存任何字符；</li>
<li>例子：char letter = ‘A’;。</li>
</ul>
<h3 id="类型默认值"><a href="#类型默认值" class="headerlink" title="类型默认值"></a>类型默认值</h3><table>
<thead>
<tr>
<th align="center"><strong>数据类型</strong></th>
<th align="center"><strong>默认值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">0L</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">0.0f</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">0.0d</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">‘u0000’</td>
</tr>
<tr>
<td align="center">String (or any object)</td>
<td align="center">null</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">false</td>
</tr>
</tbody></table>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul>
<li>在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型。变量一旦声明后，类型就不能被改变了。</li>
<li>对象、数组都是引用数据类型。</li>
<li>所有引用类型的默认值都是null。</li>
<li>一个引用变量可以用来引用任何与之兼容的类型。</li>
<li>例子：Site site = new Site(“Runoob”)。</li>
</ul>
<h3 id="Java-常量"><a href="#Java-常量" class="headerlink" title="Java 常量"></a>Java 常量</h3><p>常量在程序运行时是不能被修改的。</p>
<p>在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final double PI &#x3D; 3.1415927;</span><br></pre></td></tr></table></figure>

<h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">低  ------------------------------------&gt;  高</span><br><span class="line"></span><br><span class="line">byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double</span><br></pre></td></tr></table></figure>

<p>数据类型转换必须满足如下规则：</p>
<ul>
<li><ol>
<li>不能对boolean类型进行类型转换。</li>
</ol>
</li>
<li><ol start="2">
<li>不能把对象类型转换成不相关类的对象。</li>
</ol>
</li>
<li><ol start="3">
<li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</li>
</ol>
</li>
<li><ol start="4">
<li>转换过程中可能导致溢出或损失精度，例如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i &#x3D;128;   </span><br><span class="line">byte b &#x3D; (byte)i;</span><br></pre></td></tr></table></figure>

<p>因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p>
</li>
<li><ol start="5">
<li>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(int)23.7 &#x3D;&#x3D; 23;        </span><br><span class="line">(int)-45.89f &#x3D;&#x3D; -45</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="自动类型转换-1"><a href="#自动类型转换-1" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ul>
<li><ol>
<li>条件是转换的数据类型必须是兼容的。</li>
</ol>
</li>
<li><ol start="2">
<li>格式：(type)value type是要强制类型转换后的数据类型 实例：</li>
</ol>
</li>
</ul>
<h4 id="隐含强制类型转换"><a href="#隐含强制类型转换" class="headerlink" title="隐含强制类型转换"></a>隐含强制类型转换</h4><ul>
<li><ol>
<li>整数的默认类型是 int。</li>
</ol>
</li>
<li><ol start="2">
<li>浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f。</li>
</ol>
</li>
</ul>
<h2 id="Java-变量类型"><a href="#Java-变量类型" class="headerlink" title="Java 变量类型"></a>Java 变量类型</h2><ul>
<li>类变量：独立于方法之外的变量，用 static 修饰。</li>
<li>实例变量：独立于方法之外的变量，不过没有 static 修饰。</li>
<li>局部变量：类的方法中的变量。</li>
</ul>
<p><img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/3.png" alt>)<img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/4.png" alt></p>
<h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><ul>
<li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li>
<li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li>
<li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li>
<li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li>
<li>实例变量可以声明在使用前或者使用后；</li>
<li>访问修饰符可以修饰实例变量；</li>
<li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li>
<li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li>
<li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</li>
</ul>
<h3 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h3><ul>
<li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。</li>
<li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li>
<li>静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。</li>
<li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。</li>
<li>静态变量在第一次被访问时创建，在程序结束时销毁。</li>
<li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</li>
<li>默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li>
<li>静态变量可以通过：<em>ClassName.VariableName</em>的方式访问。</li>
<li>类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。</li>
</ul>
<h2 id="Java-修饰符"><a href="#Java-修饰符" class="headerlink" title="Java 修饰符"></a>Java 修饰符</h2><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p>
<ul>
<li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li>
<li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li>
<li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法</li>
<li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li>
</ul>
<p>我们可以通过以下表来说明访问权限：</p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="center">当前类</th>
<th align="center">同一包内</th>
<th align="center">子孙类(同一包)</th>
<th align="center">子孙类(不同包)</th>
<th align="center">其他包</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>public</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
</tr>
<tr>
<td align="left"><code>protected</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y/N</td>
<td align="center">N</td>
</tr>
<tr>
<td align="left"><code>default</code></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="center">N</td>
</tr>
<tr>
<td align="left"><code>private</code></td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
</tr>
</tbody></table>
<h4 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h4><ul>
<li>父类中声明为 public 的方法在子类中也必须为 public。</li>
<li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li>
<li>父类中声明为 private 的方法，不能够被继承。</li>
</ul>
<h3 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h3><p>static 修饰符，用来修饰类方法和类变量。</p>
<p>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p>
<p>abstract 修饰符，用来创建抽象类和抽象方法。</p>
<p>synchronized 和 volatile 修饰符，主要用于线程的编程。</p>
<h4 id="static-修饰符"><a href="#static-修饰符" class="headerlink" title="static 修饰符"></a>static 修饰符</h4><ul>
<li><p><strong>静态变量：</strong></p>
<p>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</p>
</li>
<li><p><strong>静态方法：</strong></p>
<p>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p>
</li>
</ul>
<h4 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h4><p><strong>final 变量：</strong></p>
<p>final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</p>
<p><strong>final 方法</strong></p>
<p>父类中的 final 方法可以被子类继承，但是不能被子类重写。</p>
<p>声明 final 方法的主要目的是防止该方法的内容被修改。</p>
<p><strong>final 类</strong></p>
<p>final 类不能被继承，没有类能够继承 final 类的任何特性。</p>
<h4 id="abstract-修饰符"><a href="#abstract-修饰符" class="headerlink" title="abstract 修饰符"></a>abstract 修饰符</h4><p><strong>抽象类：</strong></p>
<p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p>
<p>一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p>
<p><strong>抽象方法</strong></p>
<p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</p>
<p>抽象方法不能被声明成 final 和 static。</p>
<p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p>
<p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p>
<p>抽象方法的声明以分号结尾，例如：<strong>public abstract sample();</strong>。</p>
<h4 id="synchronized-修饰符"><a href="#synchronized-修饰符" class="headerlink" title="synchronized 修饰符"></a>synchronized 修饰符</h4><p>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</p>
<h4 id="transient-修饰符"><a href="#transient-修饰符" class="headerlink" title="transient 修饰符"></a>transient 修饰符</h4><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。</p>
<p>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p>
<p><code>public transient int limit = 55;   // 不会持久化</code></p>
<p><code>public int b; // 持久化</code></p>
<h4 id="volatile-修饰符"><a href="#volatile-修饰符" class="headerlink" title="volatile 修饰符"></a>volatile 修饰符</h4><p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p>
<p>一个 volatile 对象引用可能是 null。</p>
<h2 id="Java-运算符"><a href="#Java-运算符" class="headerlink" title="Java 运算符"></a>Java 运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table>
<thead>
<tr>
<th align="center">+</th>
<th align="center">加法 - 相加运算符两侧的值</th>
<th align="center">A + B 等于 30</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-</td>
<td align="center">减法 - 左操作数减去右操作数</td>
<td align="center">A – B 等于 -10</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">乘法 - 相乘操作符两侧的值</td>
<td align="center">A * B等于200</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">除法 - 左操作数除以右操作数</td>
<td align="center">保留整数部分</td>
</tr>
<tr>
<td align="center">％</td>
<td align="center">取余 - 左操作数除以右操作数的余数</td>
<td align="center">B%A等于0</td>
</tr>
<tr>
<td align="center">++</td>
<td align="center">自增: 操作数的值增加1</td>
<td align="center">B++ 或 ++B 等于 21（区别详见下文）</td>
</tr>
<tr>
<td align="center">–</td>
<td align="center">自减: 操作数的值减少1</td>
<td align="center">B– 或 –B 等于 19（区别详见下文）</td>
</tr>
</tbody></table>
<p>自增和自减前后缀区别：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x = ++i;<span class="comment">//先+1再用</span></span><br><span class="line"><span class="keyword">int</span> y = i++;<span class="comment">//先用再加1</span></span><br><span class="line"><span class="comment">//x=y=1,i=2</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/5.png" alt>)<img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/6.png" alt></p>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">==</td>
<td align="center">检查如果两个操作数的值是否相等，如果相等则条件为真。</td>
<td align="center">（A == B）为假。</td>
</tr>
<tr>
<td align="center">!=</td>
<td align="center">检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td>
<td align="center">(A != B) 为真。</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td>
<td align="center">（A&gt; B）为假。</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td>
<td align="center">（A &lt;B）为真。</td>
</tr>
<tr>
<td align="center">&gt;=</td>
<td align="center">检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td>
<td align="center">（A&gt; = B）为假。</td>
</tr>
<tr>
<td align="center">&lt;=</td>
<td align="center">检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td>
<td align="center">（A &lt;= B）为真。</td>
</tr>
</tbody></table>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">描述</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">＆</td>
<td align="center">如果相对应位都是1，则结果为1，否则为0</td>
<td align="center">（A＆B），得到12，即0000 1100</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">如果相对应位都是 0，则结果为 0，否则为 1</td>
<td align="center">（A | B）得到61，即 0011 1101</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">如果相对应位值相同，则结果为0，否则为1</td>
<td align="center">（A ^ B）得到49，即 0011 0001</td>
</tr>
<tr>
<td align="center">〜</td>
<td align="center">按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td>
<td align="center">（〜A）得到-61，即1100 0011</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td align="center">按位左移运算符。左操作数按位左移右操作数指定的位数。</td>
<td align="center">A &lt;&lt; 2得到240，即 1111 0000</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center">按位右移运算符。左操作数按位右移右操作数指定的位数。</td>
<td align="center">A &gt;&gt; 2得到15即 1111</td>
</tr>
<tr>
<td align="center">&gt;&gt;&gt;</td>
<td align="center">按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td>
<td align="center">A&gt;&gt;&gt;2得到15即0000 1111</td>
</tr>
</tbody></table>
<p>&gt;&gt; &amp;&amp; &gt;&gt;&gt;的区别</p>
<p><img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/7.png" alt>)<img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/8.png" alt></p>
<p>前者高位补的是原来的值（即符号位）——算术右移（汇编中的概念）</p>
<p>后者补0——逻辑右移（汇编中的概念）</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">描述</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;&amp;</td>
<td align="center">称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td>
<td align="center">（A &amp;&amp; B）为假。</td>
</tr>
<tr>
<td align="center">| |</td>
<td align="center">称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td>
<td align="center">（A | | B）为真。</td>
</tr>
<tr>
<td align="center">！</td>
<td align="center">称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td>
<td align="center">！（A &amp;&amp; B）为真。</td>
</tr>
</tbody></table>
<p>和C++，C一样也是短路计算，比如求a&amp;&amp;b，a，b均是表达式，当a的值为0，b的值就不会去计算。</p>
<p><img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/9.png" alt></p>
<p>输出a=0</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">描述</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">=</td>
<td align="center">简单的赋值运算符，将右操作数的值赋给左侧操作数</td>
<td align="center">C = A + B将把A + B得到的值赋给C</td>
</tr>
<tr>
<td align="center">+ =</td>
<td align="center">加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td>
<td align="center">C + = A等价于C = C + A</td>
</tr>
<tr>
<td align="center">- =</td>
<td align="center">减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td>
<td align="center">C - = A等价于C = C - A</td>
</tr>
<tr>
<td align="center">* =</td>
<td align="center">乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td>
<td align="center">C * = A等价于C = C * A</td>
</tr>
<tr>
<td align="center">/ =</td>
<td align="center">除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td>
<td align="center">C / = A，C 与 A 同类型时等价于 C = C / A</td>
</tr>
<tr>
<td align="center">（％）=</td>
<td align="center">取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td>
<td align="center">C％= A等价于C = C％A</td>
</tr>
<tr>
<td align="center">&lt;&lt; =</td>
<td align="center">左移位赋值运算符</td>
<td align="center">C &lt;&lt; = 2等价于C = C &lt;&lt; 2</td>
</tr>
<tr>
<td align="center">&gt;&gt; =</td>
<td align="center">右移位赋值运算符</td>
<td align="center">C &gt;&gt; = 2等价于C = C &gt;&gt; 2</td>
</tr>
<tr>
<td align="center">＆=</td>
<td align="center">按位与赋值运算符</td>
<td align="center">C＆= 2等价于C = C＆2</td>
</tr>
<tr>
<td align="center">^ =</td>
<td align="center">按位异或赋值操作符</td>
<td align="center">C ^ = 2等价于C = C ^ 2</td>
</tr>
<tr>
<td align="center">| =</td>
<td align="center">按位或赋值操作符</td>
<td align="center">C | = 2等价于C = C | 2</td>
</tr>
</tbody></table>
<p>和C，C++一样</p>
<h3 id="条件运算符（-）"><a href="#条件运算符（-）" class="headerlink" title="条件运算符（?:）"></a>条件运算符（?:）</h3><p>条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">variable x &#x3D; (expression) ? value if true : value if false</span><br></pre></td></tr></table></figure>

<p>C++中也有这种写法</p>
<h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">( Object reference variable ) instanceof  (class&#x2F;interface type)</span><br></pre></td></tr></table></figure>

<p>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。</p>
<p>下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String name &#x3D; &quot;James&quot;;</span><br><span class="line">boolean result &#x3D; name instanceof String; &#x2F;&#x2F; 由于 name 是 String 类型，所以返回真</span><br></pre></td></tr></table></figure>

<p>如果被比较的对象兼容于右侧类型,该运算符仍然返回true。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> &#123;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="title">extends</span> <span class="title">Vehicle</span> &#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Vehicle a = <span class="keyword">new</span> Car();</span><br><span class="line">      boolean result =  a instanceof Car;</span><br><span class="line">      System.out.println( result);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java运算符优先级"><a href="#Java运算符优先级" class="headerlink" title="Java运算符优先级"></a>Java运算符优先级</h3><table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">操作符</th>
<th align="center">关联性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">后缀</td>
<td align="center">() [] . (点操作符)</td>
<td align="center">左到右</td>
</tr>
<tr>
<td align="center">一元</td>
<td align="center">expr++ expr–</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">一元</td>
<td align="center">++expr –expr + - ～ ！</td>
<td align="center">从右到左</td>
</tr>
<tr>
<td align="center">乘性</td>
<td align="center">* /％</td>
<td align="center">左到右</td>
</tr>
<tr>
<td align="center">加性</td>
<td align="center">+ -</td>
<td align="center">左到右</td>
</tr>
<tr>
<td align="center">移位</td>
<td align="center">&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td>
<td align="center">左到右</td>
</tr>
<tr>
<td align="center">关系</td>
<td align="center">&gt; &gt;= &lt; &lt;=</td>
<td align="center">左到右</td>
</tr>
<tr>
<td align="center">相等</td>
<td align="center">== !=</td>
<td align="center">左到右</td>
</tr>
<tr>
<td align="center">按位与</td>
<td align="center">＆</td>
<td align="center">左到右</td>
</tr>
<tr>
<td align="center">按位异或</td>
<td align="center">^</td>
<td align="center">左到右</td>
</tr>
<tr>
<td align="center">按位或</td>
<td align="center">|</td>
<td align="center">左到右</td>
</tr>
<tr>
<td align="center">逻辑与</td>
<td align="center">&amp;&amp;</td>
<td align="center">左到右</td>
</tr>
<tr>
<td align="center">逻辑或</td>
<td align="center">| |</td>
<td align="center">左到右</td>
</tr>
<tr>
<td align="center">条件</td>
<td align="center">？：</td>
<td align="center">从右到左</td>
</tr>
<tr>
<td align="center">赋值</td>
<td align="center">= + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | =</td>
<td align="center">从右到左</td>
</tr>
<tr>
<td align="center">逗号</td>
<td align="center">，</td>
<td align="center">左到右</td>
</tr>
</tbody></table>
<p>关联性也就是C++中所谓的结合性</p>
<h2 id="Java-循环结构-for-while-及-do…while"><a href="#Java-循环结构-for-while-及-do…while" class="headerlink" title="Java 循环结构 - for, while 及 do…while"></a>Java 循环结构 - for, while 及 do…while</h2><p>这块和C++几乎一样</p>
<h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>( 布尔表达式 ) &#123;  <span class="comment">//循环内容 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="do…while-循环（至少执行一次循环）"><a href="#do…while-循环（至少执行一次循环）" class="headerlink" title="do…while 循环（至少执行一次循环）"></a>do…while 循环（至少执行一次循环）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="comment">//代码语句</span></span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式);</span><br></pre></td></tr></table></figure>

<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化; 布尔表达式; 更新) &#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-增强-for-循环（C-11也新增）"><a href="#Java-增强-for-循环（C-11也新增）" class="headerlink" title="Java 增强 for 循环（C++11也新增）"></a>Java 增强 for 循环（C++11也新增）</h3><p>C++中叫基于范围的循环，python中就是这种循环</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(声明语句 : 表达式)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//代码句子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>声明语句：</strong>声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</p>
<p><strong>表达式：</strong>表达式是要访问的数组名，或者是返回值为数组的方法。</p>
<p><img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/10.png" alt>)<img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/11.png" alt></p>
<h3 id="break-关键字"><a href="#break-关键字" class="headerlink" title="break 关键字"></a>break 关键字</h3><p>break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。</p>
<p>break 跳出最里层的循环，并且继续执行该循环下面的语句。</p>
<h3 id="continue-关键字"><a href="#continue-关键字" class="headerlink" title="continue 关键字"></a>continue 关键字</h3><p>continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。</p>
<p>在 for 循环中，continue 语句使程序立即跳转到更新语句。</p>
<p>在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。</p>
<h2 id="Java-条件语句-if…else"><a href="#Java-条件语句-if…else" class="headerlink" title="Java 条件语句 - if…else"></a>Java 条件语句 - if…else</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//如果布尔表达式为true将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="if…else语句"><a href="#if…else语句" class="headerlink" title="if…else语句"></a>if…else语句</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">   <span class="comment">//如果布尔表达式的值为true</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">//如果布尔表达式的值为false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可嵌套，和C++一模一样</p>
<h2 id="Java-switch-case-语句"><a href="#Java-switch-case-语句" class="headerlink" title="Java switch case 语句"></a>Java switch case 语句</h2><p>switch case 语句语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="comment">//你可以有任意数量的case语句</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">//可选</span></span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-Number-amp-Math-类"><a href="#Java-Number-amp-Math-类" class="headerlink" title="Java Number &amp; Math 类"></a>Java Number &amp; Math 类</h2><p>一般地，当需要使用数字的时候，我们通常使用内置数据类型，如：<strong>byte、int、long、double</strong> 等。</p>
<p>然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，Java 语言为每一个内置数据类型提供了对应的包装类。</p>
<p>所有的包装类<strong>（Integer、Long、Byte、Double、Float、Short）</strong>都是抽象类 Number 的子类。</p>
<table>
<thead>
<tr>
<th align="center">包装类</th>
<th align="center">基本数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Boolean</td>
<td align="center">boolean</td>
</tr>
<tr>
<td align="center">Byte</td>
<td align="center">byte</td>
</tr>
<tr>
<td align="center">Short</td>
<td align="center">short</td>
</tr>
<tr>
<td align="center">Integer</td>
<td align="center">int</td>
</tr>
<tr>
<td align="center">Long</td>
<td align="center">long</td>
</tr>
<tr>
<td align="center">Character</td>
<td align="center">char</td>
</tr>
<tr>
<td align="center">Float</td>
<td align="center">float</td>
</tr>
<tr>
<td align="center">Double</td>
<td align="center">double</td>
</tr>
</tbody></table>
<p><img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12.png" alt></p>
<p>这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Integer x = <span class="number">5</span>;</span><br><span class="line">      x =  x + <span class="number">10</span>;</span><br><span class="line">      System.out.println(x); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 x 被赋为整型值时，由于x是一个对象，所以编译器要对x进行装箱。然后，为了使x能进行加运算，所以要对x进行拆箱。</p>
<h2 id="Java-Math-类"><a href="#Java-Math-类" class="headerlink" title="Java Math 类"></a>Java Math 类</h2><p>Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。</p>
<p>Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String []args)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"90 度的正弦值："</span> + Math.<span class="built_in">sin</span>(Math.PI/<span class="number">2</span>));  </span><br><span class="line">        System.out.println(<span class="string">"0度的余弦值："</span> + Math.<span class="built_in">cos</span>(<span class="number">0</span>));  </span><br><span class="line">        System.out.println(<span class="string">"60度的正切值："</span> + Math.<span class="built_in">tan</span>(Math.PI/<span class="number">3</span>));  </span><br><span class="line">        System.out.println(<span class="string">"1的反正切值： "</span> + Math.<span class="built_in">atan</span>(<span class="number">1</span>));  </span><br><span class="line">        System.out.println(<span class="string">"π/2的角度值："</span> + Math.toDegrees(Math.PI/<span class="number">2</span>));  </span><br><span class="line">        System.out.println(Math.PI);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Number-amp-Math-类方法"><a href="#Number-amp-Math-类方法" class="headerlink" title="Number &amp; Math 类方法"></a>Number &amp; Math 类方法</h2><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法与描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/java/number-xxxvalue.html" target="_blank" rel="noopener">xxxValue()</a> 将 Number 对象转换为xxx数据类型的值并返回。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/java/number-compareto.html" target="_blank" rel="noopener">compareTo()</a> 将number对象与参数比较。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/java/number-equals.html" target="_blank" rel="noopener">equals()</a> 判断number对象是否与参数相等。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/java/number-valueof.html" target="_blank" rel="noopener">valueOf()</a> 返回一个 Number 对象指定的内置数据类型</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/java/number-tostring.html" target="_blank" rel="noopener">toString()</a> 以字符串形式返回值。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://www.runoob.com/java/number-parseInt.html" target="_blank" rel="noopener">parseInt()</a> 将字符串解析为int类型。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/java/number-abs.html" target="_blank" rel="noopener">abs()</a> 返回参数的绝对值。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/java/number-ceil.html" target="_blank" rel="noopener">ceil()</a> 返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/java/number-floor.html" target="_blank" rel="noopener">floor()</a> 返回小于等于（&lt;=）给定参数的最大整数 。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/java/number-rint.html" target="_blank" rel="noopener">rint()</a> 返回与参数最接近的整数。返回类型为double。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="https://www.runoob.com/java/number-round.html" target="_blank" rel="noopener">round()</a> 它表示<strong>四舍五入</strong>，算法为 <strong>Math.floor(x+0.5)</strong>，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="https://www.runoob.com/java/number-min.html" target="_blank" rel="noopener">min()</a> 返回两个参数中的最小值。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a href="https://www.runoob.com/java/number-max.html" target="_blank" rel="noopener">max()</a> 返回两个参数中的最大值。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a href="https://www.runoob.com/java/number-exp.html" target="_blank" rel="noopener">exp()</a> 返回自然数底数e的参数次方。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a href="https://www.runoob.com/java/number-log.html" target="_blank" rel="noopener">log()</a> 返回参数的自然数底数的对数值。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a href="https://www.runoob.com/java/number-pow.html" target="_blank" rel="noopener">pow()</a> 返回第一个参数的第二个参数次方。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a href="https://www.runoob.com/java/number-sqrt.html" target="_blank" rel="noopener">sqrt()</a> 求参数的算术平方根。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a href="https://www.runoob.com/java/number-sin.html" target="_blank" rel="noopener">sin()</a> 求指定double类型参数的正弦值。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a href="https://www.runoob.com/java/number-cos.html" target="_blank" rel="noopener">cos()</a> 求指定double类型参数的余弦值。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><a href="https://www.runoob.com/java/number-tan.html" target="_blank" rel="noopener">tan()</a> 求指定double类型参数的正切值。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><a href="https://www.runoob.com/java/number-asin.html" target="_blank" rel="noopener">asin()</a> 求指定double类型参数的反正弦值。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><a href="https://www.runoob.com/java/number-acos.html" target="_blank" rel="noopener">acos()</a> 求指定double类型参数的反余弦值。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left"><a href="https://www.runoob.com/java/number-atan.html" target="_blank" rel="noopener">atan()</a> 求指定double类型参数的反正切值。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left"><a href="https://www.runoob.com/java/number-atan2.html" target="_blank" rel="noopener">atan2()</a> 将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left"><a href="https://www.runoob.com/java/number-todegrees.html" target="_blank" rel="noopener">toDegrees()</a> 将参数转化为角度。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left"><a href="https://www.runoob.com/java/number-toradians.html" target="_blank" rel="noopener">toRadians()</a> 将角度转换为弧度。</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left"><a href="https://www.runoob.com/java/number-random.html" target="_blank" rel="noopener">random()</a> 返回一个随机数。</td>
</tr>
</tbody></table>
<h2 id="Java-Character-类"><a href="#Java-Character-类" class="headerlink" title="Java Character 类"></a>Java Character 类</h2><p>Character 类用于对单个字符进行操作。</p>
<p>Character 类在对象中包装一个基本类型 <strong>char</strong> 的值</p>
<h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><table>
<thead>
<tr>
<th align="center">转义序列</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\t</td>
<td align="center">在文中该处插入一个tab键</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">在文中该处插入一个后退键</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="center">在文中该处换行</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="center">在文中该处插入回车</td>
</tr>
<tr>
<td align="center">\f</td>
<td align="center">在文中该处插入换页符</td>
</tr>
<tr>
<td align="center">&#39;</td>
<td align="center">在文中该处插入单引号</td>
</tr>
<tr>
<td align="center">&quot;</td>
<td align="center">在文中该处插入双引号</td>
</tr>
<tr>
<td align="center">\</td>
<td align="center">在文中该处插入反斜杠</td>
</tr>
</tbody></table>
<h3 id="Character-方法"><a href="#Character-方法" class="headerlink" title="Character 方法"></a>Character 方法</h3><p>C++中是cctype头文件中的方法。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法与描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">isLetter() 是否是一个字母</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">isDigit()是否是一个数字字符</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">isWhitespace()是否是一个空白字符</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">isUpperCase() 是否是大写字母</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">isLowerCase()是否是小写字母</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">toUpperCase() 指定字母的大写形式</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">toLowerCase() 指定字母的小写形式</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">toString返回字符的字符串形式，字符串的长度仅为1</td>
</tr>
</tbody></table>
<h2 id="Java-String-类"><a href="#Java-String-类" class="headerlink" title="Java String 类"></a>Java String 类</h2><p>字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。</p>
<h3 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h3><p>String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"Runoob"</span>;              <span class="comment">// String 直接创建</span></span><br><span class="line">String s2 = <span class="string">"Runoob"</span>;              <span class="comment">// String 直接创建</span></span><br><span class="line">String s3 = s1;                    <span class="comment">// 相同引用</span></span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">"Runoob"</span>);   <span class="comment">// String 对象创建</span></span><br><span class="line">String s5 = <span class="keyword">new</span> String(<span class="string">"Runoob"</span>);   <span class="comment">// String 对象创建</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/13.png" alt></p>
<h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><p>String 类的一个访问器方法是 length() 方法，它返回字符串对象包含的字符数。</p>
<p>！！！没有size方法，C++STL中有size和length</p>
<h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>String 类提供了连接两个字符串的方法：</p>
<ul>
<li><p>返回 string2 连接 string1 的新字符串。也可以对字符串常量使用 concat() 方法，如：</p>
</li>
<li><p>更常用的是使用’+’操作符来连接字符串</p>
</li>
</ul>
<p><img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/14.png" alt>)<img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/15.png" alt></p>
<h3 id="创建格式化字符串"><a href="#创建格式化字符串" class="headerlink" title="创建格式化字符串"></a>创建格式化字符串</h3><p>我们知道输出格式化数字可以使用 printf() 和 format() 方法。</p>
<p>String 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。</p>
<p>String 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。</p>
<h3 id="String-方法"><a href="#String-方法" class="headerlink" title="String 方法"></a>String 方法</h3><p>参看 <a href="https://www.runoob.com/manual/jdk1.6/java/lang/String.html" target="_blank" rel="noopener">Java String API</a> 文档:</p>
<h2 id="Java-StringBuffer-和-StringBuilder-类"><a href="#Java-StringBuffer-和-StringBuilder-类" class="headerlink" title="Java StringBuffer 和 StringBuilder 类"></a>Java StringBuffer 和 StringBuilder 类</h2><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p>
<p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>
<p><img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/16.png" alt></p>
<p>在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。</p>
<p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p>
<p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。</p>
<p><img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/17.png" alt></p>
<p>然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>
<h3 id="StringBuffer-方法"><a href="#StringBuffer-方法" class="headerlink" title="StringBuffer 方法"></a>StringBuffer 方法</h3><table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">int capacity() 返回当前容量。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">char charAt(int index) 返回此序列中指定索引处的 <code>char</code> 值。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">void ensureCapacity(int minimumCapacity) 确保容量至少等于指定的最小值。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 <code>dst</code>。</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">int indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">int indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">int lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">int lastIndexOf(String str, int fromIndex) 返回 String 对象中子字符串最后出现的位置。</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">int length()  返回长度（字符数）。</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">void setCharAt(int index, char ch) 将给定索引处的字符设置为 <code>ch</code>。</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">void setLength(int newLength) 设置字符序列的长度。</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">CharSequence subSequence(int start, int end) 返回一个新的字符序列，该字符序列是此序列的子序列。</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">String substring(int start) 返回一个新的 <code>String</code>，它包含此字符序列当前所包含的字符子序列。</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">String substring(int start, int end) 返回一个新的 <code>String</code>，它包含此序列当前所包含的字符子序列。</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">String toString() 返回此序列中数据的字符串表示形式。</td>
</tr>
</tbody></table>
<h2 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h2><h3 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dataType[] arrayRefVar;   <span class="comment">// 首选的方法</span></span><br><span class="line"> </span><br><span class="line">或</span><br><span class="line"> </span><br><span class="line">dataType arrayRefVar[];  <span class="comment">// 效果相同，但不是首选方法 </span></span><br><span class="line"><span class="comment">//dataType arrayRefVar[] 风格是来自 C/C++ 语言 ，在Java中采用是为了让 C/C++ 程序员能够快速理解java语言。</span></span><br></pre></td></tr></table></figure>

<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>Java语言使用new操作符来创建数组，语法如下：</p>
<p><code>arrayRefVar = new dataType[arraySize];</code></p>
<p>上面的语法语句做了两件事：</p>
<ul>
<li>一、使用 dataType[arraySize] 创建了一个数组。</li>
<li>二、把新创建的数组的引用赋值给变量 arrayRefVar。</li>
</ul>
<p>可以理解成返回的是指针，C/C++中就有这种概念。</p>
<h3 id="数组作为函数的参数"><a href="#数组作为函数的参数" class="headerlink" title="数组作为函数的参数"></a>数组作为函数的参数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; i++) &#123;</span><br><span class="line">    System.out.print(<span class="built_in">array</span>[i] + <span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组作为函数的返回值"><a href="#数组作为函数的返回值" class="headerlink" title="数组作为函数的返回值"></a>数组作为函数的返回值</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] reverse(<span class="keyword">int</span>[] <span class="built_in">list</span>) &#123;</span><br><span class="line">  <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">list</span>.length];</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = result.length - <span class="number">1</span>; i &lt; <span class="built_in">list</span>.length; i++, j--) &#123;</span><br><span class="line">    result[j] = <span class="built_in">list</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际本质是在堆盛情内存空间之后，返回的是引用，也就是数组在堆内存中的位置。</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组，例如：</p>
<p><code>String str[][] = new String[3][4];</code></p>
<h3 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h3><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>
<p>具有以下功能：</p>
<ul>
<li>给数组赋值：通过 fill 方法。</li>
<li>对数组排序：通过 sort 方法,按升序。</li>
<li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li>
<li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="left">方法和说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><strong>public static int binarySearch(Object[] a, Object key)</strong> 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(<em>插入点</em>) - 1)。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><strong>public static boolean equals(long[] a, long[] a2)</strong> 如果两个指定的 long 型数组彼此<em>相等</em>，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><strong>public static void fill(int[] a, int val)</strong> 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><strong>public static void sort(Object[] a)</strong> 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
</tbody></table>
<h2 id="Java-日期时间"><a href="#Java-日期时间" class="headerlink" title="Java 日期时间"></a>Java 日期时间</h2><p>java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。</p>
<p>第一个构造函数使用当前日期和时间来初始化对象。</p>
<p>第一个构造函数使用当前日期和时间来初始化对象。<code>Date( )</code></p>
<p>第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。<code>Date(long millisec)</code></p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>boolean after(Date date)</strong> 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>boolean before(Date date)</strong> 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>Object clone( )</strong> 返回此对象的副本。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>int compareTo(Date date)</strong> 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>int compareTo(Object obj)</strong> 若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>boolean equals(Object date)</strong> 当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>long getTime( )</strong> 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>int hashCode( )</strong>  返回此对象的哈希码值。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>void setTime(long time)</strong>   用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>String toString( )</strong> 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。</td>
</tr>
</tbody></table>
<h3 id="获取当前日期时间"><a href="#获取当前日期时间" class="headerlink" title="获取当前日期时间"></a>获取当前日期时间</h3><p><img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/18.png" alt>)<img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/19.png" alt></p>
<h3 id="日期比较"><a href="#日期比较" class="headerlink" title="日期比较"></a>日期比较</h3><p>Java使用以下三种方法来比较两个日期：</p>
<ul>
<li>使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。</li>
<li>使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。</li>
<li>使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。</li>
</ul>
<h3 id="使用-SimpleDateFormat-格式化日期"><a href="#使用-SimpleDateFormat-格式化日期" class="headerlink" title="使用 SimpleDateFormat 格式化日期"></a>使用 SimpleDateFormat 格式化日期</h3><p>SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如：</p>
<p><code>SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;);</code></p>
<p>这一行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。</p>
<p><strong>注意</strong>:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。</p>
<p><img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/20.png" alt>)<img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/21.png" alt></p>
<h3 id="解析字符串为时间"><a href="#解析字符串为时间" class="headerlink" title="解析字符串为时间"></a>解析字符串为时间</h3><p>SimpleDateFormat 类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat 对象的格式化存储来解析字符串。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">      SimpleDateFormat ft = <span class="keyword">new</span> SimpleDateFormat (<span class="string">"yyyy-MM-dd"</span>); </span><br><span class="line"> </span><br><span class="line">      String input = args.length == <span class="number">0</span> ? <span class="string">"1818-11-11"</span> : args[<span class="number">0</span>]; </span><br><span class="line"> </span><br><span class="line">      System.out.print(input + <span class="string">" Parses as "</span>); </span><br><span class="line"> </span><br><span class="line">      Date t; </span><br><span class="line"> </span><br><span class="line">      <span class="keyword">try</span> &#123; </span><br><span class="line">          t = ft.parse(input); </span><br><span class="line">          System.out.println(t); </span><br><span class="line">      &#125; <span class="keyword">catch</span> (ParseException e) &#123; </span><br><span class="line">          System.out.println(<span class="string">"Unparseable using "</span> + ft); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-休眠-sleep"><a href="#Java-休眠-sleep" class="headerlink" title="Java 休眠(sleep)"></a>Java 休眠(sleep)</h3><p>sleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。</p>
<p>你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。</p>
<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用Calendar 类。</p>
<p>Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。</p>
<p>Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。</p>
<h3 id="GregorianCalendar类"><a href="#GregorianCalendar类" class="headerlink" title="GregorianCalendar类"></a>GregorianCalendar类</h3><p>Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。</p>
<p>Calendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。</p>
<h2 id="Java-正则表达式"><a href="#Java-正则表达式" class="headerlink" title="Java 正则表达式"></a>Java 正则表达式</h2><p>ava 正则表达式和 Perl 的是最为相似的。</p>
<p>java.util.regex 包主要包括以下三个类：</p>
<ul>
<li><p>Pattern 类：</p>
<p>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p>
</li>
<li><p>Matcher 类：</p>
<p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p>
</li>
<li><p>PatternSyntaxException：</p>
<p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p>
</li>
</ul>
<h2 id="Java-方法"><a href="#Java-方法" class="headerlink" title="Java 方法"></a>Java 方法</h2><h3 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">    ...</span><br><span class="line">    方法体</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修饰符：</strong>修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li>
<li><strong>返回值类型 ：</strong>方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字<strong>void</strong>。</li>
<li><strong>方法名：</strong>是方法的实际名称。方法名和参数表共同构成方法签名。</li>
<li><strong>参数类型：</strong>参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li>
<li><strong>方法体：</strong>方法体包含具体的语句，定义该方法的功能。</li>
</ul>
<h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。</p>
<p>Java编译器根据方法签名判断哪个方法应该被调用。</p>
<p>方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。</p>
<p>重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。</p>
<p>不管你是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，默认构造方法的访问修改符和类的访问修改符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。</p>
<p>一旦你定义了自己的构造方法，默认构造方法就会失效。</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。</p>
<p>方法的可变参数的声明如下所示：</p>
<p><code>typeName... parameterName</code></p>
<p>在方法声明中，在指定参数类型后加一个省略号(…) 。</p>
<p>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize() 方法"></a>finalize() 方法</h3><p>Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。</p>
<p>例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。</p>
<p>在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。</p>
<p>finalize() 一般格式是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 在这里终结代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。</p>
<p>当然，Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法。</p>
<h2 id="Java-流-Stream-、文件-File-和IO"><a href="#Java-流-Stream-、文件-File-和IO" class="headerlink" title="Java 流(Stream)、文件(File)和IO"></a>Java 流(Stream)、文件(File)和IO</h2><h3 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h3><p>Java 的控制台输入由 System.in 完成。</p>
<p>为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。</p>
<p>下面是创建 BufferedReader 的基本语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> </span><br><span class="line">                      InputStreamReader(System.in));</span><br></pre></td></tr></table></figure>

<p>BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。</p>
<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。</p>
<p>下图是一个描述输入流和输出流的类层次图。</p>
<p><img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/22.png" alt></p>
<h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><p>该流用于从文件读取数据，它的对象可以用关键字 new 来创建。</p>
<p>有多种构造方法可用来创建对象。</p>
<p>可以使用字符串类型的文件名来创建一个输入流对象来读取文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InputStream f &#x3D; new FileInputStream(&quot;C:&#x2F;java&#x2F;hello&quot;);</span><br></pre></td></tr></table></figure>

<p>也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File f &#x3D; new File(&quot;C:&#x2F;java&#x2F;hello&quot;); InputStream out &#x3D; new FileInputStream(f);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="left"><strong>方法及描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public void close() throws IOException{}</strong> 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>protected void finalize()throws IOException {}</strong> 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public int read(int r)throws IOException{}</strong> 这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public int read(byte[] r) throws IOException{}</strong> 这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>public int available() throws IOException{}</strong> 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。</td>
</tr>
</tbody></table>
<h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><p>该类用来创建一个文件并向文件中写数据。</p>
<p>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。</p>
<p>有两个构造方法可以用来创建 FileOutputStream 对象。</p>
<p>使用字符串类型的文件名来创建一个输出流对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OutputStream f &#x3D; new FileOutputStream(&quot;C:&#x2F;java&#x2F;hello&quot;)</span><br></pre></td></tr></table></figure>

<p>也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File f &#x3D; new File(&quot;C:&#x2F;java&#x2F;hello&quot;); OutputStream f &#x3D; new FileOutputStream(f);</span><br></pre></td></tr></table></figure>

<h3 id="Java中的目录"><a href="#Java中的目录" class="headerlink" title="Java中的目录"></a>Java中的目录</h3><h4 id="创建目录："><a href="#创建目录：" class="headerlink" title="创建目录："></a>创建目录：</h4><p>File类中有两个方法可以用来创建文件夹：</p>
<ul>
<li><strong>mkdir( )</strong>方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。</li>
<li><strong>mkdirs()</strong>方法创建一个文件夹和它的所有父文件夹。</li>
</ul>
<h3 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h3><p>一个目录其实就是一个 File 对象，它包含其他文件和文件夹。</p>
<p>如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。</p>
<p>可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。</p>
<p>删除文件可以使用 <strong>java.io.File.delete()</strong> 方法。</p>
<h3 id="删除目录或文件"><a href="#删除目录或文件" class="headerlink" title="删除目录或文件"></a>删除目录或文件</h3><p>需要注意的是当删除某一目录时，必须保证该目录下没有其他文件才能正确删除，否则将删除失败。</p>
<h2 id="Java-Scanner-类"><a href="#Java-Scanner-类" class="headerlink" title="Java Scanner 类"></a>Java Scanner 类</h2><p>java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。</p>
<p>下面是创建 Scanner 对象的基本语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Scanner s &#x3D; new Scanner(System.in);</span><br></pre></td></tr></table></figure>

<p>通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据：</p>
<h4 id="next-与-nextLine-区别"><a href="#next-与-nextLine-区别" class="headerlink" title="next() 与 nextLine() 区别"></a>next() 与 nextLine() 区别</h4><p>next():</p>
<ul>
<li>1、一定要读取到有效字符后才可以结束输入。</li>
<li>2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。</li>
<li>3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li>
<li>next() 不能得到带有空格的字符串。</li>
</ul>
<p>nextLine()：</p>
<ul>
<li>1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</li>
<li>2、可以获得空白。</li>
</ul>
<h2 id="Java-异常处理"><a href="#Java-异常处理" class="headerlink" title="Java 异常处理"></a>Java 异常处理</h2><p>异常发生的原因有很多，通常包含以下几大类：</p>
<ul>
<li>用户输入了非法数据。</li>
<li>要打开的文件不存在。</li>
<li>网络通信时连接中断，或者JVM内存溢出。</li>
</ul>
<p>这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。-</p>
<p>要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：</p>
<ul>
<li><strong>检查性异常：</strong>最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>
<li><strong>运行时异常：</strong> 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>
<li><strong>错误：</strong> 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li>
</ul>
<h3 id="Exception-类的层次"><a href="#Exception-类的层次" class="headerlink" title="Exception 类的层次"></a>Exception 类的层次</h3><p>所有的异常类是从 java.lang.Exception 类继承的子类。</p>
<p>Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。</p>
<p>Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。</p>
<p>Error 用来指示运行时环境发生的错误。</p>
<p>例如，JVM 内存溢出。一般地，程序不会从错误中恢复。</p>
<p>异常类有两个主要的子类：IOException 类和 RuntimeException 类。</p>
<p><img src="/2020/12/26/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/23.jpg" alt></p>
<h3 id="Java-内置异常类"><a href="#Java-内置异常类" class="headerlink" title="Java 内置异常类"></a>Java 内置异常类</h3><p>Java 语言定义了一些异常类在 java.lang 标准包中。</p>
<p>标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。</p>
<p>Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常。</p>
<h3 id="异常方法"><a href="#异常方法" class="headerlink" title="异常方法"></a>异常方法</h3><p>下面的列表是 Throwable 类的主要方法:</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="left"><strong>方法及说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public String getMessage()</strong> 返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>public Throwable getCause()</strong> 返回一个Throwable 对象代表异常原因。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public String toString()</strong> 使用getMessage()的结果返回类的串级名字。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public void printStackTrace()</strong> 打印toString()结果和栈层次到System.err，即错误输出流。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>public StackTraceElement [] getStackTrace()</strong> 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>public Throwable fillInStackTrace()</strong> 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。</td>
</tr>
</tbody></table>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。</p>
<p>try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">   &#x2F;&#x2F; 程序代码</span><br><span class="line">&#125;catch(ExceptionName e1)</span><br><span class="line">&#123;</span><br><span class="line">   &#x2F;&#x2F;Catch 块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多重捕获块"><a href="#多重捕获块" class="headerlink" title="多重捕获块"></a>多重捕获块</h3><p>一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 异常的变量名<span class="number">3</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="throws-throw-关键字："><a href="#throws-throw-关键字：" class="headerlink" title="throws/throw 关键字："></a>throws/throw 关键字：</h3><p>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。</p>
<p>也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p>
<p>下面方法的声明抛出一个 RemoteException 异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// Method implementation</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的例子中声明有两个元素的一个数组，当代码试图访问数组的第三个元素的时候就会抛出一个异常。</p>
<h3 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h3><p>finally 关键字用来创建在 try 代码块后面执行的代码块。</p>
<p>无论是否发生异常，finally 代码块中的代码总会被执行。</p>
<p>在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。</p>
<p>finally 代码块出现在 catch 代码块最后，语法如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>catch 不能独立于 try 存在。</li>
<li>在 try/catch 后面添加 finally 块并非强制性要求的。</li>
<li>try 代码后不能既没 catch 块也没 finally 块。</li>
<li>try, catch, finally 块之间不能添加任何代码。</li>
</ul>
<h3 id="声明自定义异常"><a href="#声明自定义异常" class="headerlink" title="声明自定义异常"></a>声明自定义异常</h3><p>在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。</p>
<ul>
<li>所有异常都必须是 Throwable 的子类。</li>
<li>如果希望写一个检查性异常类，则需要继承 Exception 类。</li>
<li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</li>
</ul>
<h3 id="通用异常"><a href="#通用异常" class="headerlink" title="通用异常"></a>通用异常</h3><p>在Java中定义了两种类型的异常和错误。</p>
<ul>
<li><strong>JVM(Java**</strong>虚拟机<strong>**)</strong> <strong>异常：</strong>由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。</li>
<li><strong>程序级异常：</strong>由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。</li>
</ul>
]]></content>
      <categories>
        <category>JAVA学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
