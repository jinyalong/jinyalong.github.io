<!DOCTYPE html><html lang="zh-Hans"><head>
	
	
	
<link rel="stylesheet" href="/css/allinone.min.css">


	

	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">

	<title>JUC并发编程 | CodeFriday</title>

	<meta name="HandheldFriendly" content="True">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
	<meta name="generator" content="hexo">
	<meta name="author" content="codefriday">
	<meta name="description" content="">

	
	<meta name="keywords" content="">
	

	
	<link rel="shortcut icon" href="https://codefriday.oss-cn-beijing.aliyuncs.com/author.jpg">
	<link rel="apple-touch-icon" href="https://codefriday.oss-cn-beijing.aliyuncs.com/author.jpg">
	

	
	<meta name="theme-color" content="#3c484e">
	<meta name="msapplication-TileColor" content="#3c484e">
	

	

	

	<meta property="og:site_name" content="CodeFriday">
	<meta property="og:type" content="article">
	<meta property="og:title" content="JUC并发编程 | CodeFriday">
	<meta property="og:description" content="">
	<meta property="og:url" content="http://yoursite.com/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

	
	<meta property="article:published_time" content="2021-01-31T11:01:00+08:00"> 
	<meta property="article:author" content="codefriday">
	<meta property="article:published_first" content="CodeFriday, /2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
	
<link rel="alternate" href="/atom.xml" title="CodeFriday" type="application/atom+xml">
</head>
<body class="post-template">
	<div class="site-wrapper">
		




<header class="site-header outer" style="z-index: 999">
    <div class="inner">
        
<nav class="site-nav"> 
    <div class="site-nav-left">
        <ul class="nav">
            <li>
                
                <a href="/" title="Home">HOME</a>
                
            </li>
            
            
            <li>
                <a href="/about" title="ABOUT">ABOUT</a>
            </li>
            
            <li>
                <a href="/archives" title="ARCHIVES">ARCHIVES</a>
            </li>
            
            
        </ul> 
    </div>
    
    <div class="search-button">
        <a href="#search" class="subscribe-button" style="margin: 0 10px;">Search ...</a>
    </div>
     
    <div class="site-nav-right">
        
        <a href="#search" class="subscribe-button" style="margin: 0 10px;">Search ...</a>
         
        
<div class="social-links">
    
    
    <a class="social-link" title="github" href="https://github.com/jinyalong" target="_blank" rel="noopener">
        <svg viewBox="0 0 1049 1024" xmlns="http://www.w3.org/2000/svg"><path d="M524.979332 0C234.676191 0 0 234.676191 0 524.979332c0 232.068678 150.366597 428.501342 358.967656 498.035028 26.075132 5.215026 35.636014-11.299224 35.636014-25.205961 0-12.168395-0.869171-53.888607-0.869171-97.347161-146.020741 31.290159-176.441729-62.580318-176.441729-62.580318-23.467619-60.841976-58.234462-76.487055-58.234463-76.487055-47.804409-32.15933 3.476684-32.15933 3.476685-32.15933 53.019436 3.476684 80.83291 53.888607 80.83291 53.888607 46.935238 79.963739 122.553122 57.365291 152.97411 43.458554 4.345855-33.897672 18.252593-57.365291 33.028501-70.402857-116.468925-12.168395-239.022047-57.365291-239.022047-259.012982 0-57.365291 20.860106-104.300529 53.888607-140.805715-5.215026-13.037566-23.467619-66.926173 5.215027-139.067372 0 0 44.327725-13.906737 144.282399 53.888607 41.720212-11.299224 86.917108-17.383422 131.244833-17.383422s89.524621 6.084198 131.244833 17.383422C756.178839 203.386032 800.506564 217.29277 800.506564 217.29277c28.682646 72.1412 10.430053 126.029806 5.215026 139.067372 33.897672 36.505185 53.888607 83.440424 53.888607 140.805715 0 201.64769-122.553122 245.975415-239.891218 259.012982 19.121764 16.514251 35.636014 47.804409 35.636015 97.347161 0 70.402857-0.869171 126.898978-0.869172 144.282399 0 13.906737 9.560882 30.420988 35.636015 25.205961 208.601059-69.533686 358.967656-265.96635 358.967655-498.035028C1049.958663 234.676191 814.413301 0 524.979332 0z"></path></svg>
    </a>
    
    
    <a class="social-link" title="facebook" href="https://blog.csdn.net/HNUCSEE" target="_blank" rel="noopener">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1049 1024"><path d="M1141.351404 39.055942l-28.91333 218.474629c-126.144728-19.927251-251.601043-38.376709-377.75495-27.674187-115.460564 9.802996-227.405635 32.180995-309.124802 122.987208-150.018878 166.696821-68.391499 396.461416 158.252293 437.463272 141.115408 25.52634 283.919721 11.785624 425.448176-8.123269-5.452228 112.440727-5.764308 95.303843-10.674985 205.229569-1.073924 24.057726 4.277337 14.612705-161.648461 31.914809-176.004159 9.004437-351.879815 11.189-520.550085-52.888447C156.545029 905.721534 30.675666 809.16019 5.176863 630.815428c-26.251468-183.595056 48.803865-331.796524 192.516883-446.128091C413.36883 13.098197 790.802521-47.271 1141.351404 39.055942z" fill="#ffffff"></path></svg>
    </a>
    
    
    
    
    
</div>
    </div>
</nav>
    </div>
</header>


<main id="site-main" class="site-main outer" role="main">
    <div class="inner">
        <header class="post-full-header">
            <section class="post-full-meta">
                <time class="post-full-meta-date" datetime="2021-01-31T03:58:54.000Z" itemprop="datePublished">
                    2021-01-31
                </time>
                
                <span class="date-divider">/</span>
                
                <a href="/categories/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/">第一阶段</a>&nbsp;&nbsp;
                
                
            </section>
            <h1 class="post-full-title">JUC并发编程</h1>
        </header>
        <article class="post-full no-image">
            
            <section class="post-full-content">
                <div id="lightgallery" class="markdown-body">
                    <h2 id="1、什么是JUC"><a href="#1、什么是JUC" class="headerlink" title="1、什么是JUC"></a>1、什么是JUC</h2><p>JUC是<code>java.util.concurrent</code>简称，主要包含以下几个包</p>
<ul>
<li><code>java.util.concurrent</code></li>
<li><code>java.util.concurrent.atomic</code></li>
<li><code>java.util.concurrent.locks</code></li>
</ul>
<h2 id="2、线程与进程"><a href="#2、线程与进程" class="headerlink" title="2、线程与进程"></a>2、线程与进程</h2><blockquote>
<p>线程的状态：</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State {</span><br><span class="line">        NEW,</span><br><span class="line">        RUNNABLE,</span><br><span class="line">        BLOCKED,</span><br><span class="line">        WAITING,</span><br><span class="line">        TIMED_WAITING,</span><br><span class="line">        TERMINATED;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>sleep和wait的区别</p>
</blockquote>
<p><strong>（1）来自不同的类</strong></p>
<p>wait =&gt; Object</p>
<p>sleep =&gt; Thread</p>
<p><strong>（2）关于锁的释放</strong></p>
<p>wait会释放锁，但sleep不会</p>
<h2 id="3、Lock锁"><a href="#3、Lock锁" class="headerlink" title="3、Lock锁"></a>3、Lock锁</h2><blockquote>
<p>传统synchronized，锁+队列</p>
</blockquote>
<p>1、修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </p>
<p>2、修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </p>
<p>3、修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </p>
<p>4、修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Ticket t1 = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">40</span>;i++) t1.buy();},<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">40</span>;i++) t1.buy();},<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">40</span>;i++) t1.buy();},<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"买到了第"</span> + (tickets--) + <span class="string">"张票，剩余："</span> + tickets);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>Lock接口</p>
</blockquote>
<p><img alt="image-20210131124819662" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131124819662.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131124819662.png"></p>
<p><img alt="image-20210131131956970" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131131956970.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131131956970.png"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Ticket1 t1 = <span class="keyword">new</span> Ticket1();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">40</span>;i++) t1.buy();},<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">40</span>;i++) t1.buy();},<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">40</span>;i++) t1.buy();},<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket1</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">30</span>;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"买到了第"</span> + (tickets--) + <span class="string">"张票，剩余："</span> + tickets);</span><br><span class="line">            }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }<span class="keyword">finally</span> {</span><br><span class="line">                lock.unlock();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>Synchronized 和 Lock区别</p>
</blockquote>
<p>1、<code>Synchronized</code>是内置的java关键字，<code>Lock</code>是一个类</p>
<p>2、<code>Synchronized</code>无法判断获取锁的状态，Lock可以判断</p>
<p>3、<code>Synchronized</code>会自动释放锁，Lock必须手动释放，不释放会导致死锁。</p>
<p>4、<code>Synchronized</code>（线程1：阻塞，线程2：等待）；Lock锁不一定会一直等待下去。</p>
<p>5、<code>Synchronized</code>是可重入锁，不可以中断的，非公平；Lock，可重入，可判断锁，公平性可自己设置。</p>
<p>6、<code>Synchronized</code>适合锁少量的代码同步问题；Lock适合大量同步代码。</p>
<h2 id="4、生产者-消费者问题"><a href="#4、生产者-消费者问题" class="headerlink" title="4、生产者/消费者问题"></a>4、生产者/消费者问题</h2><blockquote>
<p>单值缓冲区，单生产者，单消费者，Synchronized</p>
</blockquote>
<p><strong>判断等待，业务，通知</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.PC;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 生产者消费者问题</span></span><br><span class="line"><span class="comment"> * 缓冲区大小为1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Buffer buffer = <span class="keyword">new</span> Buffer();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                    buffer.increment();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        },<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                    buffer.decrement();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        },<span class="string">"B"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">if</span>(num!=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        }</span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"==&gt;"</span>+num);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        }</span><br><span class="line">        num--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"==&gt;"</span>+num);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>多生产者，多消费者时，if判断有问题</p>
</blockquote>
<p>会出现虚假唤醒！！！</p>
<p><img alt="image-20210131135810795" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131135810795.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131135810795.png"></p>
<p><strong>解决方案：if改为while</strong></p>
<blockquote>
<p>JUC中生产者/消费者问题 Condition</p>
</blockquote>
<p>必须使用两个条件变量量保证，因为消费者可能唤醒消费者，导致所有线程睡眠！</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.PC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CodeFriday </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Buffer1 buffer = <span class="keyword">new</span> Buffer1();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    buffer.increment();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span>(Exception e){</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        },<span class="string">"A生产者"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    buffer.decrement();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span>(Exception e){</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        },<span class="string">"B消费者"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    buffer.decrement();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span>(Exception e){</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        },<span class="string">"C消费者"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer1</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    ReentrantLock lock  = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition empty = lock.newCondition();</span><br><span class="line">    Condition full = lock.newCondition();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span>(num!=<span class="number">0</span>){</span><br><span class="line">                empty.await();</span><br><span class="line">            }</span><br><span class="line">            num++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"==&gt;"</span>+num);</span><br><span class="line">            full.signal();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span>(num==<span class="number">0</span>){</span><br><span class="line">                full.await();</span><br><span class="line">            }</span><br><span class="line">            num--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"==&gt;"</span>+num);</span><br><span class="line">            empty.signal();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>condition精准唤醒</p>
</blockquote>
<p>背景：一个资源类，其中三个方法，负责打印A，B，C，三个线程操作资源类，一个线程循环调用一种，但是必须安装ABC循环的顺序输出。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.PC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CodeFriday </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Buffer3 buffer3 = <span class="keyword">new</span> Buffer3();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++){</span><br><span class="line">                buffer3.PrintA();</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++){</span><br><span class="line">                buffer3.PrintB();</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++){</span><br><span class="line">                buffer3.PrintC();</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer3</span></span>{</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition c1 = lock.newCondition();</span><br><span class="line">    Condition c2 = lock.newCondition();</span><br><span class="line">    Condition c3 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintA</span><span class="params">()</span></span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span>(num!=<span class="number">1</span>){</span><br><span class="line">                c1.await();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"A"</span>);</span><br><span class="line">            num++;</span><br><span class="line">            c2.signal();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintB</span><span class="params">()</span></span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span>(num!=<span class="number">2</span>){</span><br><span class="line">                c2.await();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"B"</span>);</span><br><span class="line">            num++;</span><br><span class="line">            c3.signal();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintC</span><span class="params">()</span></span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">while</span>(num!=<span class="number">3</span>){</span><br><span class="line">                c3.await();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"C"</span>);</span><br><span class="line">            num=<span class="number">1</span>;</span><br><span class="line">            c1.signal();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="5、八锁现象"><a href="#5、八锁现象" class="headerlink" title="5、八锁现象"></a>5、八锁现象</h2><blockquote>
<p>场景一：主函数确保了两个线程调用同步方法的顺序，先打印 发短信 后打印 打电话</p>
<p>答案：发短信</p>
<p>原因：synchronized修饰的方法锁的是调用该方法的对象，也就是new出来的phone</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.EightLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Scene1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Phone1 phone = <span class="keyword">new</span> Phone1();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            phone.call();</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone1</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>场景二：给打电话方法加上休眠4秒，谁先输出</p>
<p>答案：发短信</p>
<p>原因：被 synchronized 修饰的方式，锁的对象是方法的调用者</p>
<p>调用的是同一个对象</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.EightLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Scene2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Phone2 phone = <span class="keyword">new</span> Phone2();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            phone.call();</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone2</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>场景三：去掉call方法synchronized，谁先输出</p>
<p>答案：打电话</p>
<p>原因：无synchronized修饰不受锁的影响，发短信线程获得锁休眠对其无影响</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.EightLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Scene3</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Phone3 phone = <span class="keyword">new</span> Phone3();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            phone.call();</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone3</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>场景四：两个方法都用synchronized修饰，但是两个线程调用不同对象的方法，谁先输出</p>
<p>答案：打电话</p>
<p>原因：发短信线程休眠锁的对象是phone，但是打电话线程需要的对象是phone_1互不影响</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.EightLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Scene4</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Phone4 phone = <span class="keyword">new</span> Phone4();</span><br><span class="line">        Phone4 phone_1 = <span class="keyword">new</span> Phone4();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            phone_1.call();</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone4</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>场景五：同步方法加static修饰，谁先输出？</p>
<p>答案：发短信</p>
<p>原因：只要方法被 static 修饰，锁的对象就是 Class模板对象,这个则全局唯一！</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.EightLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Scene5</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Phone5 phone = <span class="keyword">new</span> Phone5();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            phone.call();</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone5</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>场景六：把call的static去掉，谁先输出？</p>
<p>答案：打电话</p>
<p>原因：第一个线程调用sendSms由于是静态同步方法，锁的是class类模板，而第二个线程调用call需要的是对象phone的锁。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.EightLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Scene6</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Phone6 phone = <span class="keyword">new</span> Phone6();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            phone.call();</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone6</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>场景七：static+synchronized修饰两个方法，调用不同对象的方法，谁先输出</p>
<p>答案：发短信</p>
<p>原因：static修饰锁定的class类模板，全局唯一</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.EightLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Scene7</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Phone7 phone = <span class="keyword">new</span> Phone7();</span><br><span class="line">        Phone7 phone_1 = <span class="keyword">new</span> Phone7();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            phone_1.call();</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone7</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>场景八：把call方法static去掉，两个线程调用两个对象的方法，谁先输出？</p>
<p>答案：打电话</p>
<p>原因：第一个线程锁的是类模板，第二个锁的是phone_1，互补影响</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.EightLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Scene8</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Phone8 phone = <span class="keyword">new</span> Phone8();</span><br><span class="line">        Phone8 phone_1 = <span class="keyword">new</span> Phone8();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            phone_1.call();</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone8</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"发短信"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="6、集合类不安全"><a href="#6、集合类不安全" class="headerlink" title="6、集合类不安全"></a>6、集合类不安全</h2><blockquote>
<p>List不安全</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.UnSafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestList</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 报错：List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span></span><br><span class="line"><span class="comment">         * 解决方案：</span></span><br><span class="line"><span class="comment">         * 1、List&lt;String&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line"><span class="comment">         * 2、List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 3、List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * CopyOnWrite：写入时复制 COW</span></span><br><span class="line"><span class="comment">         * 读写分离，写入时先复制一份，写完覆盖回去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++){</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            }).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>CopyOnWriteArrayList</code>方法源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            lock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>Set不安全</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.UnSafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSet</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Set&lt;String&gt; set = new HashSet&lt;&gt;();</span></span><br><span class="line"><span class="comment">         * 报错java.util.ConcurrentModificationException</span></span><br><span class="line"><span class="comment">         * 解决方案：</span></span><br><span class="line"><span class="comment">         * 1、Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 2、JUC下的 Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            },String.valueOf(i)).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>HashSet</code>底层：<code>HashMap</code></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>{</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p><code>add</code>方法：将加入<code>set</code>集合的对象作为<code>Hashmap</code>的<code>key</code>来保证不重复！</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>HashMap不安全</p>
</blockquote>
<p><code>HashMap</code>不安全分<code>JDK</code>版本，一般1.8和1.7</p>
<p>1.7版本之前<code>HashMap</code>实现数组+链表（冲突解决策略）</p>
<p>1.8版本之后多引入红黑树，解决冲突链表过长问题</p>
<p><strong>HashMap</strong></p>
<ul>
<li><p>1.7版本中<code>HashMap</code>链表使用头插法，并发会出现死循环</p>
</li>
<li><p>1.8版本中HashMap采用尾插法，但是并发导致节点覆盖</p>
</li>
</ul>
<p><strong>ConcurrentHashMap</strong></p>
<ul>
<li>1.7版本采用分段锁实现</li>
<li>1.8版本采用<code>CAS</code> + <code>synchronized</code></li>
</ul>
<p>测试：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.UnSafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMap</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ConcurrentModificationException</span></span><br><span class="line"><span class="comment">         * HashMap&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">         * 解决方案： ConcurrentHashMap&lt;String, Integer&gt; hashMap = new ConcurrentHashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ConcurrentHashMap&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">                hashMap.put(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>),<span class="number">0</span>);</span><br><span class="line">                System.out.println(hashMap);</span><br><span class="line">            }).start();</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="7、Callable"><a href="#7、Callable" class="headerlink" title="7、Callable"></a>7、Callable</h2><p><img alt="image-20210131173417268" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131173417268.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131173417268.png"></p>
<p><strong>相比Runnable的好处：</strong><br>1、可以返回值</p>
<p>2、可以抛出异常</p>
<p><img alt="image-20210131185551879" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131185551879.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131185551879.png"></p>
<blockquote>
<p>测试代码</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.TestCallable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>{</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        FutureTask task = <span class="keyword">new</span> FutureTask(thread);</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        System.out.println(task.get());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(<span class="string">"==&gt;call()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意：<br>1、get方法获得返回值会阻塞。</p>
<p>2、有缓存，上述代码只输出一次”==&gt;call()”</p>
<h2 id="8、常用的辅助类"><a href="#8、常用的辅助类" class="headerlink" title="8、常用的辅助类"></a>8、常用的辅助类</h2><h3 id="8-1、CountDownLatch"><a href="#8-1、CountDownLatch" class="headerlink" title="8.1、CountDownLatch"></a>8.1、CountDownLatch</h3><blockquote>
<p>JDK文档描述</p>
</blockquote>
<p><img alt="image-20210131190803277" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131190803277.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131190803277.png"></p>
<blockquote>
<p>测试代码</p>
</blockquote>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCountDownLatch</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        CountDownLatch count = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">10</span>;i++){</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" go out!"</span>);</span><br><span class="line">                count.countDown();</span><br><span class="line">            },String.valueOf(i)).start();</span><br><span class="line">        }</span><br><span class="line">        count.await();<span class="comment">//如果计数器不为0，此方法会阻塞，不会继续往下执行</span></span><br><span class="line">        System.out.println(<span class="string">"Close door!"</span>);<span class="comment">//一定最后输出！</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实际就是一个减法计数器。</p>
<p>原理：</p>
<p><code>CountDownLatch.countDown();</code>数量减1，不会阻塞</p>
<p><code>CountDownLatch.await();</code>等待计数器为0，会唤醒调用它的线程。</p>
<h3 id="8-2、CyclicBarrier"><a href="#8-2、CyclicBarrier" class="headerlink" title="8.2、CyclicBarrier"></a>8.2、CyclicBarrier</h3><blockquote>
<p>JDK文档描述</p>
</blockquote>
<p><img alt="image-20210131191619447" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131191619447.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131191619447.png"></p>
<p>简单理解：当一些线程执行完才会最终获得某个结果，集齐7龙珠召唤神龙！</p>
<blockquote>
<p>测试代码</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCyclicBarrier</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,()-&gt;{</span><br><span class="line">            System.out.println(<span class="string">"召唤神龙成功"</span>);</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">                System.out.println(<span class="string">"获得第"</span>+temp+<span class="string">"颗龙珠~"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">catch</span> (BrokenBarrierException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="8-3、Semophore"><a href="#8-3、Semophore" class="headerlink" title="8.3、Semophore"></a>8.3、Semophore</h3><blockquote>
<p>JDK文档描述</p>
</blockquote>
<p><img alt="image-20210131193109296" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131193109296.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131193109296.png"></p>
<p>操作系统中的信号量：通俗的说初始化给定一个参数表示做多允许多少条线程<code>acquire</code>，其他线程就会阻塞等待，线程调用<code>release</code>释放资源。</p>
<blockquote>
<p>测试代码：以6个车抢车位为例子</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"==&gt;抢到车位"</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }<span class="keyword">finally</span> {</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"==&gt;离开车位"</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }).start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>可做限流！</strong></p>
<p>原理：<br><code>semaphore.acquire();</code>获得操作-1，满了就睡眠。</p>
<p><code>semaphore.release();</code>释放操作+1，唤醒睡眠的线程。</p>
<h2 id="9、读写锁"><a href="#9、读写锁" class="headerlink" title="9、读写锁"></a>9、读写锁</h2><ul>
<li><p>读的时候能多个线程同时读</p>
</li>
<li><p>写的时候只能一个锁写</p>
</li>
</ul>
<blockquote>
<p>操作系统中的实现（C）</p>
</blockquote>
<p><img alt="image-20210131200817339" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131200817339.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131200817339.png"></p>
<p><strong>实现思想：</strong></p>
<p>获取读锁时：首先获取lock，增加reader变量追踪读者数量，当第一个读着获取该锁时，读者也会获得写锁，最后释放lock。</p>
<p>一旦一个读者获得读锁，其他读者也可以获得这个读锁，但是，想要获取写锁的线程必须等到所有读者结束。即最后推出的写者在”writelock”上调用<code>sem_post</code>，从而等待的写者能获得该锁。</p>
<p><strong>需要达到互斥的操作：</strong></p>
<ul>
<li>读-写</li>
<li>写-写</li>
</ul>
<p><strong>总结一句话：读要等待写完，写要等待读者全部退出</strong></p>
<blockquote>
<p>Java代码测试</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReadWrite</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MyCache cache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">                cache.put(temp+<span class="string">""</span>,temp);</span><br><span class="line">            }).start();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">                cache.get(temp+<span class="string">""</span>);</span><br><span class="line">            }).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> HashMap&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    ReentrantReadWriteLock RWLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="comment">//写</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,Object value)</span></span>{</span><br><span class="line">        RWLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"写入"</span>+key);</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"写入完成"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            RWLock.writeLock().unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//读</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span></span>{</span><br><span class="line">        RWLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"读取"</span>+key);</span><br><span class="line">            Object o = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"读取完成"</span>+key);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            RWLock.readLock().unlock();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：(写不能被打断，读可以同时读)</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>写入<span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span>写入完成</span><br><span class="line">Thread-<span class="number">1</span>写入<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>写入完成</span><br><span class="line">Thread-<span class="number">2</span>写入<span class="number">2</span></span><br><span class="line">Thread-<span class="number">2</span>写入完成</span><br><span class="line">Thread-<span class="number">3</span>写入<span class="number">3</span></span><br><span class="line">Thread-<span class="number">3</span>写入完成</span><br><span class="line">Thread-<span class="number">4</span>写入<span class="number">4</span></span><br><span class="line">Thread-<span class="number">4</span>写入完成</span><br><span class="line">Thread-<span class="number">6</span>读取<span class="number">1</span></span><br><span class="line">Thread-<span class="number">6</span>读取完成<span class="number">1</span></span><br><span class="line">Thread-<span class="number">8</span>读取<span class="number">3</span></span><br><span class="line">Thread-<span class="number">7</span>读取<span class="number">2</span></span><br><span class="line">Thread-<span class="number">7</span>读取完成<span class="number">2</span></span><br><span class="line">Thread-<span class="number">8</span>读取完成<span class="number">3</span></span><br><span class="line">Thread-<span class="number">5</span>读取<span class="number">0</span></span><br><span class="line">Thread-<span class="number">9</span>读取<span class="number">4</span></span><br><span class="line">Thread-<span class="number">5</span>读取完成<span class="number">0</span></span><br><span class="line">Thread-<span class="number">9</span>读取完成<span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="10、阻塞队列BlockingQueue"><a href="#10、阻塞队列BlockingQueue" class="headerlink" title="10、阻塞队列BlockingQueue"></a>10、阻塞队列BlockingQueue</h2><p>写入：如果队列满了，就必须阻塞等待取出</p>
<p>取出：如果队列为空，就必须阻塞等待写入</p>
<p><img alt="image-20210131205017912" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131205017912.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131205017912.png"></p>
<p><strong>用途：线程池 多并发处理</strong></p>
<p><strong>依据它的基本原理，我们可以实现Web中的长连接聊天功能</strong></p>
<p><strong>ArrayBlockingQueue：</strong></p>
<ul>
<li><p>一个对象数组+一把锁+两个条件</p>
</li>
<li><p>入队与出队都用同一把锁</p>
</li>
<li><p>在只有入队高并发或出队高并发的情况下，因为操作数组，且不需要扩容，性能很高</p>
</li>
<li><p>采用了数组，必须指定大小，即容量有限</p>
</li>
</ul>
<p><strong>LinkedBlockingQueue：</strong></p>
<ul>
<li><p>一个单向链表+两把锁+两个条件</p>
</li>
<li><p>两把锁，一把用于入队，一把用于出队，有效的避免了入队与出队时使用一把锁带来的竞争。</p>
</li>
<li><p>在入队与出队都高并发的情况下，性能比<code>ArrayBlockingQueue</code>高很多</p>
</li>
</ul>
<p>采用了链表，最大容量为整数最大值，可看做容量无限</p>
<p><strong>4组不同的API：</strong></p>
<table>
<thead>
<tr>
<th>操作\方式</th>
<th>抛出异常</th>
<th>有返回值，不抛出异常</th>
<th>阻塞 等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td>add</td>
<td>offer()</td>
<td>put()</td>
<td>offer(,,)</td>
</tr>
<tr>
<td>移除</td>
<td>remove</td>
<td>poll()</td>
<td>take()</td>
<td>poll(,)</td>
</tr>
<tr>
<td>检测队首元素</td>
<td>element</td>
<td>peek()</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<blockquote>
<p>SynchronizedQueue 同步队列</p>
</blockquote>
<blockquote>
<p>JDK描述</p>
</blockquote>
<p><img alt="image-20210131223318236" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131223318236.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210131223318236.png"></p>
<p>没有容量，put和take方法</p>
<p>进去一个对象，必须等待去除来！</p>
<blockquote>
<p>Java代码测试 put+take线程</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronizedQueue</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; sq = <span class="keyword">new</span> SynchronousQueue();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"==&gt;put"</span>);</span><br><span class="line">                sq.put(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"==&gt;put"</span>);</span><br><span class="line">                sq.put(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"==&gt;put"</span>);</span><br><span class="line">                sq.put(<span class="number">3</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"==&gt;take"</span>);</span><br><span class="line">                sq.take();</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"==&gt;take"</span>);</span><br><span class="line">                sq.take();</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"==&gt;take"</span>);</span><br><span class="line">                sq.take();</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="11、线程池"><a href="#11、线程池" class="headerlink" title="11、线程池"></a>11、线程池</h2><blockquote>
<p>池化技术</p>
</blockquote>
<p>线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。 </p>
<p><strong>线程池的好处：</strong></p>
<p>1、降低资源消耗</p>
<p>2、提高响应速度</p>
<p>3、方便管理</p>
<p><strong>线程复用，可以控制最大并发数，管理线程。</strong></p>
<blockquote>
<p>线程池的执行流程：</p>
</blockquote>
<p><img alt="img" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/6024478-88ee7b20f8f45825.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/6024478-88ee7b20f8f45825.png"></p>
<blockquote>
<p>四个常见线程池，Excutors类创建</p>
</blockquote>
<p><strong>CachedThreadPool:</strong>可缓存的线程池，该线程池中没有核心线程，非核心线程的数量为Integer.max_value，就是无限大，当有需要时创建线程来执行任务，没有需要时回收线程，适用于耗时少，任务量大的情况，超过60s释放线程。</p>
<p><strong>SecudleThreadPool:</strong>周期性执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大。适用于执行周期性的任务。</p>
<p><strong>SingleThreadPool:</strong>只有一条线程来执行任务，适用于有顺序的任务的应用场景。</p>
<p><strong>FixedThreadPool:</strong>定长的线程池，有核心线程，核心线程的即为最大的线程数量，没有非核心线程</p>
<blockquote>
<p>ThreadPoolExecutor七大参数</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,//最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,//线程存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,//时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,//线程工场</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span><span class="comment">//拒绝策略</span></span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>四大拒绝策略</p>
</blockquote>
<p><strong>线程池最大容量 = 最大线程数+阻塞队列容量</strong></p>
<ul>
<li><p><code>ThreadPoolExecutor.AbortPolicy()</code></p>
<p>超过线程池容量，抛出<code>RejectedExecutionException</code></p>
</li>
<li><p><code>ThreadPoolExecutor.CallerRunsPolicy()</code></p>
<p>由调用者执行被拒绝的线程</p>
</li>
<li><p><code>ThreadPoolExecutor.DiscardPolicy()</code></p>
<p>丢掉任务，但是不抛出异常</p>
</li>
<li><p><code>ThreadPoolExecutor.DiscardOldestPolicy()</code></p>
<p>尝试和最早执行的任务的竞争，竞争失败则直接丢弃，不会抛出异常</p>
</li>
</ul>
<blockquote>
<p>如何选择最大线数</p>
</blockquote>
<ul>
<li>CPU密集型：一般获取CPU的核数，即设置成最大线程数</li>
<li>IO密集型：IO耗费时间更多，一般设置成核数*2</li>
</ul>
<p><strong>如何获取CPU核数？</strong></p>
<p><code>Runtime.getRuntime().availableProcessors()</code></p>
<h2 id="12、四大函数式接口"><a href="#12、四大函数式接口" class="headerlink" title="12、四大函数式接口"></a>12、四大函数式接口</h2><ul>
<li><p>链式编程</p>
<p>调用方法时返回一个this对象，即可调用方法后面再跟调用方法</p>
</li>
<li><p>Lamda表达式</p>
<p>函数式接口的简化编程</p>
</li>
</ul>
<p><strong>函数式接口：只有一个抽象方法的接口类</strong></p>
<blockquote>
<p>函数型接口Function</p>
</blockquote>
<p><img alt="image-20210201120745130" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210201120745130.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210201120745130.png"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.TestFunctionInterface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFunction</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">/**普通实现：匿名内部类。</span></span><br><span class="line"><span class="comment">         *         Function&lt;String, String&gt; function = new Function&lt;String, String&gt;() {</span></span><br><span class="line"><span class="comment">         *             <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">         *             public String apply(String o) {</span></span><br><span class="line"><span class="comment">         *                 return o;</span></span><br><span class="line"><span class="comment">         *             }</span></span><br><span class="line"><span class="comment">         *         };</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//Lambda表达式：第一个o传入参数，第二个o返回参数</span></span><br><span class="line">        Function&lt;String, String&gt; function = o -&gt; o;</span><br><span class="line">        System.out.println(function.apply(<span class="string">"Hello World!"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>Predicate断定型接口</p>
</blockquote>
<p><img alt="image-20210201121731054" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210201121731054.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210201121731054.png"></p>
<p>传入一个参数，返回一个boolean值，一般用来做判断用</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.TestFunctionInterface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPredicate</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">/***</span></span><br><span class="line"><span class="comment">         * 匿名内部类写法：</span></span><br><span class="line"><span class="comment">         * Predicate&lt;Integer&gt; predicate = new Predicate&lt;Integer&gt;() {</span></span><br><span class="line"><span class="comment">         *             <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">         *             public boolean test(Integer integer) {</span></span><br><span class="line"><span class="comment">         *                 return integer &gt; 5;</span></span><br><span class="line"><span class="comment">         *             }</span></span><br><span class="line"><span class="comment">         *         };</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//Lambda表达式</span></span><br><span class="line">        Predicate&lt;Integer&gt; predicate = integer -&gt; integer &gt; <span class="number">5</span>;</span><br><span class="line">        System.out.println(predicate.test(<span class="number">10</span>));</span><br><span class="line">        System.out.println(predicate.test(<span class="number">4</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>Consumer 消费型接口</p>
</blockquote>
<p><img alt="image-20210201122653549" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210201122653549.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210201122653549.png"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.TestFunctionInterface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConsumer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 匿名内部类写法：</span></span><br><span class="line"><span class="comment">         * Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() {</span></span><br><span class="line"><span class="comment">         *             <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">         *             public void accept(String o) {</span></span><br><span class="line"><span class="comment">         *                 System.out.println(o);</span></span><br><span class="line"><span class="comment">         *             }</span></span><br><span class="line"><span class="comment">         *         };</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//Lambda表达式</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = o -&gt; System.out.println(o);</span><br><span class="line">        consumer.accept(<span class="string">"Test"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>Supplier 供给型接口</p>
</blockquote>
<p><img alt="image-20210201123229800" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210201123229800.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210201123229800.png"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.TestFunctionInterface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSupplier</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 匿名内部类写法</span></span><br><span class="line"><span class="comment">         *  Supplier&lt;Integer&gt; supplier = new Supplier&lt;Integer&gt;() {</span></span><br><span class="line"><span class="comment">         *             <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">         *             public Integer get() {</span></span><br><span class="line"><span class="comment">         *                 return new Random().nextInt();</span></span><br><span class="line"><span class="comment">         *             }</span></span><br><span class="line"><span class="comment">         *         };</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Supplier&lt;Integer&gt; supplier = () -&gt; <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="13、Stream流式计算"><a href="#13、Stream流式计算" class="headerlink" title="13、Stream流式计算"></a>13、Stream流式计算</h2><blockquote>
<p>什么是Stream流式计算</p>
</blockquote>
<p>大数据=存储+计算</p>
<p>集合、MySQL本质就是存储东西的，计算应该交给流</p>
<blockquote>
<p>filter</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>传入一个<code>Predicate</code>函数式接口用于判断条件，保留返回值为真的结果。</p>
<blockquote>
<p>map</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>传入一个<code>Function</code>函数式接口，将流中对象某对象替换成其他对象。</p>
<blockquote>
<p>sorted(Comparator)</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>传入一个比较器排序。</p>
<blockquote>
<p>limit</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>输出流中的前<code>maxSize</code>个对象</p>
<blockquote>
<p>forEach</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>传入消费性函数式接口遍历流进行一些附加操作。</p>
<p><strong>共性，一些计算操作都返回了一个Stream流，因此可用作链式编程！</strong></p>
<blockquote>
<p>代码测试</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.StreamTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目要求：一行代码实现</span></span><br><span class="line"><span class="comment"> * 现在有五个用户，筛选</span></span><br><span class="line"><span class="comment"> * 1、ID必须为偶数</span></span><br><span class="line"><span class="comment"> * 2、年龄必须大于23岁</span></span><br><span class="line"><span class="comment"> * 3、用户名转为大写字母</span></span><br><span class="line"><span class="comment"> * 4、用户名倒叙排序</span></span><br><span class="line"><span class="comment"> * 5、只输出一个用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStream</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"a"</span>,<span class="number">21</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">"b"</span>,<span class="number">22</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="number">3</span>,<span class="string">"c"</span>,<span class="number">23</span>);</span><br><span class="line">        User u4 = <span class="keyword">new</span> User(<span class="number">4</span>,<span class="string">"d"</span>,<span class="number">24</span>);</span><br><span class="line">        User u5 = <span class="keyword">new</span> User(<span class="number">6</span>,<span class="string">"e"</span>,<span class="number">25</span>);</span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(u1,u2,u3,u4,u5);</span><br><span class="line">        Stream&lt;User&gt; stream = list.stream();</span><br><span class="line">        stream.filter(u-&gt; (u.getId()%<span class="number">2</span>)==<span class="number">0</span>)</span><br><span class="line">                .filter(u-&gt;u.getAge()&gt;<span class="number">23</span>)</span><br><span class="line">                .map(u-&gt;<span class="keyword">new</span> User(u.getId(),u.getName().toUpperCase(Locale.ROOT),u.getAge()))</span><br><span class="line">                .sorted((o1, o2) -&gt; o2.getName().compareTo(o1.getName()))</span><br><span class="line">                .limit(<span class="number">1</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User{"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>总结：流式计算=链式编程+函数式接口，函数式接口方便使用Lambda表达式简化编程！</strong></p>
<h2 id="14、ForkJoin"><a href="#14、ForkJoin" class="headerlink" title="14、ForkJoin"></a>14、ForkJoin</h2><blockquote>
<p>什么是ForkJoin</p>
</blockquote>
<p>ForkJoin是由JDK1.7后提供多线并发处理框架。ForkJoin的框架的基本思想是分而治之。</p>
<p>大数据领域：Map Reduce 任务拆分</p>
<p><img alt="image-20210201150712556" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210201150712556.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210201150712556.png"></p>
<blockquote>
<p>FrokJoin使用方法</p>
</blockquote>
<h4 id="一、-创建Task"><a href="#一、-创建Task" class="headerlink" title="一、 创建Task"></a>一、 创建Task</h4><p>使用ForkJoin框架，需要创建一个ForkJoin的任务，而ForkJoinTask是一个抽象类，我们不需要去继承ForkJoinTask进行使用。因为ForkJoin框架为我们提供了RecursiveAction和RecursiveTask。我们只需要继承ForkJoin为我们提供的抽象类的其中一个并且实现compute方法。</p>
<h4 id="二、使用ForkJoinPool进行执行"><a href="#二、使用ForkJoinPool进行执行" class="headerlink" title="二、使用ForkJoinPool进行执行"></a>二、使用ForkJoinPool进行执行</h4><p>task要通过ForkJoinPool来执行，分割的子任务也会添加到当前工作线程的双端队列中，<br>进入队列的头部。当一个工作线程中没有任务时，会从其他工作线程的队列尾部获取一个任务(工作窃取)。</p>
<h4 id="三、RecursiveTask和RecursiveAction区别"><a href="#三、RecursiveTask和RecursiveAction区别" class="headerlink" title="三、RecursiveTask和RecursiveAction区别"></a>三、RecursiveTask和RecursiveAction区别</h4><p>前者有返回结果，后者没有返回结果。</p>
<p>fork负责分割工作</p>
<blockquote>
<p>ForkJoin特点：工作窃取</p>
</blockquote>
<p>类似多CPU调度中，CPU空闲会从其他地方窃取工作执行。</p>
<p>一般工作集都是双端队列！</p>
<p>这个框架是借助了现代计算机多核的优势并行去处理数据。</p>
<blockquote>
<p>代码测试</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.ForkJoinTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.OptionalLong;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ForkJoinTask&lt;Long&gt; task = new MyTask(1L,10_0000_0000L);</span></span><br><span class="line"><span class="comment">         *         ForkJoinPool forkJoinPool = new ForkJoinPool();</span></span><br><span class="line"><span class="comment">         *         Long ans = forkJoinPool.invoke(task);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Long ans = new SimpleCal(1L, 10_0000_0000L).CalculateIt();</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        OptionalLong ans = LongStream.rangeClosed(<span class="number">1L</span>,<span class="number">10_0000_0000L</span>).parallel().reduce(Long::sum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"ans = "</span>+ans+<span class="string">"，耗时："</span>+(end-start));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//简单for循环计算  耗时：12628</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleCal</span></span>{</span><br><span class="line">    Long start;</span><br><span class="line">    Long end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleCal</span><span class="params">(Long start, Long end)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">CalculateIt</span><span class="params">()</span></span>{</span><br><span class="line">        Long sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (Long i = start; i &lt;= end; i++) {</span><br><span class="line">            sum+=i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//ForkJoin计算5619</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt;</span>{</span><br><span class="line">    Long start;</span><br><span class="line">    Long end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(Long start, Long end)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(end-start&lt;<span class="number">10000</span>){</span><br><span class="line">            Long sum = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span>(Long i = start;i&lt;=end;i++){</span><br><span class="line">                sum+=i;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            Long mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">            MyTask left = <span class="keyword">new</span> MyTask(start,mid);</span><br><span class="line">            left.fork();</span><br><span class="line">            MyTask right = <span class="keyword">new</span> MyTask(mid+<span class="number">1</span>,end);</span><br><span class="line">            right.fork();</span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="15、异步回调"><a href="#15、异步回调" class="headerlink" title="15、异步回调"></a>15、异步回调</h2><blockquote>
<p>同步回调</p>
</blockquote>
<p> 我们常用的一些请求都是同步回调的，同步回调是阻塞的，单个的线程需要等待结果的返回才能继续执行。</p>
<p><img alt="img" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/2018052219070510" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/2018052219070510"></p>
<blockquote>
<p> 异步回调</p>
</blockquote>
<p>有的时候，我们不希望程序在某个执行方法上一直阻塞，需要先执行后续的方法，那就是这里的异步回调。我们在调用一个方法时，如果执行时间比较长，我们可以传入一个回调的方法，当方法执行完时，让被调用者执行给定的回调方法。</p>
<p><img alt="img" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/20180522190716303" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/20180522190716303"></p>
<h2 id="16、JMM"><a href="#16、JMM" class="headerlink" title="16、JMM"></a>16、JMM</h2><blockquote>
<p>Volatile的特点</p>
</blockquote>
<p>1、保证可见性</p>
<p>2、不保证原子性</p>
<p>3、禁止指令重排</p>
<blockquote>
<p>什么是JMM</p>
</blockquote>
<p>JMM：Java内存模型，一个概念。</p>
<p><strong>关于JMM的一些同步的约定：</strong></p>
<p>1、线程解锁前，必须立刻把工作内存的变量覆盖回主存。</p>
<p>2、线程加锁前，必须读取主存最新值到自己的工作内存。</p>
<p>3、加锁和解锁必须是同一把。</p>
<blockquote>
<p>工作内存 和 主存</p>
</blockquote>
<p>可以简单的认为主内存是java虚拟机内存区域中的堆，局部变量和方法参数是在虚拟机栈中定义的。但是在堆中的变量如果在多线程中都使用，就涉及到了堆和不同虚拟机栈中变量的值的一致性问题了。</p>
<ul>
<li><p>主内存：java虚拟机规定所有的变量(不是程序中的变量)都必须在主内存中产生，为了方便理解，可以认为是堆区。可以与前面说的物理机的主内存相比，只不过物理机的主内存是整个机器的内存，而虚拟机的主内存是虚拟机内存中的一部分。</p>
</li>
<li><p>工作内存：java虚拟机中每个线程都有自己的工作内存，该内存是线程私有的为了方便理解，可以认为是虚拟机栈。可以与前面说的高速缓存相比。线程的工作内存保存了线程需要的变量在主内存中的副本。虚拟机规定，线程对主内存变量的修改必须在线程的工作内存中进行，不能直接读写主内存中的变量。不同的线程之间也不能相互访问对方的工作内存。如果线程之间需要传递变量的值，必须通过主内存来作为中介进行传递。</p>
</li>
</ul>
<p><img alt="img" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/4899162-66736384361f6b8b.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/4899162-66736384361f6b8b.png"></p>
<p><strong><em>这里需要说明一下：主内存、工作内存与java内存区域中的java堆、虚拟机栈、方法区并不是一个层次的内存划分。这两者是基本上是没有关系的。</em></strong></p>
<blockquote>
<p>工作内存与主内存交互(8中操作)</p>
</blockquote>
<p><img alt="image-20210202203941374" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210202203941374.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210202203941374.png"></p>
<p><strong>lock(锁定)</strong>:作用于主内存的变量，一个变量在同一时间只能一个线程锁定，该操作表示这条线成独占这个变量</p>
<p><strong>unlock(解锁)</strong>:作用于主内存的变量，表示这个变量的状态由处于锁定状态被释放，这样其他线程才能对该变量进行锁定</p>
<p><strong>read(读取)</strong>:作用于主内存变量，表示把一个主内存变量的值传输到线程的工作内存，以便随后的load操作使用</p>
<p><strong>load(载入)</strong>:作用于线程的工作内存的变量，表示把read操作从主内存中读取的变量的值放到工作内存的变量副本中(副本是相对于主内存的变量而言的)</p>
<p><strong>use(使用)</strong>:作用于线程的工作内存中的变量，表示把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作</p>
<p><strong>assign(赋值)</strong>:作用于线程的工作内存的变量，表示把执行引擎返回的结果赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作</p>
<p><strong>store(存储)</strong>:作用于线程的工作内存中的变量，把工作内存中的一个变量的值传递给主内存，以便随后的write操作使用</p>
<p><strong>write(写入)</strong>:作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中</p>
<p>对于这8中操作，虚拟机也规定了一系列规则，在执行这8中操作的时候必须遵循如下的规则：</p>
<p><strong>不允许read和load、store和write操作之一单独出现</strong>，也就是不允许从主内存读取了变量的值但是工作内存不接收的情况，或者不允许从工作内存将变量的值回写到主内存但是主内存不接收的情况</p>
<p><strong>不允许一个线程丢弃最近的assign操作</strong>，也就是不允许线程在自己的工作线程中修改了变量的值却不同步/回写到主内存</p>
<p><strong>不允许一个线程回写没有修改的变量到主内存</strong>，也就是如果线程工作内存中变量没有发生过任何assign操作，是不允许将该变量的值回写到主内存</p>
<p><strong>变量只能在主内存中产生</strong>，不允许在工作内存中直接使用一个未被初始化的变量，也就是没有执行load或者assign操作。也就是说在执行use、store之前必须对相同的变量执行了load、assign操作</p>
<p><strong>一个变量在同一时刻只能被一个线程对其进行lock操作</strong>，也就是说一个线程一旦对一个变量加锁后，在该线程没有释放掉锁之前，其他线程是不能对其加锁的，但是同一个线程对一个变量加锁后，可以继续加锁，同时在释放锁的时候释放锁次数必须和加锁次数相同。</p>
<p><strong>对变量执行lock操作，就会清空工作空间该变量的值</strong>，执行引擎使用这个变量之前，需要重新load或者assign操作初始化变量的值</p>
<p><strong>不允许对没有lock的变量执行unlock操作</strong>，如果一个变量没有被lock操作，那也不能对其执行unlock操作，当然一个线程也不能对被其他线程lock的变量执行unlock操作</p>
<p><strong>对一个变量执行unlock之前，必须先把变量同步回主内存中</strong>，也就是执行store和write操作</p>
<p>问题：程序不知道主内存的值已经被修改过了。</p>
<h2 id="17、Volatile"><a href="#17、Volatile" class="headerlink" title="17、Volatile"></a>17、Volatile</h2><blockquote>
<p>1、可见性</p>
</blockquote>
<p><strong>线程知道主存的变量被其他线程修改。</strong></p>
<blockquote>
<p>2、不保证原子性</p>
</blockquote>
<p>原子性：一个任务，要么执行完，要么没执行。</p>
<p>多线程累加一个整数时，用Volatile修饰有问题，可以使用，JUC包下的Automaitc包装类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) {</span><br><span class="line">                    add();</span><br><span class="line">                }</span><br><span class="line">            }).start();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//主线程休眠等待，保证先加完再输出</span></span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">2</span>){</span><br><span class="line">            Thread.yield();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>{</span><br><span class="line">        num++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>num++实际不是一个原子操作，需要三个指令！！！</p>
<p><img alt="image-20210202213140886" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210202213140886.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210202213140886.png"></p>
<p>实际原子类中的方法都调用了Unsafe类中的方法，Unsafe类中是一些本地方法JNI，直接和操作系统挂钩。</p>
<blockquote>
<p>什么是指令重排</p>
</blockquote>
<p>程序高效执行，写的代码编译之后的指令会经过代码优化阶段，指令重排等。</p>
<p>编译原理中编译器后端代码生成，代码优化中有~</p>
<p>由于内存屏障，所以保证避免指令重拍现象。</p>
<h2 id="18、单例模式"><a href="#18、单例模式" class="headerlink" title="18、单例模式"></a>18、单例模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、单例类只能有一个实例。</li>
<li>2、单例类必须自己创建自己的唯一实例。</li>
<li>3、单例类必须给所有其他对象提供这一实例。</li>
</ul>
<blockquote>
<p>介绍</p>
</blockquote>
<p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p>
<p><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</p>
<p><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<p><strong>关键代码：</strong>构造函数是私有的。</p>
<blockquote>
<p>饿汉式</p>
</blockquote>
<p>上来直接新建对象！</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.Single;</span><br><span class="line"><span class="comment">//饿汉式单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>{</span><br><span class="line">    <span class="comment">//可能造成空间浪费</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span></span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载类时就new出对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Hungry HUNGRY = <span class="keyword">new</span> Hungry();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> HUNGRY;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>静态内部类实现单例模式</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.Single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Holder</span><span class="params">()</span></span>{}</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">innerClass</span></span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Holder INSTANCE = <span class="keyword">new</span> Holder();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> innerClass.INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类的优点是：外部类加载时并不需要立即加载内部类，</span></span><br><span class="line"><span class="comment"> * 内部类不被加载则不去初始化INSTANCE，故而不占内存。</span></span><br><span class="line"><span class="comment"> * 即当Holder第一次被加载时，并不需要去加载innerClass，</span></span><br><span class="line"><span class="comment"> * 只有当getInstance()方法第一次被调用时，才会去初始化INSTANCE,</span></span><br><span class="line"><span class="comment"> * 第一次调用getInstance()方法会导致虚拟机加载innerClass类，</span></span><br><span class="line"><span class="comment"> * 这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>懒汉式</p>
</blockquote>
<p>对象用的时候再加载。</p>
<p><strong>(1)有问题的版本</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.Single;</span><br><span class="line"><span class="comment">//懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMan</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyMan lazyman = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//构造器私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyMan</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"OK"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//用到时才创建对象</span></span><br><span class="line">        <span class="keyword">if</span>(lazyman==<span class="keyword">null</span>){</span><br><span class="line">            lazyman = <span class="keyword">new</span> LazyMan();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> lazyman;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//问题：多线程下会破坏单例模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">                LazyMan.getInstance();</span><br><span class="line">            }).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>(2)DCL懒汉式，仍然存在问题</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.Single;</span><br><span class="line"><span class="comment">//懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMan</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyMan lazyman = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//构造器私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyMan</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"OK"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//双重检测锁模式，Double-check-lock,DCL懒汉式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//用到时才创建对象</span></span><br><span class="line">        <span class="keyword">if</span>(lazyman==<span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan<span class="class">.<span class="keyword">class</span>)</span>{</span><br><span class="line">                <span class="keyword">if</span>(lazyman==<span class="keyword">null</span>) {</span><br><span class="line">                    lazyman = <span class="keyword">new</span> LazyMan();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> lazyman;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">                LazyMan.getInstance();</span><br><span class="line">            }).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>lazyman = new LazyMan();</code>不是原子操作，分以下几个步骤</p>
<ul>
<li>分配内存空间</li>
<li>执行构造方法初始化对象</li>
<li>对象指向这个空间</li>
</ul>
<p>解决方案：<code>private static LazyMan lazyman = null;</code>加<code>volatile</code>修饰</p>
<p><strong>(3)反射可以破坏单例模式</strong></p>
<p>反射获得私有构造器，设置可到达，然后<code>newinstance</code>可以通过构造器新建一个对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.Single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMan</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyMan lazyman = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//构造器私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyMan</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"OK"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//双重检测锁模式，Double-check-lock,DCL懒汉式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//用到时才创建对象</span></span><br><span class="line">        <span class="keyword">if</span>(lazyman==<span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan<span class="class">.<span class="keyword">class</span>)</span>{</span><br><span class="line">                <span class="keyword">if</span>(lazyman==<span class="keyword">null</span>) {</span><br><span class="line">                    lazyman = <span class="keyword">new</span> LazyMan();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> lazyman;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        LazyMan instance = LazyMan.getInstance();</span><br><span class="line">        <span class="comment">//获得单例类的构造器</span></span><br><span class="line">        Constructor&lt;LazyMan&gt; constructor = LazyMan<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">null</span>)</span>;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        LazyMan instance2 = constructor.newInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>解决方案：在构造器中加一个判断，如果已经被实例，抛出异常。</strong></p>
<p><strong>(4)加判断避免反射</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.Single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMan</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyMan lazyman = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//构造器私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyMan</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (LazyMan<span class="class">.<span class="keyword">class</span>)</span>{</span><br><span class="line">            <span class="keyword">if</span>(lazyman!=<span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不要试图用反射新建对象！！！"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//双重检测锁模式，Double-check-lock,DCL懒汉式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//用到时才创建对象</span></span><br><span class="line">        <span class="keyword">if</span>(lazyman==<span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan<span class="class">.<span class="keyword">class</span>)</span>{</span><br><span class="line">                <span class="keyword">if</span>(lazyman==<span class="keyword">null</span>) {</span><br><span class="line">                    lazyman = <span class="keyword">new</span> LazyMan();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> lazyman;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        LazyMan instance = LazyMan.getInstance();</span><br><span class="line">        <span class="comment">//获得单例类的构造器</span></span><br><span class="line">        Constructor&lt;LazyMan&gt; constructor = LazyMan<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">null</span>)</span>;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        LazyMan instance2 = constructor.newInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<p><img alt="image-20210203121248535" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203121248535.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203121248535.png"></p>
<p><strong>仍然存在问题：</strong></p>
<p>不使用<code>getInstance</code>方法对象就不会被创建，使用反射获得构造器就可以获得两次实例破坏单例模式！</p>
<p><strong>解决方案：</strong></p>
<p>增加一个标志位，可以当做一个密码位，调用构造器时修改密码位即可。实现代码如下。</p>
<p><strong>(5)密码位判断</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.Single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMan</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> password = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyMan lazyman = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//构造器私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyMan</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (LazyMan<span class="class">.<span class="keyword">class</span>)</span>{</span><br><span class="line">            <span class="keyword">if</span>(password){</span><br><span class="line">                password = <span class="keyword">true</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不要试图用反射新建对象！！！"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//双重检测锁模式，Double-check-lock,DCL懒汉式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//用到时才创建对象</span></span><br><span class="line">        <span class="keyword">if</span>(lazyman==<span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan<span class="class">.<span class="keyword">class</span>)</span>{</span><br><span class="line">                <span class="keyword">if</span>(lazyman==<span class="keyword">null</span>) {</span><br><span class="line">                    lazyman = <span class="keyword">new</span> LazyMan();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> lazyman;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//LazyMan instance = LazyMan.getInstance();</span></span><br><span class="line">        <span class="comment">//获得单例类的构造器</span></span><br><span class="line">        Constructor&lt;LazyMan&gt; constructor = LazyMan<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">null</span>)</span>;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        LazyMan instance1 = constructor.newInstance();</span><br><span class="line">        LazyMan instance2 = constructor.newInstance();</span><br><span class="line">        System.out.println(instance1);</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>问题：</strong>即使标志位经过加密处理，也可能被解密。通过反编译。</p>
<p><strong>解决方案：</strong></p>
<p>查看<code>newInstance</code>的源码如下：</p>
<p><img alt="image-20210203122910178" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203122910178.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203122910178.png"></p>
<p>发现如果是枚举类型就不能破坏单例模式。</p>
<blockquote>
<p>枚举实现单例模式</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.Single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingleEnum {</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SingleEnum <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(SingleEnum.INSTANCE);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是发现编译完的class文件中有一个私有构造方法：</p>
<p><img alt="image-20210203124419607" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203124419607.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203124419607.png"></p>
<p><strong>尝试用反射获取破坏一下：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.Single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingleEnum {</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SingleEnum <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>{</span><br><span class="line">        Constructor&lt;SingleEnum&gt; constructor = SingleEnum<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">null</span>)</span>;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        SingleEnum instance = constructor.newInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>运行结果：</strong></p>
<p><img alt="image-20210203124627741" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203124627741.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203124627741.png"></p>
<p>按道理应该抛出的是<code>newInstance</code>方法中的<code>Cannot reflectively create enum objects</code>异常的，然而却抛出一个找不到构造方法的异常。</p>
<p><strong>使用javap反编译一下：</strong></p>
<p><img alt="image-20210203125041305" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203125041305.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203125041305.png"></p>
<p>发现也存在一个空参构造器。使用更专业的反编译工具！</p>
<p>JAD下载地址：<a href="https://varaneckas.com/jad/" target="_blank" rel="noopener">https://varaneckas.com/jad/</a></p>
<p><img alt="image-20210203131729962" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203131729962.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203131729962.png"></p>
<p>查看源码如下：</p>
<p><img alt="image-20210203131758731" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203131758731.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203131758731.png"></p>
<p>存在一个有参构造，因此我们可以获得该构造器。</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.Single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingleEnum {</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SingleEnum <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>{</span><br><span class="line">        Constructor&lt;SingleEnum&gt; constructor = SingleEnum<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">String</span>.<span class="title">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        SingleEnum instance = constructor.newInstance();</span><br><span class="line">        SingleEnum instance1 = constructor.newInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        System.out.println(instance1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：达到预期</p>
<p><img alt="image-20210203131956843" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203131956843.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203131956843.png"></p>
<h2 id="19、深入理解CAS"><a href="#19、深入理解CAS" class="headerlink" title="19、深入理解CAS"></a>19、深入理解CAS</h2><blockquote>
<p>什么是CAS</p>
</blockquote>
<p>Compare And Swap比较并交换，如果值等于期望值，就更新它。</p>
<p>CAS是CPU的并发原语！！！</p>
<blockquote>
<p>Unsafe类</p>
</blockquote>
<p><img alt="image-20210203140513939" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203140513939.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203140513939.png"></p>
<p>发现全部是native方法，Java不可直接操作内存，C++可以，因此Java调用C++可以操作内存。</p>
<p>以<code>AtomicInteger</code>为例：</p>
<p><img alt="image-20210203140734620" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203140734620.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203140734620.png"></p>
<p>其中的<code>getAndIncrement</code>方法调用Unsafe类的<code>getAndAddInt</code>方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>getAndAddInt</code>方法：自旋锁。</p>
<p><img alt="image-20210203140835738" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203140835738.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203140835738.png"></p>
<p><strong>缺点：</strong></p>
<p>1、循环耗时</p>
<p>2、一次性只能保证一个共享变量的原子性</p>
<p>3、ABA问题</p>
<blockquote>
<p>CAS（ABA问题）</p>
</blockquote>
<p>也就是一个线程调用CAS想改，但是另一个线程可能在此之前先改为一个其他的值又给他改回来了。</p>
<p><img alt="image-20210203142936500" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203142936500.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203142936500.png"></p>
<p><strong>乐观锁&amp;悲观锁：</strong></p>
<ul>
<li><p>悲观锁：但凡修改数据就加锁，，具有强烈的独占和排他特性。主要分以下两类</p>
<ul>
<li>共享锁【shared locks】又称为读锁，简称S锁。共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。、</li>
<li>排他锁【exclusive locks】又称为写锁，简称X锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改。</li>
</ul>
</li>
<li><p>乐观锁：乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。</p>
</li>
</ul>
<p><img alt="image-20210203144850438" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203144850438.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203144850438.png"></p>
<h2 id="20、原子引用-解决ABA问题"><a href="#20、原子引用-解决ABA问题" class="headerlink" title="20、原子引用(解决ABA问题)"></a>20、原子引用(解决ABA问题)</h2><p><strong>对应的思想：乐观锁</strong></p>
<blockquote>
<p>代码测试</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.CAS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference atomicReference= <span class="keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//A线程修改两次</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            System.out.println(<span class="string">"A==&gt;"</span>+atomicReference.getStamp());</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">1</span>,<span class="number">2</span>,atomicReference.getStamp(),atomicReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"A==&gt;"</span>+atomicReference.getStamp());</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">2</span>,<span class="number">1</span>,atomicReference.getStamp(),atomicReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"A==&gt;"</span>+atomicReference.getStamp());</span><br><span class="line">        }).start();</span><br><span class="line">        <span class="comment">//确保B线程和A线程获得最初的版本号</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            <span class="keyword">int</span> version = atomicReference.getStamp();</span><br><span class="line">            System.out.println(<span class="string">"B==&gt;"</span>+version);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">1</span>, <span class="number">3</span>, version, version + <span class="number">1</span>));</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>大坑：</strong></p>
<p>查看comepareAndSet源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span> </span>{</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>传入Integer对象直接用==判断是否相等时有问题！</p>
</blockquote>
<p>测试代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.CAS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Integer x = <span class="number">128</span>;</span><br><span class="line">        Integer y = <span class="number">128</span>;</span><br><span class="line">        System.out.println(x==y);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果为false，原因分析：== 比较的是堆中的地址。</p>
<p>查看<code>Integer</code>中的源码。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>{</span><br><span class="line">       <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">           <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<p>默认IntegerCache.low 是-127，Integer.high是128，如果在这个区间内，他就会把变量i当做一个变量，放到内存中；但如果不在这个范围内，就会去new一个Integer对象。</p>
<p><strong>比较Integer的值这儿说两种方法：</strong></p>
<ul>
<li><p>一个是用equals()比较</p>
</li>
<li><p>一个是用Integer.intValue()转成int</p>
</li>
</ul>
<h2 id="21、各种锁的理解"><a href="#21、各种锁的理解" class="headerlink" title="21、各种锁的理解"></a>21、各种锁的理解</h2><h3 id="1、公平锁、非公平锁"><a href="#1、公平锁、非公平锁" class="headerlink" title="1、公平锁、非公平锁"></a>1、公平锁、非公平锁</h3><p>公平锁：非常公平，不能插队，先来后到</p>
<p>非公平锁：可以插队（默认非公平）</p>
<h3 id="2、可重入锁"><a href="#2、可重入锁" class="headerlink" title="2、可重入锁"></a>2、可重入锁</h3><p>可重入锁（递归锁）：拿到了外面的锁之后就可以拿到里面的锁（自动获得！）</p>
<p>可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。</p>
<blockquote>
<p>Synchronized</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                phone.sms();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            phone.call();</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sms</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        System.out.println(<span class="string">"发短息"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        call();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"打电话"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>ReentrantLock</p>
</blockquote>
<p>使用ReentrantLock调用lock和unlock次数必须相等，否则会死锁。</p>
<h3 id="3、自旋锁"><a href="#3、自旋锁" class="headerlink" title="3、自旋锁"></a>3、自旋锁</h3><p>自旋等待的锁，调用lock和unlock方法是阻塞的！</p>
<h3 id="4、死锁排查"><a href="#4、死锁排查" class="headerlink" title="4、死锁排查"></a>4、死锁排查</h3><blockquote>
<p>工具</p>
</blockquote>
<p>1、使用jps定位进程号<code>jps -l</code></p>
<p>2、使用<code>jstack 进程号</code>查看堆栈信息</p>
<p>排查问题：</p>
<p>1、日志</p>
<p>2、堆栈信息</p>
<blockquote>
<p>测试死锁代码</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.codefriday.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String LockA = <span class="string">"lockA"</span>;</span><br><span class="line">        String LockB = <span class="string">"lockB"</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(LockA,LockB)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(LockB,LockA)).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line">    <span class="keyword">private</span> String LockA;</span><br><span class="line">    <span class="keyword">private</span> String LockB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String lockA, String lockB)</span> </span>{</span><br><span class="line">        LockA = lockA;</span><br><span class="line">        LockB = lockB;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (LockA){</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" get "</span>+LockA);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">synchronized</span> (LockB){</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" get "</span>+LockB);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>堆栈信息排错：</p>
</blockquote>
<p><img alt="image-20210203163557689" class="post-img b-lazy" href="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203163557689.png" data-src="/2021/01/31/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210203163557689.png"></p>

                </div>
            </section>
        </article>
    </div>

    
    <div style="height: 4vw;width: 100%"></div>
    <nav id="gobottom" class="pagination">
        
        <a class="prev-post" title="HTML5" href="/2021/02/03/HTML5/">
            ← HTML5
        </a>
        
        <span class="prev-next-post">•</span>
        
        <a class="next-post" title="JVM学习笔记" href="/2021/01/30/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
            JVM学习笔记 →
        </a>
        
    </nav>

    
    <div class="inner">
        <div id="comment"></div>
    </div>
    
</main>

<div class="toc-bar">
    <div class="toc-btn-bar">
        <a href="#site-main" class="toc-btn">
            <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M793.024 710.272a32 32 0 1 0 45.952-44.544l-310.304-320a32 32 0 0 0-46.4 0.48l-297.696 320a32 32 0 0 0 46.848 43.584l274.752-295.328 286.848 295.808z"></path></svg>
        </a>
        <div class="toc-btn toc-switch">
            <svg class="toc-open" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M779.776 480h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M779.776 672h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M256 288a32 32 0 1 0 0 64 32 32 0 0 0 0-64M392.576 352h387.2a32 32 0 0 0 0-64h-387.2a32 32 0 0 0 0 64M256 480a32 32 0 1 0 0 64 32 32 0 0 0 0-64M256 672a32 32 0 1 0 0 64 32 32 0 0 0 0-64"></path></svg>
            <svg class="toc-close hide" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M512 960c-247.039484 0-448-200.960516-448-448S264.960516 64 512 64 960 264.960516 960 512 759.039484 960 512 960zM512 128.287273c-211.584464 0-383.712727 172.128262-383.712727 383.712727 0 211.551781 172.128262 383.712727 383.712727 383.712727 211.551781 0 383.712727-172.159226 383.712727-383.712727C895.712727 300.415536 723.551781 128.287273 512 128.287273z"></path><path d="M557.05545 513.376159l138.367639-136.864185c12.576374-12.416396 12.672705-32.671738 0.25631-45.248112s-32.704421-12.672705-45.248112-0.25631l-138.560301 137.024163-136.447897-136.864185c-12.512727-12.512727-32.735385-12.576374-45.248112-0.063647-12.512727 12.480043-12.54369 32.735385-0.063647 45.248112l136.255235 136.671523-137.376804 135.904314c-12.576374 12.447359-12.672705 32.671738-0.25631 45.248112 6.271845 6.335493 14.496116 9.504099 22.751351 9.504099 8.12794 0 16.25588-3.103239 22.496761-9.247789l137.567746-136.064292 138.687596 139.136568c6.240882 6.271845 14.432469 9.407768 22.65674 9.407768 8.191587 0 16.352211-3.135923 22.591372-9.34412 12.512727-12.480043 12.54369-32.704421 0.063647-45.248112L557.05545 513.376159z"></path></svg>
        </div>
        <a href="#gobottom" class="toc-btn">
            <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M231.424 346.208a32 32 0 0 0-46.848 43.584l297.696 320a32 32 0 0 0 46.4 0.48l310.304-320a32 32 0 1 0-45.952-44.544l-286.848 295.808-274.752-295.36z"></path></svg>
        </a>
    </div>
    <div class="toc-main">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、什么是JUC"><span class="toc-text">1、什么是JUC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、线程与进程"><span class="toc-text">2、线程与进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、Lock锁"><span class="toc-text">3、Lock锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、生产者-消费者问题"><span class="toc-text">4、生产者/消费者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、八锁现象"><span class="toc-text">5、八锁现象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、集合类不安全"><span class="toc-text">6、集合类不安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、Callable"><span class="toc-text">7、Callable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8、常用的辅助类"><span class="toc-text">8、常用的辅助类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1、CountDownLatch"><span class="toc-text">8.1、CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2、CyclicBarrier"><span class="toc-text">8.2、CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3、Semophore"><span class="toc-text">8.3、Semophore</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9、读写锁"><span class="toc-text">9、读写锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10、阻塞队列BlockingQueue"><span class="toc-text">10、阻塞队列BlockingQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11、线程池"><span class="toc-text">11、线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12、四大函数式接口"><span class="toc-text">12、四大函数式接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13、Stream流式计算"><span class="toc-text">13、Stream流式计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14、ForkJoin"><span class="toc-text">14、ForkJoin</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、-创建Task"><span class="toc-text">一、 创建Task</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、使用ForkJoinPool进行执行"><span class="toc-text">二、使用ForkJoinPool进行执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、RecursiveTask和RecursiveAction区别"><span class="toc-text">三、RecursiveTask和RecursiveAction区别</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#15、异步回调"><span class="toc-text">15、异步回调</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16、JMM"><span class="toc-text">16、JMM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17、Volatile"><span class="toc-text">17、Volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18、单例模式"><span class="toc-text">18、单例模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19、深入理解CAS"><span class="toc-text">19、深入理解CAS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20、原子引用-解决ABA问题"><span class="toc-text">20、原子引用(解决ABA问题)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21、各种锁的理解"><span class="toc-text">21、各种锁的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、公平锁、非公平锁"><span class="toc-text">1、公平锁、非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、可重入锁"><span class="toc-text">2、可重入锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、自旋锁"><span class="toc-text">3、自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、死锁排查"><span class="toc-text">4、死锁排查</span></a></li></ol></li>
    </div>
</div>



	</div>
	


<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
            

<article class="read-next-card" style="background-image: url(https://codefriday.oss-cn-beijing.aliyuncs.com/background.jpg)">
  <header class="read-next-card-header">
    <small class="read-next-card-header-sitetitle">— CodeFriday —</small>
    <h3 class="read-next-card-header-title">Recent Posts</h3>
  </header>
  <div class="read-next-divider">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
      <path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"></path>
    </svg>
  </div>
  <div class="read-next-card-content">
    <ul>
      
      
      
      <li>
        <a href="/2021/02/17/MySQL/">MySQL</a>
      </li>
      
      
      
      <li>
        <a href="/2021/02/09/%E5%89%8D%E7%AB%AF%E5%AE%9E%E6%88%98%EF%BC%8C%E5%B0%8F%E7%B1%B3%E9%97%AA%E8%B4%AD%E5%AE%98%E7%BD%91/">前端实战，小米闪购官网</a>
      </li>
      
      
      
      <li>
        <a href="/2021/02/06/JavaScript/">JavaScript</a>
      </li>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    </ul>
  </div>
  <footer class="read-next-card-footer">
    <a href="/archives">  MORE  → </a>
  </footer>
</article>

            
            
            

<article class="read-next-card" style="background-image: url(https://codefriday.oss-cn-beijing.aliyuncs.com/background.jpg)">
    <header class="read-next-card-header" style="padding-bottom: 20px">
        <h3 class="read-next-card-header-title">Categories</h3>
    </header>
    <div class="read-next-card-content">
        <ul>
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/">实战项目</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/">杂七杂八</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/">第一阶段</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%84%9F%E6%82%9F/">第一阶段感悟</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5/">第三阶段</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/">第二阶段</a></li></ul>
        </ul>
    </div>
</article>


            
            
            

<article class="read-next-card" style="background-image: url(https://codefriday.oss-cn-beijing.aliyuncs.com/background.jpg)">
	<header class="read-next-card-header" style="padding-bottom: 20px">
		<h3 class="read-next-card-header-title">Tag Cloud</h3>
	</header>
	<div class="read-next-card-content-ext">
		<a href="/tags/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/" style="font-size: 24px;">第一阶段</a> <a href="/tags/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E6%84%9F%E6%82%9F/" style="font-size: 19px;">第一阶段感悟</a> <a href="/tags/%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5/" style="font-size: 14px;">第三阶段</a> <a href="/tags/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/" style="font-size: 19px;">第二阶段</a> <a href="/tags/%E7%BC%96%E7%A0%81%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86/" style="font-size: 14px;">编码和字符集</a>
	</div>
</article>

            
        </div>
    </div>
</aside>

	




<div id="search" class="search-overlay subscribe-overlay">
    <div class="search-form">
        
        <img class="search-overlay-logo" src="https://codefriday.oss-cn-beijing.aliyuncs.com/author.jpg" alt="CodeFriday">
        
        <input id="local-search-input" class="search-input" type="text" name="search" placeholder="Search ...">
        <a class="search-overlay-close" href="#"></a>
    </div>
    <div id="local-search-result"></div>
</div>


<footer class="site-footer outer">
	<div class="site-footer-content inner">
		<section class="copyright">
			<a href="/" title="CodeFriday">CodeFriday</a>
			© 2021
		</section>
		<nav class="site-footer-nav">
			
        </nav>
		<span id="busuanzi_container_site_pv">
                本站总访问量<span id="busuanzi_value_site_pv"></span>次
        </span>
        <script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    </div>
	<p align="center">
	<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>

	<script>
		var now = new Date(); 
		function createtime() { 
			var grt= new Date("12/25/2020 00:00:00");//此处建站时间
			now.setTime(now.getTime()+250); 
			days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
			hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
			if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
			mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
			seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
			snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
			document.getElementById("timeDate").innerHTML = "本站已运行 "+dnum+" 天 "; 
			document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
		} 
	setInterval("createtime()",250);
	</script>
	</p>
</footer>
	


<script>
    if(window.navigator && navigator.serviceWorker) {
        navigator.serviceWorker.getRegistrations()
        .then(function(registrations) {
            for(let registration of registrations) {
                registration.unregister();
            }
        });
    }
</script>







<div class="floating-header">
	<div class="floating-header-logo">
        <a href="/" title="CodeFriday">
			
                <img src="https://codefriday.oss-cn-beijing.aliyuncs.com/author.jpg" alt="CodeFriday icon">
			
            <span>CodeFriday</span>
        </a>
    </div>
    <span class="floating-header-divider">—</span>
    <div class="floating-header-title">JUC并发编程</div>
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>






<script src="/js/mix/post-lazy-local.min.js"></script>


<script>;(function() {var bLazy = new Blazy()})();</script>





<script src="/js/lightgallery.min.js"></script>


<link rel="stylesheet" href="/css/lightgallery.min.css">

<script>
    lightGallery(document.getElementById('lightgallery'), {
        selector: '.post-img'
    });
</script>




<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
    new Valine({
        el: '#comment' ,
        verify: false,
        notify: false,
        appId: 'u5Keac77Cgj26AHTOFXr2N32-gzGzoHsz',
        appKey: 'eokpYg7BxMlX9Cs31zsM56A9',
        placeholder: '欢迎留言！',
        pageSize: 10,
        avatar: 'mm',
        visitor: true,
    });
</script>






<script>searchFunc("/")</script>







</body></html>