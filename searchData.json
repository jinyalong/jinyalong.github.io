[{"title":"HashMap和ConcurrentHashMap","url":"/2021/01/02/HashMap和ConcurrentHashMap/","content":"\n## 前言\n\n`JavaSE`基础知识也学了大部分了，发现Java中有一个数据结构有着举足轻重的重用，什么面试必考啊，你必须掌握啊~~~，那就是`HashMap`，完后谈到这玩意，都拿1.7版本JDK和1.8版本JDK版本作比较。大多数学Java的听说过了，1.7嘛底层数据结构数组+链表，1.8多了个红黑树。完后1.7中它是线程不安全的，它查找效率可能会很低，冲突解决策略是简单用链表把冲突的节点串起来，那必然不会有很高效率，`O(n)`查找。因此1.8之后就加了红黑树，就冲突链表长度超过一个阈值，给他把链表转红黑树结构，但他依旧是线程不安全的。红黑树就是一个不是非常严格的平衡二叉树嘛，查找效率`O(logn)`级别。\n\n都是线程不安全，有啥区别：\n\n1.7中采用的是头插法，即插在链表的都节点处，而1.8是尾插法，这所谓头插尾插都是在扩容时的操作。1.7多线程头插法可能会导致出现环形链表。\n\n线程安全的`HashMap`在`java.util.concurrent`包下\n\n以上都是看了很多博客、视频总结得来的东西。完后我自己用的JDK15也去读了读源码，但是感觉还是不够，于是我下载了1.7版本JDK和1.8版本JDK来读一下源码。\n\n![](HashMap和ConcurrentHashMap/1.png)\n\n接下来分四个部分读源码，1.7版本`HashMap`，1.8版本`Hashmap`，1.7版本`ConcurrentHashMap`\n\n,1.8版本`ConcurrentHashMap`。\n\n## JDK1.7版本HashMap\n\n先看一下如何存键值对，列出`static class Entry<K,V> implements Map.Entry<K,V>`属性：\n\n```java\nfinal K key;\nV value;\nEntry<K,V> next;\nint hash;\n```\n\n`next`主要用来串出现冲突的键值对。单向链表处理冲突！\n\n### new-构造一个HashMap对象\n\n借助强大的IDEA来直接导入1.7版本JDK版本\n\n![](HashMap和ConcurrentHashMap/2.png)\n\n直接写`new HashMap;`\n\n```java\npackage hello;\n\nimport java.util.HashMap;\n\npublic class Test {\n    public static void main(String[] args) {\n        HashMap hashMap = new HashMap();\n        hashMap.put(1,\"code\");\n        hashMap.put(2,\"friday\");\n    }\n}\n```\n\n`Ctrl+鼠标左键`直接进到`HashMap`源码，使用快捷键`Alt+7`查看这个类中的一些方法以及属性\n\n![](HashMap和ConcurrentHashMap/3.png)\n\n可以看到有4种构造方法，完后再看看其中的一些属性，直接上源码如下：\n\n```java\n//其实源码中的注释已经解释得很清楚，中文备注一下\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\t//默认初始容量，必须是2的幂次，MUST be a power of two.\n\n    static final int MAXIMUM_CAPACITY = 1 << 30;\n\t//最大容量\n\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\t//默认加载因子，0.75\n\n    static final Entry<?,?>[] EMPTY_TABLE = {};\n\t//用来比较判断table是否为空用的，后面代码会体现！\n\n    transient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;\n\t//存储底层数据结构：数组\n\n    transient int size;\n\t//已经存的key-value数量\n\n    int threshold;\n\t//阈值，容量*加载因子得的，存的键值对超过这个阈值就要进行数组扩容操作\n\n    final float loadFactor;\n\t//加载因子\n\n```\n\n根据我写的代码，我调用了无参构造，查看源码调用方法的过程如下：\n\n```java\n /**\n     * Constructs an empty <tt>HashMap</tt> with the default initial capacity\n     * (16) and the default load factor (0.75).\n     */\n    public HashMap() {\n        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);\n    }\n//就给默认容量16，加载因子0.75，然后调用有参构造\npublic HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)//1.\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)//2.\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))//3.\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n\n        this.loadFactor = loadFactor;\n        threshold = initialCapacity;//此时没有插入键值对，阈值==容量\n        init();//空函数啥也没做\n    }\n```\n\n+ 1.第一个if判断，传入容量值为负数，抛出一个异常\n+ 2.第二个if判断，传入容量超过允许最大容量，就按最大容量来\n+ 3.第三个if判断，加载因子也可以自己给，判断一下是否0-1范围且是一个有效的数，不是就抛出异常\n\n自此可以得到，调用构造函数new一个`HashMap`对象，实际用来存键值对的数组并没有创建。\n\n自此，`new`操作结束，接下来肯定就是往里存键值对，调用的是`put`方法\n\n### put方法\n\n**put执行流程如下：**\n\n+ 判断数组是否已经创建\n+ 判断key是否为空，针对`key==null`插入有一个方法\n+ 计算哈希值并找一个数组下标去存\n+ 先判断key是否已经存在，存在就更新value值，返回旧的value\n+ 不存在就调用`addEntry`插入\n\n```java\npublic V put(K key, V value) {\n    if (table == EMPTY_TABLE) {//判断数组是否为空\n        inflateTable(threshold);\n    }\n    if (key == null)//key为空，调用一个插入key==null的方法，由此可知可以存key为null的键值对\n        return putForNullKey(value);\n    int hash = hash(key);//计算一下key的hash值\n    int i = indexFor(hash, table.length);//根据哈希值取得应该存在数组中那个位置\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n        //遍历一个数组下标对应的链表，如果key已经存在，更新Value并返回旧的Value\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n\n    modCount++;//修改次数+1\n    addEntry(hash, key, value, i);//实际插入键值对的方法\n    return null;\n}\n```\n\n到此，有两处需要拓展！\n\n#### put方法扩展`indexFor`\n\n**注意：看源码时不能看到一个方法中调用了一个方法就马上点进去看，你会发现，可能一直点，点个好几层都没问题，完后回来你就不知道自己是要干嘛了。**\n\n人家写的代码的函数一般都**见名知意**。重要的方法，看完整体点进去验证一下就行~~~\n\n比如这里得去看看`indexFor`做了些啥，这会解释了为什么数组容量必须2的幂次，扩容也必须2倍扩容~\n\n```java\n/**\n     * Returns index for hash code h.\n     */\n    static int indexFor(int h, int length) {\n        // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\";\n        return h & (length-1);\n    }\n```\n\n简单的做了一个按位与运算。正常把元素映射到数组，想到的映射方法肯定是用取余操作模上数组长度，这是一种相对平均的散列算法。实际这个地方本质就是模数组长度，但是必须保证`length`是2的幂次才能达到这个效果。举个例子：\n\n![](HashMap和ConcurrentHashMap/4.png)\n\n数组长度保证2的幂次，就可用按位与代替取模操作，位运算的速度比取模运算快很多很多~，可以用个计数程序测试一下。\n\n#### put方法扩展`addEntry`\n\n```java\n/**传来的参数\n*@hash：key的哈希值\n*key,value即键值对\n*@bucketIndex：键值对需要插入的桶的索引，就是数组索引，数组每一格当作一个桶\n*/\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    if ((size >= threshold) && (null != table[bucketIndex])) {//如果存的键值对已经超过阈值，就需要扩容\n        resize(2 * table.length);//扩容，2倍扩容，后续分析源码\n        hash = (null != key) ? hash(key) : 0;//重新计算一下key的hash值\n        bucketIndex = indexFor(hash, table.length);//根据hash值重新找应该放在数组哪个位置\n    }\n\n    createEntry(hash, key, value, bucketIndex);//实际放入数组的方法\n}\n```\n\n还得点一层`createEntry`，源码如下：\n\n```java\nvoid createEntry(int hash, K key, V value, int bucketIndex) {\n        Entry<K,V> e = table[bucketIndex];//把同中键值对取出来\n        table[bucketIndex] = new Entry<>(hash, key, value, e);//把新键值对加进入，并把e接到后面，这就是头插法！！！\n        size++;//键值对计数器+1\n    }\n```\n\n画个图演示一下——头插法\n\n![](HashMap和ConcurrentHashMap/5.png)\n\n**补充：key==null时默认插入数组下标为0的地方**\n\n### get方法\n\n上源码：\n\n```java\npublic V get(Object key) {\n        if (key == null)//key为null调用对应方法\n            return getForNullKey();\n        Entry<K,V> entry = getEntry(key);//获取整个Entry对象\n\n        return null == entry ? null : entry.getValue();//如果Entry对象为空表示没有这个映射，否则返回value值\n    }\n```\n\n`getEntry`源码如下：\n\n```java\nfinal Entry<K,V> getEntry(Object key) {\n        if (size == 0) {\n            return null;\n        }\n        int hash = (key == null) ? 0 : hash(key);\n        for (Entry<K,V> e = table[indexFor(hash, table.length)];//找到key对应数组中的位置\n             e != null;\n             e = e.next) {//遍历桶，也就是遍历链表\n            Object k;\n            if (e.hash == hash &&\n                ((k = e.key) == key || (key != null && key.equals(k))))\n                return e;//找到key返回Entry对象\n        }\n        return null;//没找到\n    }\n```\n\n相对简单，主要还是因为数组+链表实现`HashMap`数据结构并不复杂。\n\n接下来必须看看扩容操作了！\n\n### resize方法\n\n```java\nvoid resize(int newCapacity) {\n        Entry[] oldTable = table;//拿个指针指向原来的数组\n        int oldCapacity = oldTable.length;//记录一下原来数组大小\n        if (oldCapacity == MAXIMUM_CAPACITY) {//原来容量已经达到最大值\n            threshold = Integer.MAX_VALUE;//把阈值给扩大一下，没办法，数组不允许再扩大了\n            return;//返回\n        }\n\n        Entry[] newTable = new Entry[newCapacity];//新数组，原来的两倍\n        transfer(newTable, initHashSeedAsNeeded(newCapacity));//把老数组数据转移到新数组\n        table = newTable;//更新一下数组\n        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);//更新一下阈值\n    }\n```\n\n重点那肯定是在`transfer`，这也是并发操作导致双向链表的地方！！！源码如下：\n\n```java\nvoid transfer(Entry[] newTable, boolean rehash) {\n        int newCapacity = newTable.length;\n        for (Entry<K,V> e : table) {\n            while(null != e) {\n                Entry<K,V> next = e.next;\n                if (rehash) {//是否需要重新计算hash值\n                    e.hash = null == e.key ? 0 : hash(e.key);\n                }\n                int i = indexFor(e.hash, newCapacity);//重新计算数组下标\n                e.next = newTable[i];\n                newTable[i] = e;\n                e = next;//一样的的头插法重新放进去\n            }\n        }\n    }\n```\n\n### 并发出现环形链表\n\n![](HashMap和ConcurrentHashMap/6.png)\n\n下一次get查找这个桶时，死循环在里面不出来了！\n\n## JDK1.8版本HashMap\n\n进入Project Structure切换JDK版本：\n\n![](HashMap和ConcurrentHashMap/7.png)\n\n### 数据结构和辅助函数改变\n\n点进源码后，存储一个键值对的数据结构如下：\n\n```java\n static class Node<K,V> implements Map.Entry<K,V> {\n        final int hash;\n        final K key;\n        V value;\n        Node<K,V> next;\n }\n//只列出属性\n```\n\n名字都改了，`Entry`改成`Node`，内容倒是没变。既然引入了红黑树，那肯定由红黑树节点对应的数据结构：(只列出属性)\n\n```java\n static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n        TreeNode<K,V> parent;  // red-black tree links\n        TreeNode<K,V> left;\n        TreeNode<K,V> right;\n        TreeNode<K,V> prev;    // needed to unlink next upon deletion\n        boolean red;\n  }\n```\n\n**hash函数也改了：**\n\n```java\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n//1.7版本直接获取key的hashCode，现在把hashcode高位和低位做了一下异或操作，这玩意叫扰动函数\n\n```\n\n**扰动函数作用：**你求于的时候包含了高16位和第16位的特性 也就是说你所计算出来的hash值包含从而使得你的hash值更加不确定 来降低碰撞的概率。\n\n构造函数其实本质和1.7版本还是差不多。有很大不同的地方还是分析put，get，resize方法\n\n### put方法\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n//直接调用了putVal\n```\n\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)//如果数组还未创建\n            n = (tab = resize()).length;\n        if ((p = tab[i = (n - 1) & hash]) == null)//根据hash值找到对应存放的数组下标\n            tab[i] = newNode(hash, key, value, null);//如果该位置空，直接新建一个链表节点\n        else {//否则就遍历一下链表，看key是否有重复\n            Node<K,V> e; K k;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            else if (p instanceof TreeNode)//如果已经树化，调用红黑树的插入方法\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {//链表的插入方法\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);//链表长度超过阈值，树化\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // key已经存在，覆盖value并返回原来的\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)\n            resize();//判断一下是否需要扩容+\n    \n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n`putVal`插入流程：\n\n+ 判断数组是否已经创建\n+ 根据hash值找到对应存放的数组下标\n+ 分三种情况\n  + 该位置为空\n  + 红黑树的插入\n  + 链表的插入\n+ 插入如果是覆盖就返回旧值\n+ 判断一下是否达到阈值，然后扩容一下\n\n### get方法\n\n```java\npublic V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n//调用了getNode方法\n```\n\n```java\nfinal Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {//先判断表不为空，并根据hash索引到数组下标不为空\n            if (first.hash == hash && // always check first node先检查第一个\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;\n            if ((e = first.next) != null) {\n                if (first instanceof TreeNode)//红黑树的查找方法\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                do {//否则就是链表的查找方法\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;//找不到返回null\n    }\n```\n\n执行流程也相对简单，分红黑树和链表的查找方法，重点在扩容（注：我只分析了链表，为了对比1.7版本）\n\n### resize方法\n\n源码挺长：\n\n```java\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;//保存一下原来的表，不再需要传容量大小的参数，区别于1.7\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;//获取原来的容量\n        int oldThr = threshold;//原来的阈值\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            if (oldCap >= MAXIMUM_CAPACITY) {//如果容量已经超过最大容量\n                threshold = Integer.MAX_VALUE;//只能扩大阈值\n                return oldTab;\n            }\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                //扩大两倍容量并判断是否小于允许的最大容量，原来的容量是否大于等于16\n                newThr = oldThr << 1; // double threshold，都满足就扩大阈值，阈值在new的时候没传参数其实就给了默认\n        }\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        else {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n   \t\t//上面主要是更新容量值和阈值的值\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];//创建新表\n        table = newTab;\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {//遍历旧表，准备数据迁移\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;//如果旧桶中只有一个元素\n                    else if (e instanceof TreeNode)//如果是红黑树节点\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order//链表，保留原来的顺序，也就是尾插法\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n```\n\n重点分析链表数据迁移的过程，定义了四个链表节点\n\n```java\nNode<K,V> loHead = null, loTail = null;\nNode<K,V> hiHead = null, hiTail = null;\n```\n\n其实数据迁移过程，无非是把原来链表拆分成两个链表（不考虑红黑树），而且两个链表中的数据根据哈希值和`oldlength-1`求与之后得到的数组索引一定满足以下关系：\n\n`OldIndex == OldIndex 或 OldIndex+oldlength`\n\n分出去到更高索引的其实就是多看一个二进制位，比如原来容量是8，现在看看第4位（从低到高从1开始计），如果是1那就分到更高索引的数组去。因此定义了一个`loHead`和`hiHead`两个链表。接下来模拟操作以一下\n\ndo-while循环完之后：\n\n![](HashMap和ConcurrentHashMap/8.png)\n\n接下来两个if判断：就是把链表放到新数组中去：\n\n```java\nif (loTail != null) {\n\tloTail.next = null;\n\tnewTab[j] = loHead;\n}\nif (hiTail != null) {\n\thiTail.next = null;\n\tnewTab[j + oldCap] = hiHead;\n}\n```\n\n### 并发操作出现的问题\n\n没有任何同步机制，多线程肯定会出现关键节点线程抢占，比如其中`size`表示键值对的数目，其他线程可能对`size`的副本做出修改还未更新本来的值，那必然会出现多个线程数据覆盖的问题。实际就会出现，并发插入键值对，实际插入数量！=size，这只是一个不严谨的举例，实际自己写个测试程序运行就会抛出并发操作异常。\n\n## JDK1.7版本ConcurrentHashMap\n\n由于目前只有只学习了操作系统导论中的并发，讲的也是C/C++下的，还未学习Java中并发的一些实现进制。只能浅显分析一波~~~\n\n出错以后来改，或者欢迎评论区纠正\n\n首先这是它的结构图：\n\n![](HashMap和ConcurrentHashMap/9.png)\n\n为了实现互斥的话，最简单的思路就是只允许一个线程操作哈希表，也就是价格锁，但这样自己用`HashMap`写好同步代码块就完事了，这东西也就没存在的意义，而且并不是所有线程并发操作哈希表都是会导致出错的，因此可以考虑把哈希表分成很多段，每个段保证只能一个线程进去操作，那就可以实现真正意义上的并发操作哈希表，JDK1.7中就是利用了分段锁的机制实现互斥。\n\n### 核心属性以及数据结构\n\n新增的属性：\n\n```java\nstatic final int DEFAULT_CONCURRENCY_LEVEL = 16;\n//默认并发级别，也就是允许多少个线程同时操作\n\nstatic final int MIN_SEGMENT_TABLE_CAPACITY = 2;\n//每个段下默认hash表的长度\n\nstatic final int MAX_SEGMENTS = 1 << 16; // slightly conservative\n//允许最大的段数量\n\n```\n\n数据结构：\n\n```java\nfinal Segment<K,V>[] segments;\n\ntransient Set<K> keySet;\ntransient Set<Map.Entry<K,V>> entrySet;\ntransient Collection<V> values;\n```\n\n查看`Segment`类定义：\n\n```java\nstatic final class Segment<K,V> extends ReentrantLock implements Serializable \n```\n\n实现了`ReentrantLock`，其实就是一种锁的类型。jdk中独占锁的实现除了使用关键字`synchronized`外,还可以使用`ReentrantLock。`\n\n上面的东西暂时没学到。\n\n本质和`HashMap`没多大区别，只不过用到了`volatile `关键字等实现同步互斥。\n\n原理上来说：`ConcurrentHashMap` 采用了分段锁技术，其中` Segment `继承于` ReentrantLock`。不会像` HashTable `那样不管是` put `还是 `get `操作都需要做同步处理，理论上` ConcurrentHashMap `支持` CurrencyLevel` (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个` Segmen`t 时，不会影响到其他的 `Segment`。\n\n\n\n1.7版本解决并发问题之后，但是数组+链表的实现还是会导致查询效率低。\n\n## JDK1.8版本ConcurrentHashMap\n\n在JDK1.8版本丢弃了分段锁。\n\n采用了 `CAS + synchronized` 来保证并发安全性。\n\n`CAS`全称`CompareAndSwap`，在操作系统导论中这是操作系统中硬件提供的功能强大的原子操作，来实现锁机制用的。\n\n此处我觉得是差不多的思想，实际上这个操作似乎也是C++写的，调用了C++写的包，因为Java不能去搞底处的内存管理。\n\n## 总结\n\n1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（`O(logn)`），甚至取消了` ReentrantLock `改为了 `synchronized`，这样可以看出在新版的` JDK` 中对 `synchronized `优化是很到位的。","tags":["第一阶段感悟"],"categories":["第一阶段感悟"]},{"title":"IO","url":"/2021/01/02/IO/"},{"title":"编码和字符集","url":"/2021/01/01/编码和字符集/","content":"\n## ASCII码\n\n世界上只有两种人——一种会二进制，一种不会二进制~~~\n在初学C++时，接触最多的编码就是ASCII码了，全称((American Standard Code for Information Interchange): 美国信息交换标准代码），是老外发明的，老外用的，主要用于显示现代英语和其他西欧语言。\n\n然后C++中的char变量使用的就是ASCII码。用`sizeof（char）`将会得到`1`，C++中一个char类型占用一个字节的内存。一字节=8个二进制位。而ASCII码实际只需要7位就可编码，`2^7=128`，而在标准ASCII中，其最高位(b7)用作奇偶校验位。所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验和偶校验两种。奇校验规定：正确的代码一个字节中1的个数必须是奇数，若非奇数，则在最高位b7添1；偶校验规定：正确的代码一个字节中1的个数必须是偶数，若非偶数，则在最高位b7添1。\n\n**由此引出问题：**\n\n都有哪些字符集和编码规则，以及中文怎么输出的，C语言中用char数组是可以正常保存并输出中文的，但似乎有的字会乱码~\n\n## 字符集&编码\n\n### 编码\n\n在显示器上看见的文字、图片等信息在电脑里面其实并不是我们看见的样子，即使你知道所有信息都存储在硬盘里，把它拆开也看不见里面有任何东西，只有些盘片。假设，你用显微镜把盘片放大，会看见盘片表面凹凸不平，凸起的地方被磁化，凹的地方是没有被磁化；凸起的地方代表数字1，凹的地方代表数字0。硬盘只能用0和1来表示所有文字、图片等信息。\n\n因此需要制定一系列大家共同认可和使用的编码规则来把01的组合表示成有意义的信息。而上面Ascii码就是一种规则，比如用二进制`0100 0001`表示字母`A`，那么信息交换的时候按照编码规则解码就得到了信息本来的意义。\n\n### 字符集\n\n是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。\n\n## 常用的字符集和字符编码\n\n常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等。\n\n### ASCII字符集&编码\n\n图片来自百度百科：\n\n![](编码和字符集/1.png)\n\n老外为了表示更多的欧洲常用字符对ASCII进行了扩展，不要在高位当校验位了，ASCII扩展字符集使用8位（bits）表示一个字符，共256字符。ASCII字符集映射到数字编码规则如下图所示：\n\n![](编码和字符集/2.png)\n\n然而中文都不能表示！！！然后来了GBXXXX字符集&编码\n\n### GB2312字符集&编码\n\n计算机是老外发明的嘛，发明之后很长一段时间只是应用于美国及西方一些发达国家，ASCII完全满足他们。\n\n但是现在基本家家户户都有计算机，因此必须设计一套编码规则显示中文。于是专家们把ASCII码127号之后东西取消掉，规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。而连用两个字符表示一个的符号叫\"全角\"字符，而原来在127号以下的那些就叫\"半角\"字符了。\n\nC/C++程序运行时那个黑框输入东西时会提示！\n\n上述编码规则就是**GB2312**。\n\n这也解决了我的一个疑问，以前只是听老师说两个字符表示一个汉字，他是怎么知道什么时候是两个字符连起来表示呢~~~\n\n### BIG5字符集&编码\n\n**Big5**，又称为**大五码**或**五大码**，是使用繁体中文（正体中文）社区中最常用的电脑汉字字符集)标准，共收录13,060个汉字。中文码分为内码及交换码两类，Big5属中文内码，知名的中文交换码有CCCII、CNS11643。Big5虽普及于台湾、香港与[澳门等繁体中文通行区，但长期以来并非当地的国家标准，而只是业界标准。倚天中文系统、Windows等主要系统的字符集都是以Big5为基准，但厂商又各自增加不同的造字与造字区，派生成多种不同版本。2003年，Big5被收录到CNS11643中文标准交换码的附录当中，取得了较正式的地位。这个最新版本被称为Big5-2003。\n\n## 过度\n\n每个计算机应用广泛的国家都会去制定一套自己的规则，因此肯定会出现一种可能不能做到统一，而现在是互联网时代，~~相信大家都不止会上国内的网站~~，懂的都懂，于是一个伟大的创想出现了，Unicode，顾名思义它是一种统一编码的意思，**统一码**、**万国码**、**单一码**、**标准万国码**。\n\n## Unicode\n\n在计算机科学领域中，**Unicode**（**统一码**、**万国码**、**单一码**、**标准万国码**）是业界的一种标准，它可以使电脑得以体现世界上数十种文字的系统。Unicode 是基于通用字符集（Universal Character Set）的标准来发展，并且同时也以书本的形式对外发表。Unicode 还不断在扩增， 每个新版本插入更多新的字符。直至目前为止的第六版，Unicode 就已经包含了超过十万个字符（在2005年，Unicode 的第十万个字符被采纳且认可成为标准之一）、一组可用以作为视觉参考的代码图表、一套编码方法与一组标准字符编码、一套包含了上标字、下标字等字符特性的枚举等。Unicode 组织（The Unicode Consortium）**是由一个非营利性的机构所运作**，并主导 Unicode 的后续发展，其目标在于：将既有的字符编码方案以Unicode 编码方案来加以取代，特别是既有的方案在多语环境下，皆仅有有限的空间以及不兼容的问题。\n\nUnicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。目前的Unicode字符分为17组编排，0x0000至0x10FFFF，每组称为平面（Plane），而每平面拥有65536个码位，共1114112个。然而目前只用了少数平面。UTF-8、UTF-16、UTF-32都是将数字转换到程序数据的编码方案。\n\n（**可以这样理解：Unicode是字符集，UTF-32/ UTF-16/ UTF-8是三种字符编码方案。**）\n\n### UTF-8\n\nUTF-8以字节为单位对Unicode进行编码。从Unicode到UTF-8的编码方式如下：\n\n| **Unicode编码(十六进制)** | **UTF-8 字节流(二进制)**            |\n| :------------------------ | :---------------------------------- |\n| 000000-00007F             | 0xxxxxxx                            |\n| 000080-0007FF             | 110xxxxx 10xxxxxx                   |\n| 000800-00FFFF             | 1110xxxx 10xxxxxx 10xxxxxx          |\n| 010000-10FFFF             | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |\n\nUTF-8的特点是对不同范围的字符使用不同长度的编码。对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同。UTF-8编码的最大长度是4个字节。从上表可以看出，4字节模板有21个x，即可以容纳21位二进制数字。Unicode的最大码位0x10FFFF也只有21位。\n\n例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。\n\n例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用4字节模板：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。\n\n### UTF-16\n\nUTF-16编码以16位无符号整数为单位。我们把Unicode编码记作U。编码规则如下：\n\n如果U<0x10000，则U的UTF-16编码就是U对应的16位无符号整数（为书写简便，下文将16位无符号整数记作WORD）。\n\n如果U≥0x10000，我们先计算U'=U-0x10000，然后将U'写成二进制形式：yyyy yyyy yyxx xxxx xxxx，U的UTF-16编码（二进制）就是：110110yyyyyyyyyy 110111xxxxxxxxxx。\n\n为什么U'可以被写成20个二进制位？Unicode的最大码位是0x10FFFF，减去0x10000后，U'的最大值是0xFFFFF，所以肯定可以用20个二进制位表示。例如：Unicode编码0x20C30，减去0x10000后，得到0x10C30，写成二进制是：0001 0000 1100 0011 0000。用前10位依次替代模板中的y，用后10位依次替代模板中的x，就得到：1101100001000011 1101110000110000，即0xD843 0xDC30。\n\n按照上述规则，Unicode编码0x10000-0x10FFFF的UTF-16编码有两个WORD，第一个WORD的高6位是110110，第二个WORD的高6位是110111。可见，第一个WORD的取值范围（二进制）是11011000 00000000到11011011 11111111，即0xD800-0xDBFF。第二个WORD的取值范围（二进制）是11011100 00000000到11011111 11111111，即0xDC00-0xDFFF。\n\n为了将一个WORD的UTF-16编码与两个WORD的UTF-16编码区分开来，Unicode编码的设计者将0xD800-0xDFFF保留下来，并称为代理区（Surrogate）：\n\n| D800－DB7F | High Surrogates             | 高位替代     |\n| ---------- | --------------------------- | ------------ |\n| DB80－DBFF | High Private Use Surrogates | 高位专用替代 |\n| DC00－DFFF | Low Surrogates              | 低位替代     |\n\n高位替代就是指这个范围的码位是两个WORD的UTF-16编码的第一个WORD。低位替代就是指这个范围的码位是两个WORD的UTF-16编码的第二个WORD。那么，高位专用替代是什么意思？我们来解答这个问题，顺便看看怎么由UTF-16编码推导Unicode编码。\n\n如果一个字符的UTF-16编码的第一个WORD在0xDB80到0xDBFF之间，那么它的Unicode编码在什么范围内？我们知道第二个WORD的取值范围是0xDC00-0xDFFF，所以这个字符的UTF-16编码范围应该是0xDB80 0xDC00到0xDBFF 0xDFFF。我们将这个范围写成二进制：\n\n1101101110000000 11011100 00000000 - 1101101111111111 1101111111111111\n\n按照编码的相反步骤，取出高低WORD的后10位，并拼在一起，得到1110 0000 0000 0000 0000 - 1111 1111 1111 1111 1111即0xe0000-0xfffff，按照编码的相反步骤再加上0x10000，得到0xf0000-0x10ffff。这就是UTF-16编码的第一个WORD在0xdb80到0xdbff之间的Unicode编码范围，即平面15和平面16。因为Unicode标准将平面15和平面16都作为专用区，所以0xDB80到0xDBFF之间的保留码位被称作高位专用替代。\n\n### UTF-32\n\nUTF-32编码以32位无符号整数为单位。Unicode的UTF-32编码就是其对应的32位无符号整数。\n\n### 字节序\n\n字节序有两种，分别是“大端”（Big Endian, BE）和“小端”（Little Endian, LE）。\n\n根据字节序的不同，UTF-16可被实现为UTF-16LE或UTF-16BE，UTF-32可被实现为UTF-32LE或UTF-32BE。例如：\n\n| **Unicode编码** | **UTF-16LE** | **UTF-16BE** | **UTF32-LE** | **UTF32-BE** |\n| --------------- | ------------ | ------------ | ------------ | ------------ |\n| 0x006C49        | 49 6C        | 6C 49        | 49 6C 00 00  | 00 00 6C 49  |\n| 0x020C30        | 30 DC 43 D8  | D8 43 DC 30  | 30 0C 02 00  | 00 02 0C 30  |\n\nUnicode标准建议用BOM（Byte Order Mark）来区分字节序，即在传输字节流前，先传输被作为BOM的字符“零宽无中断空格”。这个字符的编码是FEFF，而反过来的FFFE（UTF-16）和FFFE0000（UTF-32）在Unicode中都是未定义的码位，不应该出现于实际传输中。\n\n下表是各种UTF编码的BOM：\n\n| **UTF编码**       | **Byte Order Mark (BOM)** |\n| ----------------- | ------------------------- |\n| UTF-8 without BOM | 无                        |\n| UTF-8 with BOM    | EF BB BF                  |\n| UTF-16LE          | FF FE                     |\n| UTF-16BE          | FE FF                     |\n| UTF-32LE          | FF FE 00 00               |\n| UTF-32BE          | 00 00 FE FF               |\n\n## 总结\n\n用的最多的就是UTF-8","tags":["编码和字符集"],"categories":["杂七杂八"]},{"title":"关于HashMap","url":"/2020/12/30/关于HashMap/","content":"\n## HashMap容量\n\n以下是来自JDK15源代码中的定义：\n\n```java\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable\n```\n\n在集合框架中，把`Map`接口实现并继承了`AbstractMap`，所以是一个类\n\n继续往下读这个类，第一个属性定义源码如下：\n\n```java\n /**\n     * The default initial capacity - MUST be a power of two.\n     */\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n/**\n     * The maximum capacity, used if a higher value is implicitly specified\n     * by either of the constructors with arguments.\n     * MUST be a power of two <= 1<<30.\n     */\n    static final int MAXIMUM_CAPACITY = 1 << 30;\n//最大容量为2^31;原因如下，size都只是定义为int型\n/**\n     * The number of key-value mappings contained in this map.\n     */\n    transient int size;\n```\n\n默认初始化容量为16，而且必须初始化为2的n次幂，此处我试了一下，并不是指实例化时必须传一个2次幂整数作为参数。传入初始化容量后，它实际会调用一个修正函数：\n\n```java\n    /**\n     * Returns a power of two size for the given target capacity.\n     */\n    static final int tableSizeFor(int cap) {\n        int n = -1 >>> Integer.numberOfLeadingZeros(cap - 1);\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n个人解读：\nn = -1 对应二进制1111 1111 1111 1111\n    \nnumberOfLeadingZeros方法给定一个int类型数据，返回这个数据的二进制串中从最左边算起连续的“0”的总数量。\n    \n也就是找到遇到第一个1，左边（高位）有多少1，比如9的二进制1001，32位int表示的话，高28位都为0\n    \n>>>表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0\n    \n然后n得到的应该是一个大于等于n的数。\n    \n理由：\n    1.如果cap是2的次幂，如2^x次幂，那么2^x-1应该是x个1（最低位），那么实际n逻辑右移后得到的就是2^x-1\n    比如给16 ： \t\t\t\t\t0000 0000 0001 0000\n    减1得到：   \t\t\t\t\t0000 0000 0000 1111\n    调用numberOfLeadingZeros得到 ：\t28\n    完后：-1 >>> 28得到 \t\t\t\t0000 0000 0000 1111\n    \n    2.如果不是2的次幂，那么得到的就是大于cap的最小的2次幂\n\nreturn语句两个 ？ ： 运算符\n第一个判断n和0的关系，如果n小于0，那么就返回1，否则还得比较一下有没有超过允许的1最大容量，不超过返回n+1\n```\n\n通过高效位运算就完成了容量修正。但是好像并不能直接通过方法返回容量。\n\n查看`HashMap`有参构造函数:\n\n```java\n/* ---------------- Public operations -------------- */\n\n    /**\n     * Constructs an empty {@code HashMap} with the specified initial\n     * capacity and load factor.\n     *\n     * @param  initialCapacity the initial capacity\n     * @param  loadFactor      the load factor\n     * @throws IllegalArgumentException if the initial capacity is negative\n     *         or the load factor is nonpositive\n     */\n    public HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        this.threshold = tableSizeFor(initialCapacity);\n    }\n```\n\n`threshold`字段存容量~~~，没方法直接获取这个指。\n\n突然想起看过反射了，还没用过。试一试！！！\n\n走起~\n\n```java\npublic class Main {\n    public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException, NoSuchFieldException {\n\n        HashMap<String,Integer> hm = new HashMap<String,Integer>(10);\n        //实例的getClass方法获取Class\n        Class<?> myhash = hm.getClass();\n        //获取指定属性，也可以调用getDeclaredFields()方法获取属性数组\n        Field threshold =  myhash.getDeclaredField(\"threshold\");\n        //将目标属性设置为可以访问\n        threshold.setAccessible(true);\n        System.out.println(threshold.get(hm));\n    }\n}\n```\n\n传参初始化容量为10，不出意外应该输出16\n\n![](关于HashMap/1.png)\n\n有警告，说是JDK版本太高~~~，但却是输出了16。\n\n## put方法\n\n**index = HashCode（Key） & （Length - 1）** \n\n可以说，Hash算法最终得到的index结果，完全取决于Key的Hashcode值的最后几位。\n\n如果Length - 1不是全1的二进制，映射方法不平均，好像根据什么泊松分布得出的结论。\n\n显然不符合Hash算法均匀分布的原则。","tags":["第一阶段感悟"],"categories":["第一阶段感悟"]},{"title":"集合框架","url":"/2020/12/29/集合框架/","content":"\n## 前言\n\nJava语言本身和C语言区别不大，所以很快建立了面向对象的思想后，有语法基础的支持，了解了泛型、注解、反射等概念后。可以开始学习Java强大的数据结构了——集合框架。\n\n集合框架被设计成要满足以下几个目标。\n\n- 该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。\n- 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。\n- 对一个集合的扩展和适应必须是简单的。\n\n## 框架图\n\n来自网络资源\n\n![](集合框架/集合框架.gif)\n\n## 接口&实现（类）&算法\n\n+ **接口：**\n\n  上图中虚线框均是接口，代表集合的抽象数据类型，之所以定义多个接口，是为了以不同的方式操作集合对象。\n\n+ **实现（类）：**\n\n  是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。\n\n+ **算法：**\n\n  实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。\n\n## 直接剖析JDK源码理解集合框架\n\n### 展开Collection\n\n在IDEA中打出关键字`Collection`——按住`Ctrl`点击进入`Collection`源代码——使用`Ctrl+H`快捷键即可查看集合继承关系如图：\n\n![](集合框架/1.png)\n\n首先可以观察到`Collection`本身就是一个接口并且这些东西都有锁，不可更改\n\n+ ```\n  SynchronizedCollection in Collections\n  ```\n\n  具体实现类，与线程安全有关。\n\n+ ```\n  ValuesView in ConcurrentHashMap\n  ```\n\n  具体实现类，与锁，线程安全有关。\n\n+ ```\n  BeanContext\n  ```\n\n  提供与 bean 上下文有关的类和接口，暂时不懂~\n\n+ ```\n  List\n  ```\n\n  一个接口，源码：\n\n  ```java\n  定义：public interface List<E> extends Collection<E>\n      泛型，单继承自Collection\n  ```\n\n  源码1068行，完后只是定义了41种方法，其中一种是重写了父接口的~自己数的不知道准不\n\n  接口只定义方法，不能带具体实现，因此大部分是函数的文档注释。\n\n+ ```\n  AbstractCollection\n  ```\n\n  实现了大部分的集合接口\n\n  最简单的一个`isEmpty()`的实现源码带文档注释如下：\n\n  ```java\n  /**\n       * {@inheritDoc}\n       *\n       * @implSpec\n       * This implementation returns {@code size() == 0}.\n       */\n      public boolean isEmpty() {\n          return size() == 0;\n      }\n  //直接调用size方法的返回值判断\n  ```\n\n+ ```\n  CollectionView\n  ```\n\n  源码中定义如下：\n\n  ```java\n  abstract static class CollectionView<K,V,E>\n          implements Collection<E>, java.io.Serializable\n  ```\n\n  暂时不知道干嘛用的\n\n+ ```\n  CheckedCollection\n  ```\n\n  也不懂干嘛用的\n\n+ ```\n  Set\n  ```\n\n  一个接口，继承至`Collection`\n\n  源码中定义如下：\n\n  ```java\n  public interface Set<E> extends Collection<E>\n  ```\n\n  和`List`一样就定义了一堆方法.\n\n+ ```\n  UnmodifiableCollection\n  ```\n\n  ???\n\n+ ```\n  Queue\n  源码中的定义\n  public interface Queue<E> extends Collection<E>\n  ```\n\n  定义一堆方法。\n\n  \n\n**主要关注接口部分继续展开`List`、`Set`、`Queue`**\n\n#### 展开List\n\n `List`第一条分支实现了`Vector`->`Stack`\n\n![](集合框架/3.png)\n\n`Vector`源码中定义如下：\n\n```java\npublic class Vector<E>\n    extends AbstractList<E>\n    implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n//继承AbstractList类，并实现List接口\n```\n\n`Stack`中源码定义如下：\n\n```java\npublic class Stack<E> extends Vector<E>\n//继承一个实体类，Vector基础新增一些方法\n//如：\n /**\n     * Pushes an item onto the top of this stack. This has exactly\n     * the same effect as:\n     * <blockquote><pre>\n     * addElement(item)</pre></blockquote>\n     *\n     * @param   item   the item to be pushed onto this stack.\n     * @return  the {@code item} argument.\n     * @see     java.util.Vector#addElement\n     */\n    public E push(E item) {\n        addElement(item);\n\n        return item;\n    }\n```\n\n`ArrayList`也是直接实现了List接口\n\n```java\n//源码定义如下：\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n//先继承了AbstractList然后实现List接口\n```\n\n`LinkedList`\n\n```java\n\npublic class LinkedList<E>\n    extends AbstractSequentialList<E>\n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n    //实现了List和Deque接口\n```\n\n#### 展开Queue\n\n![](集合框架/5.png)\n\n```java\npublic interface BlockingQueue<E> extends Queue<E> \n```\n\n```\npublic interface Deque<E> extends Queue<E>\n```\n\n`Deque`接口被`LinkedList`和`ArrayDeque`实现，定义源码如下：\n\n```java\npublic class LinkedList<E>\n    extends AbstractSequentialList<E>\n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n    \npublic class ArrayDeque<E> extends AbstractCollection<E>\n                           implements Deque<E>, Cloneable, Serializable\n```\n\n阻塞队列接口`BlockingQueue`继承自Queue接口，然后`BlockingDeque`继承`BlockingQueue`和`Deque`\n\n```java\npublic interface BlockingQueue<E> extends Queue<E> \n    \npublic interface BlockingDeque<E> extends BlockingQueue<E>, Deque<E> \n```\n\n#### 展开set\n\n源码中的重要定义\n\n![](集合框架/6.png)\n\n```java\npublic class HashSet<E>\n    extends AbstractSet<E>\n    implements Set<E>, Cloneable, java.io.Serializable\n \n public class LinkedHashSet<E>\n    extends HashSet<E>\n    implements Set<E>, Cloneable, java.io.Serializable\n```\n\n然后`AbstractSet`下生成很多种`Set`已经开始有点懵~\n\n大致框架最重要的部分应该是`Collection`下生成的一些的抽象类，即实现了接口中大部分方法的类\n\n![](集合框架/7.png)\n\n然后大致理出`Collection`这条线生成的直接用的，并且用的多的数据结构如图，不全~~~\n\n![](集合框架/8.png)\n\n### 展开Map\n\n![](集合框架/9.png)\n\n大致关系如下：(红色表示接口，绿色表示可用的实现类)\n\n![](集合框架/10.png)\n\n## 总结\n\n集合可以看作是一种容器，用来存储对象信息。所有集合类都位于java.util包下，但支持多线程的集合类位于java.util.concurrent包下。","tags":["第一阶段感悟"],"categories":["第一阶段感悟"]},{"title":"Java面向对象总结","url":"/2020/12/29/Java面向对象总结/","content":"\n## Java面向对象三大特性脑图\n\n![](Java面向对象总结/OOP总结.jpg)\n\n## instanceof关键字\n\n`X instance of Y`\n\n+ 编译通过的条件\n\n  X是Y的子类，X和Y的类型应该去看定义的左边，而不是new的右边所指向的东西\n\n+ 比较结果\n\n  X指向的类（看右边引用）是Y的子类\n\n**类型之间的转换**\n\n```java\n父类 -------> 子类\n高类 -------> 低类\n    必须使用强制类型装换\n  \n子类 -------> 父类\n低 -------> 高\n    不需要强制类型转换，但是会丢失子类的方法\n```\n\n## static关键字\n\n### 修饰变量\n\n静态的：可以直接通过`类名.变量名`格式直接访问，无论实例化多少对象，都只有一个！\n\n//多线程\n\n非静态的：必须先实例化类，才能使用\n\n### 修饰方法\n\n静态的：可直接调用（类加载时就加载了static修饰的）\n\n非静态的：必须先实例化类，才能通过实例的对象使用\n\n### 修饰代码块\n\n```java\n静态代码块\nstatic{} —— 最先执行，只执行一次，第一次加载类时执行\n匿名代码块：\n{} \t-- 先于构造器之前执行\n```\n\n## 抽象类\n\n**本质还是类！！！**\n\n抽象（封装继承多态）的抽象\n\n抽象类是一种约束~~\n\n### 特点\n\n1.不能new这个抽线类，只能有子类实现\n\n2.抽线类可以写普通方法\n\n3.抽象方法必须存在于抽象类中\n\n**4.存在构造器**\n\n## 接口\n\n**递进关系：**\n\n普通类：只有具体实现\n\n抽象类：具体实现，规范（抽象方法）都可以有\n\n**接口：只有规范**\n\n声明类的关键字：`class`\n\n声明接口的关键字：`interface `（本质就不是类了）\n\n### 特点\n\n其中定义一个方法默认有的修饰符：`public abstract`\n\n定义变量默认有的修饰符：`public static final`\n\n`implements`关键字实现，可多继承，侧面实现了多继承！！！\n\n继承时必须重写接口中所有方法\n\n## 扩展概念——内部类\n\n一个类的内部去定义一个新的类\n\n### 1.成员内部类\n\n类作为类的成员之一\n\n内部类可以获得外部类的私有属性（通过方法）\n\n内部类实例化方法：先实例化外部类，再使用外部类来实例化内部类\n\n### 2.静态内部类\n\nstatic修饰之后就不能用外部类私有属性了\n\n原因：static最先加载，都还不知道私有属性是啥！！！\n\n### 3.一个java类\n\n可以有多个`class`类但只能有一个`public class`类\n\n### 4.局部内部类\n\n方法中定义类\n\n### 5.匿名内部类\n\n接口也可new但是必须重写方法\n\n","tags":["第一阶段感悟"],"categories":["第一阶段感悟"]},{"title":"Git","url":"/2020/12/28/Git/","content":"\n## Git简介\n\n**Git是一个分布式版本管理控制系统**\n\nLinus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。世界各地的人为Linux编写代码，而在2002年以前都是由Linus本人通过手工方式合并代码！\n\n代码库过大，手工管理难度大，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper授权Linux社区免费使用这个版本控制系统。开发Samba的Andrew试图破解BitKeeper的协议，被BitMover公司发现了，于是BitMover公司怒了，要收回Linux社区的免费使用权。\n\n\n\n然后Linus自己用C语言花了两周自己写了一个分布式版本控制系统，这就是Git！\n\n~~太强了！！！\n\n![](Git/3.png)\n\n### 安装Git\n\n最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。\n\nWindows安装git\n\n![](Git/1.png)\n\n下载后右键菜单多出两个东西。\n\n`Git Bush Here`就是命令行使用`git`\n\n### 创建版本库\n\n使用命令`$ git init`把当前目录变成Git可以管理的版本库，目录多出一个`.git`文件夹\n\n![](Git/2.png)\n\n这个目录是Git来跟踪管理版本库的\n\n**把文件添加到版本库**\n\n所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等。\n\n而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。\n\nMicrosoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的。\n\n如果要真正使用版本控制系统，就要以纯文本方式编写文件。\n\n因为文本是有编码的，使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。\n\n千万不要使用Windows自带的**记事本**编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符！！！\n\n第一步，用命令`git add`告诉Git，把文件添加到仓库\n\n第二步，用命令`git commit`告诉Git，把文件提交到仓库\n\n![](Git/4.png)\n\n`git commit`命令，`-m`后面输入的是本次提交的说明\n\n## 基础使用\n\n现在更改readme.md文件内容为\n\n```\nA test：change the file\n```\n\n使用`$git status`指令查看仓库状态，会显示readme.txt被修改过，但是未提交\n\n然后使用`$git diff`指令可以查看修改了什么内容：\n\n![](Git/5.png)\n\n`git diff`顾名思义就是查看difference，显示的格式正是Unix通用的diff格式","tags":["Git","代码管理工具","分布式"],"categories":["Git"]},{"title":"注解","url":"/2020/12/28/注解/","content":"\n## 什么是注解\n\n注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”，如`@Override`\n\n**注释和注解的区别：**\n\n注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。\n\n## 注解的作用\n\n**从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。**\n\nJava的注解可以分为三类：\n\n第一类是由编译器使用的注解，例如：\n\n- `@Override`：让编译器检查该方法是否正确地实现了覆写；\n- `@SuppressWarnings`：告诉编译器忽略此处代码产生的警告。\n\n这类注解不会被编译进入`.class`文件，它们在编译后就被编译器扔掉了。\n\n第二类是由工具处理`.class`文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入`.class`文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。\n\n第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了`@PostConstruct`的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。\n\n## 定义注解\n\nJava语言使用`@interface`语法来定义注解（`Annotation`），它的格式如下：\n\n```\npublic @interface Report {\n    int type() default 0;\n    String level() default \"info\";\n    String value() default \"\";\n}\n```\n\n注解的参数类似无参数方法，可以用`default`设定一个默认值。最常用的参数应当命名为`value`。\n\n定义一个注解Demo程序：\n\n```java\npackage Annotation;\n\npublic class Demo1 {\n    public @interface check {\n        int max() default 1000;\n        int min() default 0;\n    }\n    @check\n    public static int n;\n    public static void main(String[] args){\n    }\n}\n\n```\n\n注解定义了并没有任何实际意义\n\n## 元注解\n\n有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。\n\n### @Target\n\n最常用的元注解是`@Target`。使用`@Target`可以定义`Annotation`能够被应用于源码的哪些位置：\n\n- 类或接口：`ElementType.TYPE`；\n- 字段：`ElementType.FIELD`；\n- 方法：`ElementType.METHOD`；\n- 构造方法：`ElementType.CONSTRUCTOR`；\n- 方法参数：`ElementType.PARAMETER`。\n\n例如，定义注解可用在方法上，我们必须添加一个`@Target(ElementType.METHOD)`\n\n实际上`@Target`定义的`value`是`ElementType[]`数组，只有一个元素时，可以省略数组的写法。\n\n### @Retention\n\n`@Retention`定义了`Annotation`的生命周期：\n\n- 仅编译期：`RetentionPolicy.SOURCE`；\n- 仅class文件：`RetentionPolicy.CLASS`；\n- 运行期：`RetentionPolicy.RUNTIME`。\n\n### @Repeatable\n\n使用`@Repeatable`这个元注解可以定义`Annotation`是否可重复。\n\n### @Inherited\n\n使用`@Inherited`定义子类是否可继承父类定义的`Annotation`。`@Inherited`仅针对`@Target(ElementType.TYPE)`类型的`annotation`有效，并且仅针对`class`的继承，对`interface`的继承无效.\n\n## 处理注解\n\n只需要考虑如何读取`RUNTIME`类型的注解。\n\n因为注解定义后也是一种`class`，所有的注解都继承自`java.lang.annotation.Annotation`，因此，读取注解，需要使用反射API。\n\nJava提供的使用反射API读取`Annotation`的方法包括：\n\n判断某个注解是否存在于`Class`、`Field`、`Method`或`Constructor`：\n\n- `Class.isAnnotationPresent(Class)`\n- `Field.isAnnotationPresent(Class)`\n- `Method.isAnnotationPresent(Class)`\n- `Constructor.isAnnotationPresent(Class)`\n\n使用反射API读取Annotation：\n\n- `Class.getAnnotation(Class)`\n- `Field.getAnnotation(Class)`\n- `Method.getAnnotation(Class)`\n- `Constructor.getAnnotation(Class)`\n\n定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。\n\n","tags":["第一阶段","JAVA基础"],"categories":["第一阶段"]},{"title":"反射","url":"/2020/12/28/反射/","content":"\n## 什么是反射\n\n反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。\n\n正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例。\n\n**<u>所以反射是为了解决运行期间，对某一个实例一无所知的情况下，如何获取并调用其中的方法</u>**\n\n## Class类\n\nJava中除了几种基本数据类型，即小写字母开头的关键字`int，byte`之外，其他类型全部都是class类型\n\n例如`String，Object，Exception，Integer`\n\n因此可以认为：`class`的本质是数据类型\n\n`class`是由JVM在执行过程中动态加载的。JVM在第一次读取到一种`class`类型时，将其加载进内存。\n\n每加载一种`class`，JVM就为其创建一个`Class`类型的实例，并关联起来。注意：这里的`Class`类型是一个名叫`Class`的`class`。\n\n```java\npublic final class Class {\n    private Class() {}\n}\n```\n\n以`String`类为例，当JVM加载`String`类时，它首先读取`String.class`文件到内存，然后，为`String`类创建一个`Class`实例并关联起来：\n\n```\nClass cls = new Class(String);\n/*\n*这个Class实例是JVM内部创建的\n*Class类的构造方法是private\n*只有JVM能创建Class实例，我们自己的Java程序是无法创建Class实例的。\n*/\n\n```\n\n所以，JVM持有的每个`Class`实例都指向一个数据类型（`class`或`interface`）：\n\n```ascii\n┌───────────────────────────┐\n│      Class Instance       │──────> String\n├───────────────────────────┤\n│name = \"java.lang.String\"  │\n└───────────────────────────┘\n┌───────────────────────────┐\n│      Class Instance       │──────> Random\n├───────────────────────────┤\n│name = \"java.util.Random\"  │\n└───────────────────────────┘\n┌───────────────────────────┐\n│      Class Instance       │──────> Runnable\n├───────────────────────────┤\n│name = \"java.lang.Runnable\"│\n└───────────────────────────┘\n```\n\n一个`Class`实例包含了该`class`的所有完整信息：\n\n```ascii\n┌───────────────────────────┐\n│      Class Instance       │──────> String\n├───────────────────────────┤\n│name = \"java.lang.String\"  │\n├───────────────────────────┤\n│package = \"java.lang\"      │\n├───────────────────────────┤\n│super = \"java.lang.Object\" │\n├───────────────────────────┤\n│interface = CharSequence...│\n├───────────────────────────┤\n│field = value[],hash,...   │\n├───────────────────────────┤\n│method = indexOf()...      │\n└───────────────────────────┘\n```\n\n由于JVM为每个加载的`class`创建了对应的`Class`实例，并在实例中保存了该`class`的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个`Class`实例，我们就可以通过这个`Class`实例获取到该实例对应的`class`的所有信息。\n\n这种通过`Class`实例获取`class`信息的方法称为反射（Reflection）。\n\n### 获取class的Class实例\n\n+ 通过一个class的静态变量\n+ 通过实例对象的getClass方法\n+ 知道完整类名，用Class.forName方法获取\n\n因为`Class`实例在JVM中是唯一的，所以，上述方法获取的`Class`实例是同一个实例。可以用`==`比较两个`Class`实例：\n\nDemo程序如下：\n\n```java\npackage Reflection;\n\npublic class Demo1 {\n    public static void main(String[] args) throws ClassNotFoundException {\n        System.out.println(\"通过class的静态变量class获取:\");\n        Class cls1 = String.class;\n        System.out.println(cls1);\n\n        System.out.println(\"通过class实例对象的getClass方法获取:\");\n        Class cls2 = \"\".getClass();\n        System.out.println(cls2);\n\n        System.out.println(\"如果知道一个class的完整类名，可以通过静态方法Class.forName()获取：\");\n        Class cls3 = Class.forName(\"java.lang.String\");\n        System.out.println(cls3);\n\n        System.out.println(\"比较Class实例：\");\n        System.out.println(\"cls1==cls2 ? \" + (cls1 == cls2));\n        System.out.println(\"cls1==cls3 ? \" + (cls1 == cls3));\n        System.out.println(\"cls2==cls3 ? \" + (cls2 == cls3));\n    }\n\n}\n\n```\n\n运行结果：\n\n![](泛型/1.png)\n\n因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个`Object`实例时，我们可以通过反射获取该`Object`的`class`信息：\n\n```\nvoid printObjectInfo(Object obj) {\n    Class cls = obj.getClass();\n}\n```\n\nDemo2：\n\n```java\npackage Reflection;\n\npublic class Demo2 {\n    public static void main(String[] args) {\n        //String类\n        printClassInfo(\"\".getClass());\n        //实现多线程的接口类\n        printClassInfo(Runnable.class);\n        //时间日期类\n        printClassInfo(java.time.Month.class);\n        //数组不等于String类\n        printClassInfo(String[].class);\n        //基本类型\n        printClassInfo(int.class);\n    }\n\n    static void printClassInfo(Class cls) {\n        System.out.println(\"Class name: \" + cls.getName());\n        System.out.println(\"Simple name: \" + cls.getSimpleName());\n        if (cls.getPackage() != null) {\n            System.out.println(\"Package name: \" + cls.getPackage().getName());\n        }\n        System.out.println(\"is interface: \" + cls.isInterface());\n        System.out.println(\"is enum: \" + cls.isEnum());\n        System.out.println(\"is array: \" + cls.isArray());\n        System.out.println(\"is primitive: \" + cls.isPrimitive());\n        System.out.println();\n    }\n}\npackage Reflection;\n\npublic class Demo2 {\n    public static void main(String[] args) {\n        //String类\n        printClassInfo(\"\".getClass());\n        //实现多线程的接口类\n        printClassInfo(Runnable.class);\n        //时间日期类\n        printClassInfo(java.time.Month.class);\n        //数组不等于String类\n        printClassInfo(String[].class);\n        //基本类型\n        printClassInfo(int.class);\n    }\n\n    static void printClassInfo(Class cls) {\n        System.out.println(\"Class name: \" + cls.getName());\n        System.out.println(\"Simple name: \" + cls.getSimpleName());\n        if (cls.getPackage() != null) {\n            System.out.println(\"Package name: \" + cls.getPackage().getName());\n        }\n        System.out.println(\"is interface: \" + cls.isInterface());\n        System.out.println(\"is enum: \" + cls.isEnum());\n        System.out.println(\"is array: \" + cls.isArray());\n        System.out.println(\"is primitive: \" + cls.isPrimitive());\n        System.out.println();\n    }\n}\n\n```\n\n运行结果：\n\n![](反射/2.png)\n\n如果获取到了一个`Class`实例，我们就可以通过该`Class`实例来创建对应类型的实例：\n\n```java\n// 获取String的Class实例:\nClass cls = String.class;\n// 创建一个String实例:\nString s = (String) cls.newInstance();\n```\n\n上述代码相当于`new String()`。通过`Class.newInstance()`可以创建类实例，它的局限是：**只能调用`public`的无参数构造方法**。带参数的构造方法，或者非`public`的构造方法都无法通过`Class.newInstance()`被调用。\n\n### 动态加载\n\nJVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。\n\n## 访问字段\n\n对任意的一个`Object`实例，只要我们获取了它的`Class`，就可以获取它的一切信息。\n\n**这就是“反射”**\n\n`Class`类提供了以下几个方法来获取字段：\n\n- Field getField(name)：根据字段名获取某个public的field（包括父类）\n- Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）\n- Field[] getFields()：获取所有public的field（包括父类）\n- Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）\n\n一个`Field`对象包含了一个字段的所有信息：\n\n- `getName()`：返回字段名称，例如，`\"name\"`；\n- `getType()`：返回字段类型，也是一个`Class`实例，例如，`String.class`；\n- `getModifiers()`：返回字段的修饰符，它是一个`int`，不同的bit表示不同的含义。\n\n字段可以访问、获取、设置。\n\n## 调用方法\n\n通过`Class`实例的方法可以获取`Method`实例：`getMethod()`，`getMethods()`，`getDeclaredMethod()`，`getDeclaredMethods()`；\n\n通过`Method`实例可以获取方法信息：`getName()`，`getReturnType()`，`getParameterTypes()`，`getModifiers()`；\n\n通过`Method`实例可以调用某个对象的方法：`Object invoke(Object instance, Object... parameters)`；\n\n通过设置`setAccessible(true)`来访问非`public`方法；\n\n通过反射调用方法时，仍然遵循多态原则。\n\n## 调用构造方法\n\n`Constructor`对象封装了构造方法的所有信息；\n\n通过`Class`实例的方法可以获取`Constructor`实例：`getConstructor()`，`getConstructors()`，`getDeclaredConstructor()`，`getDeclaredConstructors()`；\n\n通过`Constructor`实例可以创建一个实例对象：`newInstance(Object... parameters)`； 通过设置`setAccessible(true)`来访问非`public`构造方法。\n\n## 获取继承关系\n\n通过`Class`对象可以获取继承关系：\n\n- `Class getSuperclass()`：获取父类类型；\n- `Class[] getInterfaces()`：获取当前类实现的所有接口。\n\n通过`Class`对象的`isAssignableFrom()`方法可以判断一个向上转型是否可以实现。\n\n## 总结\n\n反射技术内容其实很多，目前暂时先建立概念框架，以及简单Demo，这种技术用的多的是在框架中，等到学习Java第一个框架——集合框架再研究深一点！！！","tags":["第一阶段","JAVA基础"],"categories":["第一阶段"]},{"title":"泛型","url":"/2020/12/28/泛型/","content":"\n## 概述\n\n其实Java中的泛型也就是C++中的模板类。C++中用的最多的就是STL中。之所以用到泛型其实就是使得一个函数的功能更强大，或者说一个类的功能更强大。比如写一个函数比较两个元素大小，在C++中有float类型，int类型，double甚至string时每种格式数据都需要写一个函数，很麻烦。\n\n什么是泛型？为什么要使用泛型？\n\n**泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。**\n\n**泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）**。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。\n\n## 举例\n\n在JDK1.5版本之前没有泛型，因此可以定义一个可以接收任何对象的List，\n\n![](泛型/1.png)\n\n定义一个ArrayList，格式是Object，所有类的父类\n\n![](泛型/2.png)\n\n上述问题是运行是产生问题。\n\n为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。\n\n## 特性\n\n泛型只在编译阶段有效。编译之后程序会采取去泛型化的措施，也就是说Java中的泛型，只在编译阶段有效。\n\n在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。\n\n**型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。**\n\n## 泛型的使用\n\n泛型的三种使用方法：泛型类，泛型接口，泛型方法\n\n### 泛型类\n\n在类的定义中使用类，然后就可让类中的操作都能使用泛型。最典型的就是Java各种容器类——List，Set，Map\n\n一个泛型类例子：\n\n```java\npackage Fanxing;\n\nclass Point<K,V> {       // 此处可以随便写标识符号，T是type的简称\n    private K key;\n    private V value;\n    public void set(K akey,V avalue){\n        this.key = akey;\n        this.value = avalue;\n    }\n    public V getValue(){//作为方法返回类型\n        return this.value;\n    }\n\n};\npublic class Test{\n    public static void main(String args[]){\n        Point<Integer,String> p = new Point<Integer,String>();\n        p.set(1,\"one\");\n        System.out.println(p.getValue());\n        fun(p);\n    }\n    public static void fun(Point<?,?> temp){//通配符 ？\n        System.out.println(temp.getValue());\n    }\n};\n```\n\n声明方法是在类名后面用尖括号把会用到的标识符号列出来。\n\n然后在类中就可以直接使用这些标识符，作为变量类型或者方法的返回类型都可以。\n\n### 泛型接口\n\n泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：\n\n```java\npackage Fanxing;\n\ninterface Info<T>{        // 在接口上定义泛型\n    public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型\n}\nclass InfoImpl<T> implements Info<T>{   // 定义泛型接口的子类\n    private T var ;             // 定义属性\n    public InfoImpl(T avar){     // 通过构造方法设置属性内容\n        this.var = avar;\n    }\n    public T getVar(){//实现接口\n        return this.var ;\n    }\n};\npublic class Test2{\n    public static void main(String arsg[]){\n        Info<String> i =new InfoImpl<String>(\"Codefriday\") ;\n        System.out.println(\"作者：\" + i.getVar()) ;\n    }\n};\n```\n\n### 泛型方法\n\n第一个泛型类例子中\n\n```java\n public V getValue()//作为方法返回类型\n```\n\n并不是一个泛型方法，这只是类中一个普通成员方法，下面引用泛型方法：\n\n\tpublic class Test1 {\n\t    public <T> void testMethod(T t){\n\t\n\t    }\n\t}\n类型参数位置在返回类型之前\n\n### 通配符\n\n除了用 `<T>`表示泛型外，还有 `<?>`这种形式。**？** 被称为通配符。\n\n通配符有 3 种形式。\n\n1. `<?>`被称作无限定的通配符。\n2. `<? extends T>`被称作有上限的通配符。\n3. `<? super T>`被称作有下限的通配符。\n\n## 类型擦除\n\n**泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除**。\n\n### 带来的局限性\n\n类型擦除，是泛型能够与之前的 java 版本代码兼容共存的原因。但也因为类型擦除，它会抹掉很多继承相关的特性，这是它带来的局限性。\n\n## 泛型中值得注意的地方\n\n### 不接受 8 种基本数据类型\n\n原因：只接受对象！！！\n\n```\nint->integer\n\nboolean->Boolean\n```\n\n## 总结\n\n泛型其实就是方便编程以及减小代码冗余度，但是只是编译阶段起作用。\n\n抽离了数据类型与代码逻辑，本意是提高程序代码的简洁性和可读性，并提供可能的编译时类型转换安全检测功能。","tags":["第一阶段","JAVA基础"],"categories":["第一阶段"]},{"title":"Java数据结构","url":"/2020/12/27/Java数据结构/","content":"\n## 前言\n\n我有过数据结构的基础，学C++时都实现了一遍数据结构，所以相当于做记录，更偏向实际应用。\n\n本博客相当于是笔记，只为了给自己以后方便查资料等，并不是自己写的内容，因为我也是正在学。\n\n基本复制来的加上自己手敲代码给自己加深印象。\n\n资源来自[菜鸟网](https://www.runoob.com/java/java-tutorial.html)\n\n## Java 数据结构\n\nJava工具包提供了强大的数据结构。在Java中的数据结构主要包括以下几种接口和类：\n\n- 枚举（Enumeration）\n- 位集合（BitSet）\n- 向量（Vector）\n- 栈（Stack）\n- 字典（Dictionary）\n- 哈希表（Hashtable）\n- 属性（Properties）\n\n### 枚举（Enumeration）\n\n枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。 枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。\n\n例如，枚举定义了一个叫nextElement 的方法，该方法用来得到一个包含多元素的数据结构的下一个元素。\n\nEnumeration接口中定义了一些方法，通过这些方法可以枚举（一次获得一个）对象集合中的元素。\n\n这种传统接口已被迭代器取代，虽然Enumeration 还未被遗弃，但在现代代码中已经被很少使用了。尽管如此，它还是使用在诸如Vector和Properties这些传统类所定义的方法中，除此之外，还用在一些API类，并且在应用程序中也广泛被使用。 下表总结了一些Enumeration声明的方法：\n\n| **序号** |                         **方法描述**                         |\n| :------- | :----------------------------------------------------------: |\n| 1        | **boolean hasMoreElements( )**  测试此枚举是否包含更多的元素。 |\n| 2        | **Object nextElement( )** 如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素。 |\n\n实例：\n\n```cpp\npackage hello;\nimport java.util.Vector;\nimport java.util.Enumeration;\npublic class EnumerationTest {\n    public static void main(String args[]) {\n        Enumeration<String> days;\n        Vector<String> week = new Vector<String>();\n        week.add(\"Sunday\");\n        week.add(\"Monday\");\n        week.add(\"Tuesday\");\n        week.add(\"Wednesday\");\n        week.add(\"Thursday\");\n        week.add(\"Friday\");\n        week.add(\"Saturday\");\n        days = week.elements();\n        while(days.hasMoreElements()){\n            System.out.println(days.nextElement());\n        }\n    }\n}\n\n```\n\n运行结果：\n\n![](Java数据结构/1.png)\n\n### 位集合（BitSet）\n\n位集合类实现了一组可以单独设置和清除的位或标志。\n\n该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一\"位\"，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。\n\n一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。这和位向量（vector of bits）比较类似。\n\n这是一个传统的类，但它在Java 2中被完全重新设计。\n\nBitSet定义了两个构造方法。\n\n第一个构造方法创建一个默认的对象：\n\n```\nBitSet()\n```\n\n第二个方法允许用户指定初始大小。所有位初始化为0。\n\n```\nBitSet(int size)\n```\n\n### 向量（Vector）\n\n向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。\n\n和数组一样，Vector对象的元素也能通过索引访问。\n\n使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。\n\nVector 类实现了一个动态数组。和 ArrayList 很相似，但是两者是不同的：\n\n- Vector 是同步访问的。\n- Vector 包含了许多传统的方法，这些方法不属于集合框架。\n\nVector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。\n\nVector 类支持 4 种构造方法。\n\n第一种构造方法创建一个默认的向量，默认大小为 10：\n\n```\nVector()\n```\n\n第二种构造方法创建指定大小的向量。\n\n```\nVector(int size)\n```\n\n第三种构造方法创建指定大小的向量，并且增量用 incr 指定。增量表示向量每次增加的元素数目。\n\n```\nVector(int size,int incr)\n```\n\n第四种构造方法创建一个包含集合 c 元素的向量：\n\n```\nVector(Collection c)\n```\n\n一堆接口：比较两个接口，其他接口用到再写：\n\n int size()   返回此向量中的组件数。\n\n Enumeration elements()  返回此向量的组件的枚举。\n\nint capacity() 返回此向量的当前容量。\n\n**容量可以构造时指定，而size表示容器中现在有的对象个数。**\n\n### 栈（Stack）\n\n栈（Stack）实现了一个后进先出（LIFO）的数据结构。\n\n你可以把栈理解为对象的垂直分布的栈，当你添加一个新元素时，就将新元素放在其他元素的顶部。\n\n当你从栈中取元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。\n\n**除了由Vector定义的所有方法，自己也定义了一些方法：**\n\n堆栈只定义了默认构造函数，用来创建一个空栈。 堆栈除了包括由Vector定义的所有方法，也定义了自己的一些方法。\n\n```\nStack()\n```\n\n| 序号 |                           方法描述                           |\n| :--: | :----------------------------------------------------------: |\n|  1   |             boolean empty()  测试堆栈是否为空。              |\n|  2   |   Object peek( ) 查看堆栈顶部的对象，但不从堆栈中移除它。    |\n|  3   | Object pop( ) 移除堆栈顶部的对象，并作为此函数的值返回该对象。 |\n|  4   |        Object push(Object element) 把项压入堆栈顶部。        |\n|  5   | int search(Object element) 返回对象在堆栈中的位置，以 1 为基数。 |\n\n### 字典（Dictionary）\n\n字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。\n\n当你想要通过特定的键而不是整数索引来访问数据的时候，这时候应该使用Dictionary。\n\n由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。\n\n类似于C++的map\n\nDictionary 类是一个抽象类，用来存储键/值对，作用和Map类相似。\n\n给出键和值，你就可以将值存储在Dictionary对象中。一旦该值被存储，就可以通过它的键来获取它。所以和Map一样， Dictionary 也可以作为一个键/值对列表。\n\nDictionary定义的抽象方法如下表所示：\n\n| **序号** |                         **方法描述**                         |\n| :------: | :----------------------------------------------------------: |\n|    1     |  **Enumeration elements( )** 返回此 dictionary 中值的枚举。  |\n|    2     | **Object get(Object key)** 返回此 dictionary 中该键所映射到的值。 |\n|    3     | **boolean isEmpty( )** 测试此 dictionary 是否不存在从键到值的映射。 |\n|    4     |   **Enumeration keys( )** 返回此 dictionary 中的键的枚举。   |\n|    5     | **Object put(Object key, Object value)** 将指定 key 映射到此 dictionary 中指定 value。 |\n|    6     | **Object remove(Object key)** 从此 dictionary 中移除 key （及其相应的 value）。 |\n|    7     |  **int size( )** 返回此 dictionary 中条目（不同键）的数量。  |\n\nDictionary类已经过时了。在实际开发中，你可以实现Map接口来获取键/值的存储功能。\n\n### 哈希表（Hashtable）\n\nHashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。\n\n例如，在地址列表的哈希表中，你可以根据邮政编码作为键来存储和排序数据，而不是通过人名。\n\n哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。\n\n#### Java Hashtable 类\n\nHashtable是原始的java.util的一部分， 是一个Dictionary具体的实现 。\n\n然而，Java 2 重构的Hashtable实现了Map接口，因此，Hashtable现在集成到了集合框架中。它和HashMap类很相似，但是它支持同步。\n\n像HashMap一样，Hashtable在哈希表中存储键/值对。当使用一个哈希表，要指定用作键的对象，以及要链接到该键的值。\n\n然后，该键经过哈希处理，所得到的散列码被用作存储在该表中值的索引。\n\nHashtable定义了四个构造方法。第一个是默认构造方法：\n\n```\nHashtable()\n```\n\n第二个构造函数创建指定大小的哈希表：\n\n```\nHashtable(int size)\n```\n\n第三个构造方法创建了一个指定大小的哈希表，并且通过fillRatio指定填充比例。\n\n填充比例必须介于0.0和1.0之间，它决定了哈希表在重新调整大小之前的充满程度：\n\n```\nHashtable(int size,float fillRatio)\n```\n\n第四个构造方法创建了一个以M中元素为初始化元素的哈希表。\n\n哈希表的容量被设置为M的两倍。\n\n```\nHashtable(Map m)\n```\n\n### 属性（Properties）\n\nProperties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。\n\nProperties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。\n\n#### Java Properties 类\n\nProperties 继承于 Hashtable。表示一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。\n\nProperties 类被许多 Java 类使用。例如，在获取环境变量时它就作为 System.getProperties() 方法的返回值。\n\nProperties 定义如下实例变量.这个变量持有一个 Properties 对象相关的默认属性列表。\n\n```\nProperties defaults;\n```\n\nProperties类定义了两个构造方法. 第一个构造方法没有默认值。\n\n```\nProperties()\n```\n\n第二个构造方法使用propDefault 作为默认值。两种情况下，属性列表都为空：\n\n```\nProperties(Properties propDefault)\n```\n\n## 总结\n\n先大致过一遍，后面搞项目练手时不至于遇到就卡住！","tags":["第一阶段","JAVA基础"],"categories":["第一阶段"]},{"title":"Java面向对象","url":"/2020/12/27/Java面向对象/","content":"\n<!--more-->\n\nJAVA是一门纯面向对象的语言。\n\n## 1.Java 继承\n\n### 1.1继承的概念\n\n继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。\n\n继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。\n\n所以继承需要符合的关系是：is-a，父类更通用，子类更具体。\n\n### 1.2类的继承格式\n\n在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：\n\n```java\nclass 父类 {\n}\n \nclass 子类 extends 父类 {\n}\n```\n\n### 1.3为什么需要继承\n\n一个简单例子：\n\n不使用继承，代码重复：\n\n![](Java面向对象/1.png)\n\n![](Java面向对象/2.png)\n\n使用继承之后：\n\n![](Java面向对象/3.png)\n\n从这两段代码可以看出来，代码存在重复了，导致后果就是代码量大且臃肿，而且维护性不高(维护性主要是后期需要修改的时候，就需要修改很多的代码，容易出错)，所以要从根本上解决这两段代码的问题，就需要继承，将两段代码中相同的部分提取出来组成 一个父类.\n\n### 1.4继承类型\n\n需要注意的是 Java 不支持多继承，但支持多重继承。(C++支持多继承)\n\n![](E:\\Blog\\source\\_posts\\Java面向对象\\4.png)\n\n### 1.5继承的特性\n\n- 子类拥有父类非 private 的属性、方法。\n- 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\n- 子类可以用自己的方式实现父类的方法。\n- Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。\n- 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。\n\n### 1.6 继承关键字\n\n继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 **java.lang** 包中，所以不需要 **import**）祖先类。\n\n#### 1.6.1extends关键字\n\n在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。\n\n#### 1.6.2implements关键字\n\n使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。\n\n#### 1.6.3super 与 this 关键字\n\nsuper关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。\n\nthis关键字：指向自己的引用。\n\n#### 1.6.4final关键字\n\nfinal 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：\n\n#### 1.6.5 构造器\n\n子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 **super** 关键字调用父类的构造器并配以适当的参数列表。\n\n如果父类构造器没有参数，则在子类的构造器中不需要使用 **super** 关键字调用父类构造器，系统会自动调用父类的无参构造器。\n\n## 2.Java 重写(Override)与重载(Overload)\n\n### 2.1重写(Override)\n\n重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。**即外壳不变，核心重写！**\n\n重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。\n\n重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。\n\n在编译阶段，只检查参数的引用类型。\n\n然而在运行时，Java 虚拟机(JVM)指定对象的类型并且运行该对象的方法。\n\n#### 2.1.1方法的重写规则\n\n- 参数列表与被重写方法的参数列表必须完全相同。\n- 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。\n- 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。\n- 父类的成员方法只能被它的子类重写。\n- 声明为 final 的方法不能被重写。\n- 声明为 static 的方法不能被重写，但是能够被再次声明。\n- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。\n- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。\n- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。\n- 构造方法不能被重写。\n- 如果不能继承一个类，则不能重写该类的方法。\n\n#### 2.1.2Super 关键字的使用\n\n当需要在子类中调用父类的被重写方法时，要使用 super 关键字。\n\n### 2.2重载(Overload)\n\n重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。\n\n每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。\n\n最常用的地方就是构造器的重载。\n\n#### 2.2.1重载规则:\n\n- 被重载的方法必须改变参数列表(参数个数或类型不一样)；\n- 被重载的方法可以改变返回类型；\n- 被重载的方法可以改变访问修饰符；\n- 被重载的方法可以声明新的或更广的检查异常；\n- 方法能够在同一个类中或者在一个子类中被重载。\n- 无法以返回值类型作为重载函数的区分标准。\n\n### 2.3重写与重载之间的区别\n\n|  区别点  | 重载方法 |                    重写方法                    |\n| :------: | :------: | :--------------------------------------------: |\n| 参数列表 | 必须修改 |                  一定不能修改                  |\n| 返回类型 | 可以修改 |                  一定不能修改                  |\n|   异常   | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常 |\n|   访问   | 可以修改 |     一定不能做更严格的限制（可以降低限制）     |\n\n### 2.4总结：\n\n方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。\n\n- (1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。\n- (2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。\n- (3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。\n\n![](Java面向对象/5.png)\n\n## 3.Java 多态\n\n多态是同一个行为具有多个不同表现形式或形态的能力。\n\n多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：\n\n### 3.1多态的优点\n\n- 1. 消除类型之间的耦合关系\n- 2. 可替换性\n- 3. 可扩充性\n- 4. 接口性\n- 5. 灵活性\n- 6. 简化性\n\n### 3.2多态存在的三个必要条件\n\n- 继承\n- 重写\n- 父类引用指向子类对象：**Parent p = new Child();**\n\n![](Java面向对象/6.png)\n\n### 3.3虚函数\n\n虚函数的存在是为了多态。\n\nJava 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。\n\n### 3.4多态的实现方式\n\n#### 方式一：重写\n\n#### 方式二：接口\n\n#### 方式三：抽象类和抽象方法\n\n## 4.Java 抽象类\n\n### 4.1抽象类\n\n在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。\n\n抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。\n\n由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。\n\n父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。\n\n在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n抽象类不能实例化：\n\n![](Java面向对象/7.png)\n\n### 4.2抽象方法\n\n如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。\n\nAbstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。\n\n抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。\n\n**声明抽象方法会造成以下两个结果：**\n\n- 如果一个类包含抽象方法，那么该类必须是抽象类。\n- 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。\n\n继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。\n\n### 4.3抽象类总结规定\n\n- 1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。\n- 2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。\n- 3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。\n- 4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。\n- 5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。\n\n## 5.Java 封装\n\n在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。\n\n封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。\n\n要访问该类的代码和数据，必须通过严格的接口控制。\n\n封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。\n\n适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。\n\n### 5.1封装的优点\n\n- 1. 良好的封装能够减少耦合。\n- 2. 类内部的结构可以自由修改。\n- 3. 可以对成员变量进行更精确的控制。\n- 4. 隐藏信息，实现细节。\n\n### 5.2实现Java封装的步骤\n\n#### 5.2.1修改属性的可见性来限制对属性的访问（一般限制为private），例如：\n\n```java\npublic class Person {\n    private String name;\n    private int age;\n}\n```\n\n这段代码中，将 **name** 和 **age** 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。\n\n#### 5.2.2对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：\n\n```java\npublic class Person{\n    private String name;\n    private int age;\n​\n    public int getAge(){\n      return age;\n    }\n​\n    public String getName(){\n      return name;\n    }\n​\n    public void setAge(int age){\n      this.age = age;\n    }\n​\n    public void setName(String name){\n      this.name = name;\n    }\n}\n```\n\n采用 **this** 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。\n\n## 6.Java 接口\n\n接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。\n\n接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。\n\n除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\n\n接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。\n\n### 6.1接口与类相似点：\n\n- 一个接口可以有多个方法。\n- 接口文件保存在 .java 结尾的文件中，文件名使用接口名。\n- 接口的字节码文件保存在 .class 结尾的文件中。\n- 接口相应的字节码文件必须在与包名称相匹配的目录结构中。\n\n### 6.2接口与类的区别：\n\n- 接口不能用于实例化对象。\n- 接口没有构造方法。\n- 接口中所有的方法必须是抽象方法。\n- 接口不能包含成员变量，除了 static 和 final 变量。\n- 接口不是被类继承了，而是要被类实现。\n- 接口支持多继承。\n\n### 6.3接口特性\n\n- 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 **public abstract**（只能是 public abstract，其他修饰符都会报错）。\n- 接口中可以含有变量，但是接口中的变量会被隐式的指定为 **public static final** 变量（并且只能是 public，用 private 修饰会报编译错误）。\n- 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。\n\n### 6.4抽象类和接口的区别\n\n- 1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。\n- 2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 **public static final** 类型的。\n- 3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。\n- 4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n### 6.5接口的声明\n\n规则：\n\n```java\n[可见度] interface 接口名称 [extends 其他的接口名] {\n        // 声明变量\n        // 抽象方法\n}\n```\n\n接口有以下特性：\n\n- 接口是隐式抽象的，当声明一个接口的时候，不必使用**abstract**关键字。\n- 接口中每一个方法也是隐式抽象的，声明时同样不需要**abstract**关键字。\n- 接口中的方法都是公有的。\n\n### 6.6接口的实现\n\n当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。\n\n类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。\n\n实现一个接口的语法，可以使用这个公式：\n\n```java\n...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...\n```\n\n重写接口中声明的方法时，需要注意以下规则：\n\n- 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。\n- 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。\n- 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。\n\n在实现接口的时候，也要注意一些规则：\n\n- 一个类可以同时实现多个接口。\n- 一个类只能继承一个类，但是能实现多个接口。\n- 一个接口能继承另一个接口，这和类之间的继承比较相似。\n\n### 6.7接口的继承\n\n一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。\n\n### 6.8接口的多继承\n\n在Java中，类的多继承是不合法，但接口允许多继承。\n\n在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：\n\n```java\npublic interface Hockey extends Sports, Event\n```\n\n### 6.9标记接口\n\n最常用的继承接口是没有包含任何方法的接口。\n\n标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。\n\n标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。\n\n例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：\n\n```java\npackage java.util;\npublic interface EventListener\n{}\n```\n\n没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：\n\n- 建立一个公共的父接口：\n\n  正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。\n\n- 向一个类添加数据类型：\n\n  这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。\n\n## 7.Java 枚举(enum)\n\nJava 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。\n\nJava 枚举类使用 enum 关键字来定义，各个常量使用逗号 **,** 来分割。\n\n例如定义一个颜色的枚举类。\n\n```\nenum Color \n{ \n    RED, GREEN, BLUE; \n} \n```\n\n实例：\n\n```java\nenum Color\n{\n    RED, GREEN, BLUE;\n}\n \npublic class Test\n{\n    // 执行输出结果\n    public static void main(String[] args)\n    {\n        Color c1 = Color.RED;\n        System.out.println(c1);\n    }\n}\n```\n\n输出：RED\n\n### 7.1内部类中使用枚举\n\n枚举类也可以声明在内部类中\n\n### 7.2迭代枚举元素\n\n可以使用 for 语句来迭代枚举元素：\n\n```java\nenum Color\n{\n    RED, GREEN, BLUE;\n}\npublic class MyClass {\n  public static void main(String[] args) {\n    for (Color myVar : Color.values()) {\n      System.out.println(myVar);\n    }\n  }\n}\n```\n\n和C++中的枚举区别很大\n\n### 7.3在 switch 中使用枚举类\n\n```java\nenum Color\n{\n    RED, GREEN, BLUE;\n}\npublic class MyClass {\n  public static void main(String[] args) {\n    Color myVar = Color.BLUE;\n\n    switch(myVar) {\n      case RED:\n        System.out.println(\"红色\");\n        break;\n      case GREEN:\n         System.out.println(\"绿色\");\n        break;\n      case BLUE:\n        System.out.println(\"蓝色\");\n        break;\n    }\n  }\n}\n```\n\n### 7.4values(), ordinal() 和 valueOf() 方法\n\nenum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。\n\nvalues(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：\n\n- values() 返回枚举类中所有的值。\n- ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。\n- valueOf()方法返回指定字符串值的枚举常量。\n\n## 8.Java 包(package)\n\n为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。\n\nC++中使用using namespace的编译指令区别！！！\n\n### 8.1包的作用\n\n- 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。\n- 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。\n- 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。\n\nJava 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。\n\n包语句的语法格式为：\n\n`package pkg1[．pkg2[．pkg3…]];`\n\n### 8.2创建包\n\n![](Java面向对象/8.png)\n\n然后可以把自己的包打包成jar包，并调用\n\n### 8.3import 关键字\n\n为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 \"import\" 语句可完成此功能。\n\n在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为：\n`port package1[.package2…].(classname|*);`\n\n### 8.4package 的目录结构\n\n类放在包中会有两种主要的结果：\n\n- 包名成为类名的一部分，正如我们前面讨论的一样。\n- 包名必须与相应的字节码所在的目录结构相吻合。\n\n下面是管理你自己 java 中文件的一种简单方式：\n\n+ 将类、接口等类型的源码放在一个文本中，这个文件的名字就是这个类型的名字，并以.java作为扩展名。例如：\n\n```java\n// 文件名 :  Car.java\n \npackage vehicle;\n \npublic class Car {\n   // 类实现  \n}\n```\n\n+ 接下来，把源文件放在一个目录中，这个目录要对应类所在包的名字。\n\n```java\n....\\vehicle\\Car.java\n```\n\n+ 现在，正确的类名和路径将会是如下样子：\n\n  - 类名 -> vehicle.Car\n  - 路径名 -> vehicle\\Car.java (在 windows 系统中)\n\n  通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是 runoob.com，所有的包名都以 com.runoob 开头。包名中的每一个部分对应一个子目录。\n\n  例如：有一个 **com.runoob.test** 的包，这个包包含一个叫做 Runoob.java 的源文件，那么相应的，应该有如下面的一连串子目录：\n\n```java\n....\\com\\runoob\\test\\Runoob.java\n```\n\n+ 编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类型的名字，并加上 .class 作为扩展后缀。 例如：\n\n```java\n// 文件名: Runoob.java\n \npackage com.runoob.test;\npublic class Runoob {\n      \n}\nclass Google {\n      \n}\n```\n\n+ 现在，我们用-d选项来编译这个文件，如下：\n\n> ```\n> $javac -d . Runoob.java\n> ```\n\n+ 这样会像下面这样放置编译了的文件：\n\n> ```\n> .\\com\\runoob\\test\\Runoob.class\n> .\\com\\runoob\\test\\Google.class\n> ```\n\n+ 你可以像下面这样来导入所有 **\\com\\runoob\\test\\** 中定义的类、接口等：\n\n> ```\n> import com.runoob.test.*;\n> ```\n\n+ 编译之后的 .class 文件应该和 .java 源文件一样，它们放置的目录应该跟包的名字对应起来。但是，并不要求 .class 文件的路径跟相应的 .java 的路径一样。你可以分开来安排源码和类的目录。\n\n> ```\n> <path-one>\\sources\\com\\runoob\\test\\Runoob.java\n> <path-two>\\classes\\com\\runoob\\test\\Google.class\n> ```\n\n这样，你可以将你的类目录分享给其他的编程人员，而不用透露自己的源码。用这种方法管理源码和类文件可以让编译器和java 虚拟机（JVM）可以找到你程序中使用的所有类型。\n\n类目录的绝对路径叫做 **class path**。设置在系统变量 **CLASSPATH** 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。\n\n<path- two>\\classes 是 class path，package 名字是 com.runoob.test,而编译器和 JVM 会在 <path-two>\\classes\\com\\runoob\\test 中找 .class 文件。\n\n一个 class path 可能会包含好几个路径，多路径应该用分隔符分开。默认情况下，编译器和 JVM 查找当前目录。JAR 文件按包含 Java 平台相关的类，所以他们的目录默认放在了 class path 中。\n\n### 8.5设置 CLASSPATH 系统变量\n\n就像安装JDK时设置系统变量一样用自己的包！！！","tags":["第一阶段","JAVA基础"],"categories":["第一阶段"]},{"title":"Java基础语法","url":"/2020/12/26/基础语法/","content":"\n\n\n<!--more-->\n\n## Java 源程序与编译型运行区别\n\n![](./基础语法/1.png)\n\n## Java 对象和类\n\nJava作为一种面向对象语言。支持以下基本概念：\n\n- 多态\n- 继承\n- 封装\n- 抽象\n- 类\n- 对象\n- 实例\n- 方法\n- 重载\n\n### 对象和类的概念。\n\n- **对象**：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。\n- **类**：类是一个模板，它描述一类对象的行为和状态。\n\n### 一个类可以包含以下类型变量：\n\n- **局部变量**：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。\n- **成员变量**：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。\n- **类变量**：类变量也声明在类中，方法体之外，但必须声明为 static 类型。\n\n### 构造方法\n\n每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。\n\n在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。\n\n```java\npublic class Puppy{\n    public Puppy(){\n    }\n \n    public Puppy(String name){\n        // 这个构造器仅有一个参数：name\n    }\n}\n```\n\n### 源文件声明规则\n\n当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。\n\n- 一个源文件中只能有一个 public 类\n- 一个源文件可以有多个非 public 类\n- 源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。\n- 如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。\n- 如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。\n- import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。\n\n## Java 基本数据类型\n\n变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。\n\n内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。\n\n![](./基础语法/2.png)\n\n因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。\n\nJava 的两大数据类型:\n\n- 内置数据类型\n- 引用数据类型\n\n### 内置数据类型\n\nJava语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。\n\n**byte：**\n\n- byte 数据类型是8位、有符号的，以二进制补码表示的整数；\n- 最小值是 **-128（-2^7）**；\n- 最大值是 **127（2^7-1）**；\n- 默认值是 **0**；\n- byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；\n- 例子：byte a = 100，byte b = -50。\n\n**short：**\n\n- short 数据类型是 16 位、有符号的以二进制补码表示的整数\n- 最小值是 **-32768（-2^15）**；\n- 最大值是 **32767（2^15 - 1）**；\n- Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；\n- 默认值是 **0**；\n- 例子：short s = 1000，short r = -20000。\n\n**int：**\n\n- int 数据类型是32位、有符号的以二进制补码表示的整数；\n- 最小值是 **-2,147,483,648（-2^31）**；\n- 最大值是 **2,147,483,647（2^31 - 1）**；\n- 一般地整型变量默认为 int 类型；\n- 默认值是 **0** ；\n- 例子：int a = 100000, int b = -200000。\n\n**long：**\n\n- long 数据类型是 64 位、有符号的以二进制补码表示的整数；\n- 最小值是 **-9,223,372,036,854,775,808（-2^63）**；\n- 最大值是 **9,223,372,036,854,775,807（2^63 -1）**；\n- 这种类型主要使用在需要比较大整数的系统上；\n- 默认值是 **0L**；\n- 例子： long a = 100000L，Long b = -200000L。\n  \"L\"理论上不分大小写，但是若写成\"l\"容易与数字\"1\"混淆，不容易分辩。所以最好大写。\n\n**float：**\n\n- float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；\n- float 在储存大型浮点数组的时候可节省内存空间；\n- 默认值是 **0.0f**；\n- 浮点数不能用来表示精确的值，如货币；\n- 例子：float f1 = 234.5f。\n\n**double：**\n\n- double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；\n- 浮点数的默认类型为double类型；\n- double类型同样不能表示精确的值，如货币；\n- 默认值是 **0.0d**；\n- 例子：double d1 = 123.4。\n\n**boolean：**\n\n- boolean数据类型表示一位的信息；\n- 只有两个取值：true 和 false；\n- 这种类型只作为一种标志来记录 true/false 情况；\n- 默认值是 **false**；\n- 例子：boolean one = true。\n\n**char：**\n\n- char类型是一个单一的 16 位 Unicode 字符；\n- 最小值是 **\\u0000**（即为 0）；\n- 最大值是 **\\uffff**（即为65、535）；\n- char 数据类型可以储存任何字符；\n- 例子：char letter = 'A';。\n\n### 类型默认值\n\n|      **数据类型**      | **默认值** |\n| :--------------------: | :--------: |\n|          byte          |     0      |\n|         short          |     0      |\n|          int           |     0      |\n|          long          |     0L     |\n|         float          |    0.0f    |\n|         double         |    0.0d    |\n|          char          |  'u0000'   |\n| String (or any object) |    null    |\n|        boolean         |   false    |\n\n### 引用类型\n\n- 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型。变量一旦声明后，类型就不能被改变了。\n- 对象、数组都是引用数据类型。\n- 所有引用类型的默认值都是null。\n- 一个引用变量可以用来引用任何与之兼容的类型。\n- 例子：Site site = new Site(\"Runoob\")。\n\n### Java 常量\n\n常量在程序运行时是不能被修改的。\n\n在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：\n\n```\nfinal double PI = 3.1415927;\n```\n\n### 自动类型转换\n\n```\n低  ------------------------------------>  高\n\nbyte,short,char—> int —> long—> float —> double \n```\n\n数据类型转换必须满足如下规则：\n\n- 1. 不能对boolean类型进行类型转换。\n\n- 2. 不能把对象类型转换成不相关类的对象。\n\n- 3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。\n\n- 4. 转换过程中可能导致溢出或损失精度，例如：\n\n  ```\n  int i =128;   \n  byte b = (byte)i;\n  ```\n\n  因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。\n\n- 5. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：\n\n  ```\n  (int)23.7 == 23;        \n  (int)-45.89f == -45\n  ```\n\n#### 自动类型转换\n\n必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。\n\n#### 强制类型转换\n\n- 1. 条件是转换的数据类型必须是兼容的。\n- 2. 格式：(type)value type是要强制类型转换后的数据类型 实例：\n\n#### 隐含强制类型转换\n\n- 1. 整数的默认类型是 int。\n- 2. 浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f。\n\n## Java 变量类型\n\n- 类变量：独立于方法之外的变量，用 static 修饰。\n- 实例变量：独立于方法之外的变量，不过没有 static 修饰。\n- 局部变量：类的方法中的变量。\n\n![](基础语法/3.png)![](基础语法/4.png)\n\n### 实例变量\n\n- 实例变量声明在一个类中，但在方法、构造方法和语句块之外；\n- 当一个对象被实例化之后，每个实例变量的值就跟着确定；\n- 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；\n- 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；\n- 实例变量可以声明在使用前或者使用后；\n- 访问修饰符可以修饰实例变量；\n- 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；\n- 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；\n- 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。\n\n### 类变量（静态变量）\n\n- 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。\n- 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n- 静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。\n- 静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。\n- 静态变量在第一次被访问时创建，在程序结束时销毁。\n- 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。\n- 默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n- 静态变量可以通过：*ClassName.VariableName*的方式访问。\n- 类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。\n\n## Java 修饰符\n\n### 访问控制修饰符\n\nJava中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。\n\n- **default** (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。\n- **private** : 在同一类内可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**\n- **public** : 对所有类可见。使用对象：类、接口、变量、方法\n- **protected** : 对同一包内的类和所有子类可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**。\n\n我们可以通过以下表来说明访问权限：\n\n| 修饰符      | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包) | 其他包 |\n| :---------- | :----: | :------: | :------------: | :------------: | :----: |\n| `public`    |   Y    |    Y     |       Y        |       Y        |   Y    |\n| `protected` |   Y    |    Y     |       Y        |      Y/N       |   N    |\n| `default`   |   Y    |    Y     |       Y        |       N        |   N    |\n| `private`   |   Y    |    N     |       N        |       N        |   N    |\n\n#### 访问控制和继承\n\n- 父类中声明为 public 的方法在子类中也必须为 public。\n- 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。\n- 父类中声明为 private 的方法，不能够被继承。\n\n### 非访问修饰符\n\nstatic 修饰符，用来修饰类方法和类变量。\n\nfinal 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。\n\nabstract 修饰符，用来创建抽象类和抽象方法。\n\nsynchronized 和 volatile 修饰符，主要用于线程的编程。\n\n#### static 修饰符\n\n- **静态变量：**\n\n  static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。\n\n- **静态方法：**\n\n  static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。\n\n#### final 修饰符\n\n**final 变量：**\n\nfinal 表示\"最后的、最终的\"含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。\n\n**final 方法**\n\n父类中的 final 方法可以被子类继承，但是不能被子类重写。\n\n声明 final 方法的主要目的是防止该方法的内容被修改。\n\n**final 类**\n\nfinal 类不能被继承，没有类能够继承 final 类的任何特性。\n\n#### abstract 修饰符\n\n**抽象类：**\n\n抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。\n\n一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。\n\n**抽象方法**\n\n抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。\n\n抽象方法不能被声明成 final 和 static。\n\n任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。\n\n如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。\n\n抽象方法的声明以分号结尾，例如：**public abstract sample();**。\n\n#### synchronized 修饰符\n\nsynchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。\n\n#### transient 修饰符\n\n序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。\n\n该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。\n\n`public transient int limit = 55;   // 不会持久化 `\n\n`public int b; // 持久化`\n\n#### volatile 修饰符\n\nvolatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。\n\n一个 volatile 对象引用可能是 null。\n\n## Java 运算符\n\n### 算术运算符\n\n|  +   |     加法 - 相加运算符两侧的值     |           A + B 等于 30            |\n| :--: | :-------------------------------: | :--------------------------------: |\n|  -   |    减法 - 左操作数减去右操作数    |           A – B 等于 -10           |\n|  *   |     乘法 - 相乘操作符两侧的值     |            A * B等于200            |\n|  /   |    除法 - 左操作数除以右操作数    |            保留整数部分            |\n|  ％  | 取余 - 左操作数除以右操作数的余数 |              B%A等于0              |\n|  ++  |       自增: 操作数的值增加1       | B++ 或 ++B 等于 21（区别详见下文） |\n|  --  |       自减: 操作数的值减少1       | B-- 或 --B 等于 19（区别详见下文） |\n\n自增和自减前后缀区别：\n\n```cpp\nint i = 0;\nint x = ++i;//先+1再用\nint y = i++;//先用再加1\n//x=y=1,i=2\n```\n\n![](基础语法/5.png)![](基础语法/6.png)\n\n### 关系运算符\n\n| 运算符 |                             描述                             |       例子       |\n| :----: | :----------------------------------------------------------: | :--------------: |\n|   ==   |     检查如果两个操作数的值是否相等，如果相等则条件为真。     | （A == B）为假。 |\n|   !=   |   检查如果两个操作数的值是否相等，如果值不相等则条件为真。   | (A != B) 为真。  |\n|   >    |  检查左操作数的值是否大于右操作数的值，如果是那么条件为真。  |  （A> B）为假。  |\n|   <    |  检查左操作数的值是否小于右操作数的值，如果是那么条件为真。  |  （A <B）为真。  |\n|   >=   | 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 | （A> = B）为假。 |\n|   <=   | 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 | （A <= B）为真。 |\n\n### 位运算符\n\nJava定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。\n\n| 操作符 |                             描述                             |              例子              |\n| :----: | :----------------------------------------------------------: | :----------------------------: |\n|   ＆   |            如果相对应位都是1，则结果为1，否则为0             | （A＆B），得到12，即0000 1100  |\n|   \\|   |           如果相对应位都是 0，则结果为 0，否则为 1           | （A \\| B）得到61，即 0011 1101 |\n|   ^    |            如果相对应位值相同，则结果为0，否则为1            | （A ^ B）得到49，即 0011 0001  |\n|   〜   |     按位取反运算符翻转操作数的每一位，即0变成1，1变成0。     |  （〜A）得到-61，即1100 0011   |\n|   <<   |     按位左移运算符。左操作数按位左移右操作数指定的位数。     |  A << 2得到240，即 1111 0000   |\n|   >>   |     按位右移运算符。左操作数按位右移右操作数指定的位数。     |      A >> 2得到15即 1111       |\n|  >>>   | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 |     A>>>2得到15即0000 1111     |\n\n\\>> && \\>>>的区别\n\n![](基础语法/7.png)![](基础语法/8.png)\n\n前者高位补的是原来的值（即符号位）——算术右移（汇编中的概念）\n\n后者补0——逻辑右移（汇编中的概念）\n\n### 逻辑运算符\n\n| 操作符 |                             描述                             |        例子         |\n| :----: | :----------------------------------------------------------: | :-----------------: |\n|   &&   |   称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。   |  （A && B）为假。   |\n| \\| \\|  | 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 | （A \\| \\| B）为真。 |\n|   ！   | 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 | ！（A && B）为真。  |\n\n和C++，C一样也是短路计算，比如求a&&b，a，b均是表达式，当a的值为0，b的值就不会去计算。\n\n![](基础语法/9.png)\n\n输出a=0\n\n### 赋值运算符\n\n| 操作符  |                             描述                             |                   例子                   |\n| :-----: | :----------------------------------------------------------: | :--------------------------------------: |\n|    =    |        简单的赋值运算符，将右操作数的值赋给左侧操作数        |     C = A + B将把A + B得到的值赋给C      |\n|   + =   |   加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数   |          C + = A等价于C = C + A          |\n|   - =   |   减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数   |          C - = A等价于C = C - A          |\n|   * =   |   乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数   |          C * = A等价于C = C * A          |\n|   / =   |   除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数   | C / = A，C 与 A 同类型时等价于 C = C / A |\n| （％）= | 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 |           C％= A等价于C = C％A           |\n|  << =   |                       左移位赋值运算符                       |         C << = 2等价于C = C << 2         |\n|  >> =   |                       右移位赋值运算符                       |         C >> = 2等价于C = C >> 2         |\n|   ＆=   |                       按位与赋值运算符                       |           C＆= 2等价于C = C＆2           |\n|   ^ =   |                      按位异或赋值操作符                      |          C ^ = 2等价于C = C ^ 2          |\n|  \\| =   |                       按位或赋值操作符                       |         C \\| = 2等价于C = C \\| 2         |\n\n和C，C++一样\n\n### 条件运算符（?:）\n\n条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。\n\n```\nvariable x = (expression) ? value if true : value if false\n```\n\nC++中也有这种写法\n\n### instanceof 运算符\n\n该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。\n\n```\n( Object reference variable ) instanceof  (class/interface type)\n```\n\n如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。\n\n下面是一个例子：\n\n```\nString name = \"James\";\nboolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真\n```\n\n如果被比较的对象兼容于右侧类型,该运算符仍然返回true。\n\n```cpp\nclass Vehicle {}\n \npublic class Car extends Vehicle {\n   public static void main(String[] args){\n      Vehicle a = new Car();\n      boolean result =  a instanceof Car;\n      System.out.println( result);\n   }\n}\n```\n\n### Java运算符优先级\n\n|   类别   |                   操作符                   |  关联性  |\n| :------: | :----------------------------------------: | :------: |\n|   后缀   |             () [] . (点操作符)             |  左到右  |\n|   一元   |               expr++ expr--                | 从左到右 |\n|   一元   |          ++expr --expr + - ～ ！           | 从右到左 |\n|   乘性   |                   * /％                    |  左到右  |\n|   加性   |                    + -                     |  左到右  |\n|   移位   |                 >> >>>  <<                 |  左到右  |\n|   关系   |                 > >= < <=                  |  左到右  |\n|   相等   |                   == !=                    |  左到右  |\n|  按位与  |                     ＆                     |  左到右  |\n| 按位异或 |                     ^                      |  左到右  |\n|  按位或  |                     \\|                     |  左到右  |\n|  逻辑与  |                     &&                     |  左到右  |\n|  逻辑或  |                   \\| \\|                    |  左到右  |\n|   条件   |                    ？：                    | 从右到左 |\n|   赋值   | = + = - = * = / =％= >> = << =＆= ^ = \\| = | 从右到左 |\n|   逗号   |                     ，                     |  左到右  |\n\n关联性也就是C++中所谓的结合性\n\n## Java 循环结构 - for, while 及 do...while\n\n这块和C++几乎一样\n\n### while 循环\n\n```cpp\nwhile( 布尔表达式 ) {  //循环内容 }\n```\n\n### do…while 循环（至少执行一次循环）\n\n```cpp\ndo {\n       //代码语句\n}while(布尔表达式);\n```\n\n### for循环\n\n```cpp\nfor(初始化; 布尔表达式; 更新) {\n    //代码语句\n}\n```\n\n### Java 增强 for 循环（C++11也新增）\n\nC++中叫基于范围的循环，python中就是这种循环\n\n```cpp\nfor(声明语句 : 表达式)\n{\n   //代码句子\n}\n```\n\n**声明语句：**声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。\n\n**表达式：**表达式是要访问的数组名，或者是返回值为数组的方法。\n\n![](基础语法/10.png)![](基础语法/11.png)\n\n### break 关键字\n\nbreak 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。\n\nbreak 跳出最里层的循环，并且继续执行该循环下面的语句。\n\n### continue 关键字\n\ncontinue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。\n\n在 for 循环中，continue 语句使程序立即跳转到更新语句。\n\n在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。\n\n## Java 条件语句 - if...else\n\n### if\n\n\n\n语法：\n\n```cpp\nif(布尔表达式)\n{\n   //如果布尔表达式为true将执行的语句\n}\n```\n\n### if...else语句\n\n```cpp\nif(布尔表达式){\n   //如果布尔表达式的值为true\n}else{\n   //如果布尔表达式的值为false\n}\n```\n\n可嵌套，和C++一模一样\n\n## Java switch case 语句\n\nswitch case 语句语法格式如下：\n\n```java\nswitch(expression){\n    case value :\n       //语句\n       break; //可选\n    case value :\n       //语句\n       break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n       //语句\n}\n```\n\n## Java Number & Math 类\n\n一般地，当需要使用数字的时候，我们通常使用内置数据类型，如：**byte、int、long、double** 等。\n\n然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，Java 语言为每一个内置数据类型提供了对应的包装类。\n\n所有的包装类**（Integer、Long、Byte、Double、Float、Short）**都是抽象类 Number 的子类。\n\n|  包装类   | 基本数据类型 |\n| :-------: | :----------: |\n|  Boolean  |   boolean    |\n|   Byte    |     byte     |\n|   Short   |    short     |\n|  Integer  |     int      |\n|   Long    |     long     |\n| Character |     char     |\n|   Float   |    float     |\n|  Double   |    double    |\n\n![](基础语法/12.png)\n\n这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。\n\n```java\npublic class Test{\n \n   public static void main(String args[]){\n      Integer x = 5;\n      x =  x + 10;\n      System.out.println(x); \n   }\n}\n```\n\n当 x 被赋为整型值时，由于x是一个对象，所以编译器要对x进行装箱。然后，为了使x能进行加运算，所以要对x进行拆箱。\n\n## Java Math 类\n\nJava 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。\n\nMath 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。\n\n示例：\n\n```cpp\npublic class Test {  \n    public static void main (String []args)  \n    {  \n        System.out.println(\"90 度的正弦值：\" + Math.sin(Math.PI/2));  \n        System.out.println(\"0度的余弦值：\" + Math.cos(0));  \n        System.out.println(\"60度的正切值：\" + Math.tan(Math.PI/3));  \n        System.out.println(\"1的反正切值： \" + Math.atan(1));  \n        System.out.println(\"π/2的角度值：\" + Math.toDegrees(Math.PI/2));  \n        System.out.println(Math.PI);  \n    }  \n}\n```\n\n## Number & Math 类方法\n\n| 序号 | 方法与描述                                                   |\n| :--- | :----------------------------------------------------------- |\n| 1    | [xxxValue()](https://www.runoob.com/java/number-xxxvalue.html) 将 Number 对象转换为xxx数据类型的值并返回。 |\n| 2    | [compareTo()](https://www.runoob.com/java/number-compareto.html) 将number对象与参数比较。 |\n| 3    | [equals()](https://www.runoob.com/java/number-equals.html) 判断number对象是否与参数相等。 |\n| 4    | [valueOf()](https://www.runoob.com/java/number-valueof.html) 返回一个 Number 对象指定的内置数据类型 |\n| 5    | [toString()](https://www.runoob.com/java/number-tostring.html) 以字符串形式返回值。 |\n| 6    | [parseInt()](https://www.runoob.com/java/number-parseInt.html) 将字符串解析为int类型。 |\n| 7    | [abs()](https://www.runoob.com/java/number-abs.html) 返回参数的绝对值。 |\n| 8    | [ceil()](https://www.runoob.com/java/number-ceil.html) 返回大于等于( >= )给定参数的的最小整数，类型为双精度浮点型。 |\n| 9    | [floor()](https://www.runoob.com/java/number-floor.html) 返回小于等于（<=）给定参数的最大整数 。 |\n| 10   | [rint()](https://www.runoob.com/java/number-rint.html) 返回与参数最接近的整数。返回类型为double。 |\n| 11   | [round()](https://www.runoob.com/java/number-round.html) 它表示**四舍五入**，算法为 **Math.floor(x+0.5)**，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。 |\n| 12   | [min()](https://www.runoob.com/java/number-min.html) 返回两个参数中的最小值。 |\n| 13   | [max()](https://www.runoob.com/java/number-max.html) 返回两个参数中的最大值。 |\n| 14   | [exp()](https://www.runoob.com/java/number-exp.html) 返回自然数底数e的参数次方。 |\n| 15   | [log()](https://www.runoob.com/java/number-log.html) 返回参数的自然数底数的对数值。 |\n| 16   | [pow()](https://www.runoob.com/java/number-pow.html) 返回第一个参数的第二个参数次方。 |\n| 17   | [sqrt()](https://www.runoob.com/java/number-sqrt.html) 求参数的算术平方根。 |\n| 18   | [sin()](https://www.runoob.com/java/number-sin.html) 求指定double类型参数的正弦值。 |\n| 19   | [cos()](https://www.runoob.com/java/number-cos.html) 求指定double类型参数的余弦值。 |\n| 20   | [tan()](https://www.runoob.com/java/number-tan.html) 求指定double类型参数的正切值。 |\n| 21   | [asin()](https://www.runoob.com/java/number-asin.html) 求指定double类型参数的反正弦值。 |\n| 22   | [acos()](https://www.runoob.com/java/number-acos.html) 求指定double类型参数的反余弦值。 |\n| 23   | [atan()](https://www.runoob.com/java/number-atan.html) 求指定double类型参数的反正切值。 |\n| 24   | [atan2()](https://www.runoob.com/java/number-atan2.html) 将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。 |\n| 25   | [toDegrees()](https://www.runoob.com/java/number-todegrees.html) 将参数转化为角度。 |\n| 26   | [toRadians()](https://www.runoob.com/java/number-toradians.html) 将角度转换为弧度。 |\n| 27   | [random()](https://www.runoob.com/java/number-random.html) 返回一个随机数。 |\n\n## Java Character 类\n\nCharacter 类用于对单个字符进行操作。\n\nCharacter 类在对象中包装一个基本类型 **char** 的值\n\n### 转义序列\n\n| 转义序列 |           描述           |\n| :------: | :----------------------: |\n|    \\t    | 在文中该处插入一个tab键  |\n|    \\b    | 在文中该处插入一个后退键 |\n|    \\n    |      在文中该处换行      |\n|    \\r    |    在文中该处插入回车    |\n|    \\f    |   在文中该处插入换页符   |\n|    \\'    |   在文中该处插入单引号   |\n|    \\\"    |   在文中该处插入双引号   |\n|    \\\\    |   在文中该处插入反斜杠   |\n\n### Character 方法\n\nC++中是cctype头文件中的方法。\n\n| 序号 | 方法与描述                                      |\n| :--- | :---------------------------------------------- |\n| 1    | isLetter() 是否是一个字母                       |\n| 2    | isDigit()是否是一个数字字符                     |\n| 3    | isWhitespace()是否是一个空白字符                |\n| 4    | isUpperCase() 是否是大写字母                    |\n| 5    | isLowerCase()是否是小写字母                     |\n| 6    | toUpperCase() 指定字母的大写形式                |\n| 7    | toLowerCase() 指定字母的小写形式                |\n| 8    | toString返回字符的字符串形式，字符串的长度仅为1 |\n\n## Java String 类\n\n字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。\n\n### 创建字符串\n\nString 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：\n\n```java\nString s1 = \"Runoob\";              // String 直接创建\nString s2 = \"Runoob\";              // String 直接创建\nString s3 = s1;                    // 相同引用\nString s4 = new String(\"Runoob\");   // String 对象创建\nString s5 = new String(\"Runoob\");   // String 对象创建\n```\n\n![](基础语法/13.png)\n\n### 字符串长度\n\nString 类的一个访问器方法是 length() 方法，它返回字符串对象包含的字符数。\n\n！！！没有size方法，C++STL中有size和length\n\n### 连接字符串\n\nString 类提供了连接两个字符串的方法：\n\n+ 返回 string2 连接 string1 的新字符串。也可以对字符串常量使用 concat() 方法，如：\n\n+ 更常用的是使用'+'操作符来连接字符串\n\n![](基础语法/14.png)![](基础语法/15.png)\n\n### 创建格式化字符串\n\n我们知道输出格式化数字可以使用 printf() 和 format() 方法。\n\nString 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。\n\nString 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。\n\n### String 方法\n\n参看 [Java String API](https://www.runoob.com/manual/jdk1.6/java/lang/String.html) 文档:\n\n## Java StringBuffer 和 StringBuilder 类\n\n当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。\n\n和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。\n\n![](基础语法/16.png)\n\n在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。\n\nStringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。\n\n由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。\n\n![](基础语法/17.png)\n\n然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。\n\n### StringBuffer 方法\n\n| 序号 |                           方法描述                           |\n| :--: | :----------------------------------------------------------: |\n|  1   |                int capacity() 返回当前容量。                 |\n|  2   | char charAt(int index) 返回此序列中指定索引处的 `char` 值。  |\n|  3   | void ensureCapacity(int minimumCapacity) 确保容量至少等于指定的最小值。 |\n|  4   | void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 `dst`。 |\n|  5   | int indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。 |\n|  6   | int indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。 |\n|  7   | int lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。 |\n|  8   | int lastIndexOf(String str, int fromIndex) 返回 String 对象中子字符串最后出现的位置。 |\n|  9   |              int length()  返回长度（字符数）。              |\n|  10  | void setCharAt(int index, char ch) 将给定索引处的字符设置为 `ch`。 |\n|  11  |      void setLength(int newLength) 设置字符序列的长度。      |\n|  12  | CharSequence subSequence(int start, int end) 返回一个新的字符序列，该字符序列是此序列的子序列。 |\n|  13  | String substring(int start) 返回一个新的 `String`，它包含此字符序列当前所包含的字符子序列。 |\n|  14  | String substring(int start, int end) 返回一个新的 `String`，它包含此序列当前所包含的字符子序列。 |\n|  15  |     String toString() 返回此序列中数据的字符串表示形式。     |\n\n## Java 数组\n\n### 声明数组变量\n\n```cpp\ndataType[] arrayRefVar;   // 首选的方法\n \n或\n \ndataType arrayRefVar[];  // 效果相同，但不是首选方法 \n//dataType arrayRefVar[] 风格是来自 C/C++ 语言 ，在Java中采用是为了让 C/C++ 程序员能够快速理解java语言。\n```\n\n### 创建数组\n\nJava语言使用new操作符来创建数组，语法如下：\n\n`arrayRefVar = new dataType[arraySize];`\n\n上面的语法语句做了两件事：\n\n- 一、使用 dataType[arraySize] 创建了一个数组。\n- 二、把新创建的数组的引用赋值给变量 arrayRefVar。\n\n可以理解成返回的是指针，C/C++中就有这种概念。\n\n### 数组作为函数的参数\n\n```cpp\npublic static void printArray(int[] array) {\n  for (int i = 0; i < array.length; i++) {\n    System.out.print(array[i] + \" \");\n  }\n}\n```\n\n### 数组作为函数的返回值\n\n```cpp\npublic static int[] reverse(int[] list) {\n  int[] result = new int[list.length];\n \n  for (int i = 0, j = result.length - 1; i < list.length; i++, j--) {\n    result[j] = list[i];\n  }\n  return result;\n}\n```\n\n实际本质是在堆盛情内存空间之后，返回的是引用，也就是数组在堆内存中的位置。\n\n### 多维数组\n\n多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组，例如：\n\n`String str[][] = new String[3][4];`\n\n### Arrays 类\n\njava.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。\n\n具有以下功能：\n\n- 给数组赋值：通过 fill 方法。\n- 对数组排序：通过 sort 方法,按升序。\n- 比较数组：通过 equals 方法比较数组中元素值是否相等。\n- 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。\n\n| 序号 | 方法和说明                                                   |\n| :--: | :----------------------------------------------------------- |\n|  1   | **public static int binarySearch(Object[] a, Object key)** 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(*插入点*) - 1)。 |\n|  2   | **public static boolean equals(long[] a, long[] a2)** 如果两个指定的 long 型数组彼此*相等*，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |\n|  3   | **public static void fill(int[] a, int val)** 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |\n|  4   | **public static void sort(Object[] a)** 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |\n\n## Java 日期时间\n\njava.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。\n\n第一个构造函数使用当前日期和时间来初始化对象。\n\n第一个构造函数使用当前日期和时间来初始化对象。`Date( )`\n\n第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。`Date(long millisec)`\n\n| 序号 | 方法和描述                                                   |\n| :--- | :----------------------------------------------------------- |\n| 1    | **boolean after(Date date)** 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。 |\n| 2    | **boolean before(Date date)** 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。 |\n| 3    | **Object clone( )** 返回此对象的副本。                       |\n| 4    | **int compareTo(Date date)** 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。 |\n| 5    | **int compareTo(Object obj)** 若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。 |\n| 6    | **boolean equals(Object date)** 当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。 |\n| 7    | **long getTime( )** 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 |\n| 8    | **int hashCode( )**  返回此对象的哈希码值。                  |\n| 9    | **void setTime(long time)**   用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。 |\n| 10   | **String toString( )** 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。 |\n\n### 获取当前日期时间\n\n![](基础语法/18.png)![](基础语法/19.png)\n\n### 日期比较\n\nJava使用以下三种方法来比较两个日期：\n\n- 使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。\n- 使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。\n- 使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。\n\n### 使用 SimpleDateFormat 格式化日期\n\nSimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如：\n\n`SimpleDateFormat ft = new SimpleDateFormat (\"yyyy-MM-dd hh:mm:ss\");`\n\n这一行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。\n\n**注意**:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。\n\n![](基础语法/20.png)![](基础语法/21.png)\n\n### 解析字符串为时间\n\nSimpleDateFormat 类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat 对象的格式化存储来解析字符串。例如：\n\n```java\nimport java.util.*;\nimport java.text.*;\n  \npublic class DateDemo {\n \n   public static void main(String args[]) {\n      SimpleDateFormat ft = new SimpleDateFormat (\"yyyy-MM-dd\"); \n \n      String input = args.length == 0 ? \"1818-11-11\" : args[0]; \n \n      System.out.print(input + \" Parses as \"); \n \n      Date t; \n \n      try { \n          t = ft.parse(input); \n          System.out.println(t); \n      } catch (ParseException e) { \n          System.out.println(\"Unparseable using \" + ft); \n      }\n   }\n}\n```\n\n### Java 休眠(sleep)\n\nsleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。\n\n你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。\n\n### Calendar类\n\n我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用Calendar 类。\n\nCalendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。\n\nCalendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。\n\n### GregorianCalendar类\n\nCalendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。\n\nCalendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。\n\n## Java 正则表达式\n\nava 正则表达式和 Perl 的是最为相似的。\n\njava.util.regex 包主要包括以下三个类：\n\n- Pattern 类：\n\n  pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。\n\n- Matcher 类：\n\n  Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。\n\n- PatternSyntaxException：\n\n  PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。\n\n  \n\n## Java 方法\n\n### 方法的定义\n\n```java\n修饰符 返回值类型 方法名(参数类型 参数名){\n    ...\n    方法体\n    ...\n    return 返回值;\n}\n```\n\n- **修饰符：**修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。\n- **返回值类型 ：**方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字**void**。\n- **方法名：**是方法的实际名称。方法名和参数表共同构成方法签名。\n- **参数类型：**参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。\n- **方法体：**方法体包含具体的语句，定义该方法的功能。\n\n### 方法的重载\n\n就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。\n\nJava编译器根据方法签名判断哪个方法应该被调用。\n\n方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。\n\n重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。\n\n### 构造方法\n\n当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。\n\n不管你是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，默认构造方法的访问修改符和类的访问修改符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。\n\n一旦你定义了自己的构造方法，默认构造方法就会失效。\n\n### 可变参数\n\nJDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。\n\n方法的可变参数的声明如下所示：\n\n`typeName... parameterName`\n\n在方法声明中，在指定参数类型后加一个省略号(...) 。\n\n一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。\n\n### finalize() 方法\n\nJava 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。\n\n例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。\n\n在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。\n\nfinalize() 一般格式是：\n\n```java\nprotected void finalize()\n{\n   // 在这里终结代码\n}\n```\n\n关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。\n\n当然，Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法。\n\n## Java 流(Stream)、文件(File)和IO\n\n### 读取控制台输入\n\nJava 的控制台输入由 System.in 完成。\n\n为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。\n\n下面是创建 BufferedReader 的基本语法：\n\n```java\nBufferedReader br = new BufferedReader(new \n                      InputStreamReader(System.in));\n```\n\nBufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。\n\n### 读写文件\n\n如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。\n\n下图是一个描述输入流和输出流的类层次图。\n\n![](基础语法/22.png)\n\n### FileInputStream\n\n该流用于从文件读取数据，它的对象可以用关键字 new 来创建。\n\n有多种构造方法可用来创建对象。\n\n可以使用字符串类型的文件名来创建一个输入流对象来读取文件：\n\n```\nInputStream f = new FileInputStream(\"C:/java/hello\");\n```\n\n也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：\n\n```\nFile f = new File(\"C:/java/hello\"); InputStream out = new FileInputStream(f);\n```\n\n| **序号** | **方法及描述**                                               |\n| :------- | :----------------------------------------------------------- |\n| 1        | **public void close() throws IOException{}** 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。 |\n| 2        | **protected void finalize()throws IOException {}** 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。 |\n| 3        | **public int read(int r)throws IOException{}** 这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。 |\n| 4        | **public int read(byte[] r) throws IOException{}** 这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。 |\n| 5        | **public int available() throws IOException{}** 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。 |\n\n### FileOutputStream\n\n该类用来创建一个文件并向文件中写数据。\n\n如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。\n\n有两个构造方法可以用来创建 FileOutputStream 对象。\n\n使用字符串类型的文件名来创建一个输出流对象：\n\n```\nOutputStream f = new FileOutputStream(\"C:/java/hello\")\n```\n\n也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：\n\n```\nFile f = new File(\"C:/java/hello\"); OutputStream f = new FileOutputStream(f);\n```\n\n### Java中的目录\n\n#### 创建目录：\n\nFile类中有两个方法可以用来创建文件夹：\n\n- **mkdir( )**方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。\n- **mkdirs()**方法创建一个文件夹和它的所有父文件夹。\n\n### 读取目录\n\n一个目录其实就是一个 File 对象，它包含其他文件和文件夹。\n\n如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。\n\n可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。\n\n删除文件可以使用 **java.io.File.delete()** 方法。\n\n### 删除目录或文件\n\n需要注意的是当删除某一目录时，必须保证该目录下没有其他文件才能正确删除，否则将删除失败。\n\n## Java Scanner 类\n\njava.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。\n\n下面是创建 Scanner 对象的基本语法：\n\n```\nScanner s = new Scanner(System.in);\n```\n\n通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据：\n\n#### next() 与 nextLine() 区别\n\nnext():\n\n- 1、一定要读取到有效字符后才可以结束输入。\n- 2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。\n- 3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。\n- next() 不能得到带有空格的字符串。\n\nnextLine()：\n\n- 1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。\n- 2、可以获得空白。\n\n## Java 异常处理\n\n异常发生的原因有很多，通常包含以下几大类：\n\n- 用户输入了非法数据。\n- 要打开的文件不存在。\n- 网络通信时连接中断，或者JVM内存溢出。\n\n这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。-\n\n要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：\n\n- **检查性异常：**最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。\n- **运行时异常：** 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。\n- **错误：** 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。\n\n### Exception 类的层次\n\n所有的异常类是从 java.lang.Exception 类继承的子类。\n\nException 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。\n\nJava 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。\n\nError 用来指示运行时环境发生的错误。\n\n例如，JVM 内存溢出。一般地，程序不会从错误中恢复。\n\n异常类有两个主要的子类：IOException 类和 RuntimeException 类。\n\n![](基础语法/23.jpg)\n\n### Java 内置异常类\n\nJava 语言定义了一些异常类在 java.lang 标准包中。\n\n标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。\n\nJava 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常。\n\n### 异常方法\n\n下面的列表是 Throwable 类的主要方法:\n\n| **序号** | **方法及说明**                                               |\n| :------- | :----------------------------------------------------------- |\n| 1        | **public String getMessage()** 返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。 |\n| 2        | **public Throwable getCause()** 返回一个Throwable 对象代表异常原因。 |\n| 3        | **public String toString()** 使用getMessage()的结果返回类的串级名字。 |\n| 4        | **public void printStackTrace()** 打印toString()结果和栈层次到System.err，即错误输出流。 |\n| 5        | **public StackTraceElement [] getStackTrace()** 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。 |\n| 6        | **public Throwable fillInStackTrace()** 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。 |\n\n### 捕获异常\n\n使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。\n\ntry/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：\n\n```\ntry\n{\n   // 程序代码\n}catch(ExceptionName e1)\n{\n   //Catch 块\n}\n```\n\n### 多重捕获块\n\n一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。\n\n```java\ntry{\n   // 程序代码\n}catch(异常类型1 异常的变量名1){\n  // 程序代码\n}catch(异常类型2 异常的变量名2){\n  // 程序代码\n}catch(异常类型3 异常的变量名3){\n  // 程序代码\n}\n```\n\n### throws/throw 关键字：\n\n如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。\n\n也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。\n\n下面方法的声明抛出一个 RemoteException 异常：\n\n```java\nimport java.io.*;\npublic class className\n{\n  public void deposit(double amount) throws RemoteException\n  {\n    // Method implementation\n    throw new RemoteException();\n  }\n  //Remainder of class definition\n}\n```\n\n下面的例子中声明有两个元素的一个数组，当代码试图访问数组的第三个元素的时候就会抛出一个异常。\n\n### finally关键字\n\nfinally 关键字用来创建在 try 代码块后面执行的代码块。\n\n无论是否发生异常，finally 代码块中的代码总会被执行。\n\n在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。\n\nfinally 代码块出现在 catch 代码块最后，语法如下:\n\n```java\ntry{\n  // 程序代码\n}catch(异常类型1 异常的变量名1){\n  // 程序代码\n}catch(异常类型2 异常的变量名2){\n  // 程序代码\n}finally{\n  // 程序代码\n}\n```\n\n- catch 不能独立于 try 存在。\n- 在 try/catch 后面添加 finally 块并非强制性要求的。\n- try 代码后不能既没 catch 块也没 finally 块。\n- try, catch, finally 块之间不能添加任何代码。\n\n### 声明自定义异常\n\n在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。\n\n- 所有异常都必须是 Throwable 的子类。\n- 如果希望写一个检查性异常类，则需要继承 Exception 类。\n- 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。\n\n### 通用异常\n\n在Java中定义了两种类型的异常和错误。\n\n- **JVM(Java****虚拟机****)** **异常：**由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。\n- **程序级异常：**由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。","tags":["第一阶段","JAVA基础"],"categories":["第一阶段"]}]