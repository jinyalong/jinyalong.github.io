[{"title":"MySQL","url":"/2021/02/17/MySQL/","content":"\n## 1、概述及准备工作\n\n数据库（DB，DateBase）\n\n概念：安装在操作系统（Windows，Linux，Mac...）上的软件，用于存储和管理数据。\n\n> 数据库分类\n\n**关系型数据库：**（SQL）\n\n+ MySQL，Oracle，Sql Server，DB2，SQLlite\n+ 通过表和表之间，行和列之间关系进行数据的存储。\n\n**非关系型数据库：**（NoSQL）——Not Only\n\n+ Redis，MongDB\n+ 以对象存储，通过对象自身的属性来决定。\n\n> DBMS（数据库管理系统）\n\n+ 数据库的管理软件，科学有效的管理数据，维护和获取数据。\n+ MySQL本质就是一个数据库管理系统！\n\n![image-20210210132615008](MySQL/image-20210210132615008.png)\n\n> MySQL简介\n\n![image-20210210132719212](MySQL/image-20210210132719212.png)\n\n官网：https://www.mysql.com\n\n5.7：稳定版\n\n> 压缩包版MySQL安装5.7\n\n压缩包下载地址：https://dev.mysql.com/downloads/mysql/5.7.html\n\n1、官网下载压缩包，并解压到相关目录\n\n2、配置环境变量：`此电脑-右键属性-高级系统设置-环境变量`，`Path`目录新增Mysql压缩包bin目录的路径\n\n![image-20210210141411892](MySQL/image-20210210141411892.png)\n\n3、在MySQL目录下新建`my.ini`配置文件\n\n```ini\n[mysqld]  \n#第一个为Mysql解压目录\nbasedir=D:\\Environment\\mysql-5.7.33\\\n#第二个为data目录，无需自己新建！！！会自动生成\ndatadir=D:\\Environment\\mysql-5.7.33\\data\\\nport=3306\n#第一次登录跳过密码\nskip-grant-tables\n```\n\n4、**管理员模式**启动`CMD`，切换到MySQL目录下的`bin`目录，执行指令`mysqld install `，可能会提示缺少`dll`文件安装失败，需要到微软官网下载一个插件！\n\n![在这里插入图片描述](MySQL/20200618113646466.png)\n\n**下载 vcredist 地址：**https://www.microsoft.com/zh-CN/download/details.aspx?id=40784\n\n![image-20210210141900322](MySQL/image-20210210141900322.png)\n\n5、初始化，会创建`data`文件夹。执行指令`mysqld --initialize-insecure --user=mysql`\n\n6、执行指令`net start mysql`启动mysql服务\n\n![image-20210210142049821](MySQL/image-20210210142049821.png)\n\n7、执行指令`mysql -u root -p`登入mysql，由于之前的设置是不需要密码就直接登录的，看到输入密码的提示直接回车即可。然后命令行提示变成`mysql>`即为成功了。\n\n8、执行命令修改密码：\n\n```shell\nupdate mysql.user set authentication_string=password('123456') where user='root' and Host = 'localhost';\n```\n\n9、 `flush privileges;`刷新权限，然后把`my.ini`中最后一行跳过密码验证删除。(`skip-grant-tables`)\n\n10、停止mysql服务的命令`net stop mysql`；\n\n![image-20210210143321098](MySQL/image-20210210143321098.png)\n\n>安装SQLyog\n\n命令行操作数据库不直观，因此下载一些可视化软件，在此我使用了MySQLyog\n\n官网：https://store.webyog.com/product/sqlyogpricing\n\n网上嫖注册码~~~\n\n## 2、操作数据库\n\n### 2.1、基础命令\n\n> 连接数据库\n\n命令行连接：\n\n```sql\nmysql -uroot -p123456\t--连接数据库\nupdate mysql.user set authentication_string=password('123456') where user='root' and Host = 'localhost';\t--修改密码\nflush privileges;\t--刷新权限\n----------------------------------------\nshow databases;\t\t--\t查看所有数据库\n\nmysql> use school;\nDatabase changed\t-- \t切换数据库命令——use 数据库名\nshow tables;\t\t--\t查看数据库中所有的表\ndescribe student;\t--\t显示表的详细信息\n\nmysql> describe student;\n+-------+--------------+------+-----+---------+-------+\n| Field | Type         | Null | Key | Default | Extra |\n+-------+--------------+------+-----+---------+-------+\n| id    | int(10)      | NO   | PRI | NULL    |       |\n| name  | varchar(100) | NO   |     | NULL    |       |\n| age   | int(3)       | NO   |     | NULL    |       |\n+-------+--------------+------+-----+---------+-------+\n3 rows in set (0.00 sec)\n\ncreate database 名字;\t--\t创建数据库\nexit;\t\t--\t退出连接\nsql的单行注释：\t--\nsql的多行注释：\t/**/\n```\n\n> 数据库语言分类\n\n**数据库xxx语言**\n\n**DDL——定义**\n\n**DML——操作，管理**\n\n**DQL——查询**\n\n**DCL——控制**\n\n### 2.2、数据库的列类型\n\n> 数值\n\n+ tinyint\t          1个字节\n+ smallint           2个字节\n+ mediumint      3个字节\n+ **int 标准的整数 4个字节**\n+ bigint                 8个字节\n\n+ float   浮点数     4字节\n+ double               8字节\n+ decimal 字符串形式浮点数     金融计算的时候一般用精确的decimal\n\n> 字符串\n\n+ char\t\t字符串固定大小，0-255，\n\n+ **varchar  可变字符串  0-65535**  \n+ tinytext   微型文本   2^8-1\n+ **text          文本串       2^16-1  保存大文本。**\n\n> 时间日期\n\n+ date\tYYYY-MM-DD    日期格式\n+ time    HH:mm:ss    时间格式\n+ **datetime    YYYY-MM-DD HH:mm:ss    最常用的时间格式**\n+ **timestamp    时间戳，1970-01-01到现在的毫秒数。**\n+ year    年份表示\n\n> null\n\n+ 没有值，未知\n+ **注意：不要使用null值进行运算。**\n\n### 2.3、数据库的字段属性\n\n>Unsigned\n\n+ Unsigned：无符号的整数\n+ 不能声明为负数\n\n> zerofill\n\n+ 0填充的\n+ 不足的位数使用0填充\n\n> 自增\n\n+ 自动在上一条记录的基础上加1\n+ 通常用来设计唯一的逐渐，必须是整数类型\n+ 可以自定义设计主键的开始值和步长\n\n> 非空 NULL NOT NULL\n\n+ NULL表示该字段必须赋值，否则报错\n\n> 默认 default\n\n+ 设置默认值\n\n> 规范（拓展）\n\n每个数据表必须包含以下五个字段：\n\n```sql\nid\t主键\nversion\t用于做乐观锁\nis_delete\t伪删除\ngmt_create\t创建时间\ngmt_update\t修改时间\n```\n\n### 2.4、创建表\n\n```sql\n-- 学会表\n-- id,name,pwd,sex,birth,address,email\nCREATE TABLE IF NOT EXISTS `student`(\n    `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT '学号',\n    `name` VARCHAR(30) NOT NULL DEFAULT '匿名' COMMENT '姓名',\n    `pwd` VARCHAR(32) NOT NULL DEFAULT '123456' COMMENT '密码',\n    `sex` VARCHAR(2) NOT NULL DEFAULT '男' COMMENT '性别',\n    `birth` DATETIME DEFAULT NULL COMMENT '出生日期',\n    `address` VARCHAR(100) DEFAULT NULL COMMENT '地址',\n    `email` VARCHAR(50) DEFAULT NULL COMMENT '邮件',\n    PRIMARY KEY (`id`) \n)ENGINE=INNODB DEFAULT CHARSET=`student`utf8\n\n```\n\n**格式：**\n\n```sql\nCREATE TABLE [IF NOT EXISTS] `表名称`(\n    `字段名` 列类型 [属性] [索引] [注释],\n    `字段名` 列类型 [属性] [索引] [注释],\n    ......\n    `字段名` 列类型 [属性] [索引] [注释]\n)[表类型][字符集设置][表注释]    \n```\n\n常用命令：\n\n```sql\nSHOW CREATE DATABASE school -- CREATE DATABASE `school` /*!40100 DEFAULT CHARACTER SET utf8 */\n-- 查看创建数据库的sql\nSHOW CREATE TABLE student  \n/*\nCREATE TABLE `student` (\n  `id` int(4) NOT NULL AUTO_INCREMENT COMMENT '学号',\n  `name` varchar(30) NOT NULL DEFAULT '匿名' COMMENT '姓名',\n  `pwd` varchar(32) NOT NULL DEFAULT '123456' COMMENT '密码',\n  `sex` varchar(2) NOT NULL DEFAULT '男' COMMENT '性别',\n  `birth` datetime DEFAULT NULL COMMENT '出生日期',\n  `address` varchar(100) DEFAULT NULL COMMENT '地址',\n  `email` varchar(50) DEFAULT NULL COMMENT '邮件',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n*/ \n\nDESCRIBE student\n```\n\n### 2.5、数据表的类型\n\n**数据库引擎：**\n\nINNODB\t默认使用\n\nMYISAM\t早些年使用\n\n|            | MYISAM |     INNODB     |\n| ---------- | :----: | :------------: |\n| 事务支持   | 不支持 |      支持      |\n| 数据行锁定 | 不支持 |      支持      |\n| 外检约束   | 不支持 |      支持      |\n| 全文索引   |  支持  |     不支持     |\n| 表空间大小 |  较小  | 较大，约为两倍 |\n\n常规使用操作：\n\n+ MYISAM：\t节约空间，速度较快\n+ INNODB：    安全性高，支持外键，可以多表多用户操作\n\n> 在物理空间存在的位置\n\n所有数据库文件都存在data目录下，一个文件夹对应一个数据库，本质还是文件存储。\n\nMySQL引擎在物理文件上的区别：\n\n+ INNODB在数据库表中只有一个*.frm文件，以及上级目录下的ibdata1文件\n+ MYISAM对应的文件\n  + *.frm      -表结构的定义文件\n  + *.MYD    -数据文件\n  + *.MYI      -索引文件\n\n> 数据库表的字符集编码\n\n```sql\nCHARSET=utf8\n```\n\n不设置的话，会是mysql默认的编码，不支持中文。\n\n### 2.6、修改和删除表\n\n> 修改\n\n```sql\nALTER TABLE 旧表名 RENAME AS 新表名\t--修改表名\n\nALTER TABLE 表名 ADD 字段名 字段列属性\t\t\t--增加字段\n\nALTER TABLE 表名 MODIFY 字段名 字段新属性\t\t\t--修改字段的约束\n\nALTER TABLE 表名 CHANGE 旧字段名 新字段名 属性\t\t--重命名字段\n\nALTER TABLE 表名 DROP 字段名\t\t\t\t\t\t--删除表的字段\n\n```\n\n> 删除\n\n```sql\nDROP TABLE IF EXISTS 表名\t\t\t\t\t\t--删除表，加条件判断是否存在\n```\n\n所有创建和删除尽量加上条件判断，以免报错。\n\n## 3、MySQL数据管理\n\n### 3.1、外键\n\n> 创建表时设置外键\n\n```sql\nCREATE TABLE `grade`(\n    `gradeid` INT(2) NOT NULL COMMENT '年级id',\n    `gradename` VARCHAR(20) NOT NULL COMMENT '年级',\n    PRIMARY KEY (`gradeid`)\n)ENGINE=INNODB DEFAULT CHARSET=utf8\n\n\n\nCREATE TABLE `student` (\n  `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT '学号',\n  `name` VARCHAR(30) NOT NULL DEFAULT '匿名' COMMENT '姓名',\n  `pwd` VARCHAR(32) NOT NULL DEFAULT '123456' COMMENT '密码',\n  `sex` VARCHAR(2) NOT NULL DEFAULT '男' COMMENT '性别',\n  `birth` DATETIME DEFAULT NULL COMMENT '出生日期',\n  `address` VARCHAR(100) DEFAULT NULL COMMENT '地址',\n  `email` VARCHAR(50) DEFAULT NULL COMMENT '邮件',\n  `gradeid` INT(2) NOT NULL COMMENT '学生的年级',\n  PRIMARY KEY (`id`),\n  KEY `FK_gradeid` (`gradeid`),\n  CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade`(`gradeid`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8\n-- 定义外键\n-- 约束外键 引用到其他数据表的其他列\n```\n\n> 表存在后设置外键\n\n```sql\nCREATE TABLE `grade`(\n    `gradeid` INT(2) NOT NULL COMMENT '年级id',\n    `gradename` VARCHAR(20) NOT NULL COMMENT '年级',\n    PRIMARY KEY (`gradeid`)\n)ENGINE=INNODB DEFAULT CHARSET=utf8\n\nSHOW CREATE TABLE student\n\nCREATE TABLE `student` (\n  `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT '学号',\n  `name` VARCHAR(30) NOT NULL DEFAULT '匿名' COMMENT '姓名',\n  `pwd` VARCHAR(32) NOT NULL DEFAULT '123456' COMMENT '密码',\n  `sex` VARCHAR(2) NOT NULL DEFAULT '男' COMMENT '性别',\n  `birth` DATETIME DEFAULT NULL COMMENT '出生日期',\n  `address` VARCHAR(100) DEFAULT NULL COMMENT '地址',\n  `email` VARCHAR(50) DEFAULT NULL COMMENT '邮件',\n  `gradeid` INT(2) NOT NULL COMMENT '学生的年级',\n    PRIMARY KEY(`id`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8\n-- 定义外键\n-- 约束外键 引用到其他数据表的其他列\n\nALTER TABLE `student`\nADD CONSTRAINT `FK_gradeid` FOREIGN KEY(`gradeid`) REFERENCES grade(`gradeid`)\n\n\n-- ALTER TABLE `表名` ADD CONSTRAINT 外键名 FOREIGN KEY(主表字段名) REFERENCES 从表名(从表字段)\n```\n\n**总结：**\n\n当有数据库级别外键存在时，若要删除从表，必须先删除主表。\n\n### 3.2、DML语言\n\n**数据库=数据存储+数据管理**\n\n**DML语言**：数据操作语言\n\n+ insert\n\n+ update\n+ delete\n\n### 3.3、添加\n\n```sql\nINSERT INTO 表名([字段1，字段2，...]) VALUES('值1'，'值2'...)\n-- 如果省略的字段，会自动从第一个开始匹配\n插入多行时用()包起来每一行的值！\n```\n\n### 3.4、修改\n\n语法：\n\n```sql\nUPDATE 表名 set 列名=value,[列名=value,...] WHERE [条件]\n注意：\n列名是数据库的列，尽量加上``\n条件，筛选的条件，可以使用运算符\nvalue可以是一个具体的值也可以是一个变量\n```\n\n> 条件运算符\n\n| 操作符           | 含义               |\n| ---------------- | ------------------ |\n| =                | 条件等于具体的值   |\n| <>或!=           | 不等于             |\n| >                | 大于               |\n| <                | 小于               |\n| >=               | 大于等于           |\n| <=               | 小于等于           |\n| BETWEEM...AND... | 条件的值在某个区间 |\n| AND              | 多个条件同时满足   |\n| OR               | 条件选择           |\n\n\n\n### 3.5、删除\n\n> delete\n\n```sql\nDELETE FROM `表名` [WHERE 条件]\n-- 不加条件时全部删除\n```\n\n> truncate\n\n```sql\nTRUNCATE 表名-- 清空表\n```\n\n> 区别\n\n+ TRUNCATE重新设置自增列，计数器归零\n+ TRUNCATE不会影响事务\n\n`DELETE删除的问题`，重启数据库，现象\n\n+ INNODB：自增列从1开始，存在内存中\n+ MYISAM：继续从上一个自增量开始，存在文件中\n\n## 4、DQL查询数据\n\n（Data Query Language-数据查询语言）\n\n> SELECT语法：\n\n![image-20210215140103536](MySQL/image-20210215140103536.png)\n\n### 4.1、指定查询字段\n\n```sql\n-- 查询整个表\nSELECT * FROM 表名\n\n-- 查询指定的字段\nSELECT '字段1','字段2'... FROM 表名\n\n-- 别名，给结果起一个新名字 AS\nSELECT `字段1` AS 新字段名,'字段2' AS ‘新字段名’ FROM 表名 AS 新表名\n\n-- 函数 Concat(a,b)\nSELECT CONCAT('字段注释',字段名) AS 新字段名 FROM 表名\n```\n\n> distinct\n\n作用：去除SELECT查询结果中重复的数据，重复数据只显示一条\n\n```sql\nSELECT DISTINCT `字段名` FROM `表名` --去重\n```\n\n> 数据库的列（表达式）\n\n```sql\nSELECT VERSION() -- 查询数据库版本\nSELECT @@auto_increment_increment -- 查询自增量\nSELECT `列名`+1 AS `提分后` FROM `表名` -- 数据库列字段值+1\nSELECT 100*2 AS 计算结果 -- 用来计算表达式\n\n```\n\n### 4.2、where条件字句\n\n**作用：检索数据中符合条件的值**，结果为布尔值\n\n> 逻辑运算符\n\n+ and    &&\n+ or      ||\n+ Not    !\n\n> 模糊查询：比较运算符\n\n+ IS NULL——为空 \n+ IS NOT NULL——不为空\n+ BETWEEN...AND——在区间中\n+ LIKE——`a like b`，SQL匹配，如果a匹配b，则结果为真，配合`%`和`_`，`%`匹配多个，`_`匹配一个字\n+ IN——`a in（a1,a2,a3...）`——假设a是（a1,a2,a3...）其中一个则为真\n\n### 4.3、联表查询\n\n> JOIN对比\n\n![img](MySQL/sql-join.png)\n\n**实际上两个表的字段有重复的，然后通过这个重复的字段去查询两个表中的数据来合成一个表。同时在选择重复字段时，必须确定这个字段选用哪个表的。**\n\n+ left join：查询左表中有的所有值并合并右表\n+ inner join：查询两个表都有的字段，交集\n+ right join：查询右表所有，把左表综合进去\n\n> 自连接\n\n自己的表和自己表连接，核心：一张表看做两张一样的表。\n\n自连接是指使用表的别名实现表与其自身连接的查询方法。\n\n假设在【成绩表】有【主键ID】【学生姓名】【课程名称】【成绩】等字段。\n\n![img](MySQL/20190514105101377.png)\n现在要查询 “语文成绩>=数学成绩”的学生姓名，这时就可以使用自连接查询：\n\n```sql\nselect 【学生姓名】\nfrom 【成绩表】 AS a,【成绩表】 AS b\nwhere a.【主键ID】=b.【主键ID】\nand a.【成绩】>=b.【成绩】\nand a.【课程名称】='语文'\nand b.【课程名称】='数学'\n```\n\n### 4.4、分页和排序\n\n> 排序\n\n```sql\n-- 升序ASC，降序DESC\nORDER BY 排序的字段 ASC/DESC\n```\n\n> 分页\n\n ```sql\n语法：limit 起始值，页面大小--从0开始\n ```\n\n### 4.5、子查询\n\nwhere（计算出来的值）\n\n本质：在where语句中嵌套一个子查询语句。还可以嵌套查询。\n\n## 5、MySQL函数\n\n### 5.1、常用函数\n\n```sql\n-- 数值类：\nSELECT ABS(-1)\t-- 绝对值\nSELECT CEILING(5.5) -- 向上取整\nSELECT FLOOR(5.5) -- 向下取整\nSELECT RAND() -- 0~1之间的随机数\nSELECT SIGN(0) -- 判断一个数的符号，0-0,负数：-1,正数：1\n\n-- 字符串类：\nSELECT CHAR_LENGTH('codefriday') -- 字符串长度\n\nSELECT NOW() -- 系统时间\nSELECT LOCALTIME() -- 本地时间\n\n```\n\n### 5.2、聚合函数\n\n| 函数名称    | 描述                                                         |\n| ----------- | ------------------------------------------------------------ |\n| COUNT(字段) | 查询记录的条数，忽略null，count(*),count(1)都是计算行数，不忽略null |\n| SUM()       | 求和                                                         |\n| AVG()       | 平均值                                                       |\n| MAX()       | 最大值                                                       |\n| MIN()       | 最小值                                                       |\n\n> 分数过滤\n\n```sql\nGROUP BY ... -- 指定结果按照哪几个字段分组\nHAVING ...   -- 过滤分组的记录必须满足的次要条件\n```\n\n### 5.3、数据库级别的MD5加密\n\n**MD5信息摘要算法**（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，主要增强算法复杂度和不可逆性。\n\nMD5破解原理只是收录了很多加密后的MD5字符串当做字典。\n\n直接使用`MD5()`函数，由于不可逆性，校验时传入的明文密码先经过MD5再比对。\n\n## 6、事务\n\n### 6.1、事务定义\n\n**要么都成功，要么都失败**，一组SQL必须一起执行完，不能被打断！\n\n> 事务的ACID原则——原子性，一致性，隔离性，持久性\n\n**事务的原子性(Atomicity)：**是指一个事务要么全部执行，要么不执行，也就是说一个事务不可能只执行了一半就停止了。比如你从取款机取钱，这个事务可以分成两个步骤：1划卡，2出钱。不可能划了卡，而钱却没出来。这两步必须同时完成，要么就不完成。\n\n**事务的一致性(Consistency)：**是指事务的运行并不改变数据库中数据的一致性。例如，完整性约束了a+b=10，一个事务改变了a，那么b也应该随之改变。\n\n**独立性(Isolation）：**事务的独立性也称作隔离性，是指两个以上的事务不会出现交错执行的状态。因为这样可能会导致数据不一致，更加具体的来讲，就是事务之间的操作是独立的。\n\n**持久性(Durability）：**事务的持久性是指事务执行成功以后，该事务对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚。\n\n> 隔离级别\n\n**脏读：**一个事务读取了另外一个事务未提交的数据。\n\n**不可重复读：**在一个事务内读取一个表，多次读取结果不同！\n\n**虚读（幻读）：**是指一个事务读取到了别的事务插入的数据，导致前后读取不一致（一般是行影响）\n\n### 6.2、执行事务\n\n```sql\n-- MYSQL默认自动提交事务。\nSET autocommit = 0 -- 关闭自动提交\nSET autocommit = 1 -- 开启自动提交，默认开启的\n\n\n-- 流程：\nSET autocommit = 0; -- 关闭自动提交\nSTART TRANSACTION -- 开启一个事务\nINSERT xxx\nINSERT xxx\nCOMMIT; -- 提交事务并持久化，持久化后不可回滚\nROLLBACK; -- 回滚\n\nSET autocommit = 1; -- 恢复默认值\n```\n\n> 模拟转账场景\n\n```sql\nCREATE DATABASE shop CHARACTER SET utf8 COLLATE utf8_general_ci\nUSE shop\nCREATE TABLE account( \n    `id` INT(4) NOT NULL AUTO_INCREMENT, \n    `name` VARCHAR(20) NOT NULL, `money`, \n    DECIMAL(9,2) NOT NULL,   -- 第一个参数表示位数，第二个参数表示小数位数\n    PRIMARY KEY(`id`) \n)ENGINE=INNODB DEFAULT CHARSET=utf8; \n\nINSERT account(`name`,`money`) VALUES\n('A',1000.00),\n('B',2000.00)\n\n\nSET autocommit = 0;\n\nSTART TRANSACTION\n\nUPDATE account SET money=money-500 WHERE `name` = 'A'  -- A转出500\nUPDATE account SET money=money+500 WHERE `name` = 'B'  -- B收到500\n\nCOMMIT;\nROLLBACK;\n\nSET autocommit = 1;\n\n```\n\n## 7、索引\n\n> MySQL官方对索引的定义为:索引(Index)是帮助MySQL高效获取数据的数据结构。\n>\n> 提取句子主干，就可以得到索引的本质:索引是数据结构。\n\n### 7.1、索引分类\n\n+ 主键索引（PRIMARY KEY）\n  + 唯一的标识，主键不可重复，只能有一个列作为主键索引\n+ 唯一索引（UNIQUE KEY）\n  + 避免重复的列出现，不可重复，一个表可以有多个唯一索引\n+ 常规索引（KEY/INDEX）\n  + 默认的，index，key关键字设置\n+ 全文索引（FULLTEXT）\n  + 在特定数据库引擎才有，MYISAM\n  + 快速定位数据\n\n```sql\nEXPLAIN -- 分析sql执行情况\n\n\nEXPLAIN SELECT * FROM student;\t-- 非全文索引\nEXPLAIN SELECT * FROM student WHERE MATCH(studentname) AGAINST('刘') -- 全文索引，数据量小不起作用\n```\n\n### 7.2、测试索引\n\n```sql\nCREATE TABLE `app_user` (\n  `id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,\n  `name` VARCHAR(50) DEFAULT '',\n  `email` VARCHAR(50) NOT NULL,\n  `phone` VARCHAR(20) DEFAULT '',\n  `gender` TINYINT(4) UNSIGNED DEFAULT '0',\n  `password` VARCHAR(100) NOT NULL DEFAULT '',\n  `update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  PRIMARY KEY (`id`)\n) ENGINE=INNODB AUTO_INCREMENT=1000001 DEFAULT CHARSET=utf8\n\n\n-- 1、插入100万数据.\nDELIMITER $$\n-- 写函数之前必须要写$$标志\nCREATE FUNCTION mock_data ()\nRETURNS INT\nBEGIN\n    DECLARE num INT DEFAULT 1000000;\n    DECLARE i INT DEFAULT 0;\n    WHILE i<num DO\n        INSERT INTO `app_user`(`name`,`email`,`phone`,`gender`)VALUES(CONCAT('用户',i),'19224305@qq.com','123456789',FLOOR(RAND()*2));\n        SET i=i+1;\n    END WHILE;\n    RETURN i;\nEND;\n\n-- 2、执行此函数 生成一百万条数据大约要执行半分钟\nSELECT mock_data() \n-- 3、查询表中数据\nSELECT * FROM app_user;\n```\n\n![image-20210215160802012](MySQL/image-20210215160802012.png)\n\n> 添加索引后查询结果：\n\n![image-20210215161143273](MySQL/image-20210215161143273.png)\n\n### 7.3、索引原则\n\n+ 索引不是越多越好\n+ 不要对经常变动的数据加索引\n+ 小数据表不需要加索引\n+ 索引一般加在常用来查询的字段\n\n> 索引的数据结构\n\nHash类型索引\n\nBTREE：INNODB默认的索引\n\n## 8、权限管理和备份\n\n### 8.1、权限管理\n\n> SQL命令\n\n**用户表：mysql.user**\n\n本质就是对这张表的增删改查\n\n```sql\n-- 创建用户 CREATE USER 用户名 IDENTIFIED BY '密码'\nCREATE USER codefriday IDENTIFIED BY '123456'\n\n-- 修改密码（当前登录的用户）\nSET PASSWORD=PASSWORD('新密码')\n\n-- 修改密码(指定用户)\nSET PASSWORD FOR 用户名 = PASSWORD('新密码')\n\n-- 重命名\nRENAME USER 原来的名字 TO 新的名字\n\n-- 用户授权,所有权限，但是 GRANT权限只有root有，不能给被人授权\nGRANT ALL PRIVILEGES ON *.* TO 用户名\n\n-- 查看权限\nSHOW GRANTS FOR 用户名\n-- 管理员权限查看\nSHOW GRANTS FOR root@localhost\n\n\n-- 撤销权限 REVOKE 哪些权限，在哪个库，给谁撤销\nREVOKE ALL PRIVILEGS ON *.* FROM 用户名\n\n-- 删除用户\nDROP USER 用户名\n```\n\n### 8.2、MYSQL备份\n\n+ 保证重要数据不丢失\n+ 数据转移\n\n> 备份的方式\n\n+ 直接拷贝物理文件\n+ 在Sqlyog这种可视化工具中手动导出备份\n+ 使用命令行导出mysqldump\n\n```bash\n#mysqldump -h主机 -uroot -p密码 数据库 [表1 表2...] > 物理磁盘位置\nmysqldump -uroot -pcodefriday school student > D:/1.sql\n\n\n#导入操作，先登录之后，切换到指定数据库\nmysql>source 备份文件物理磁盘地址\n```\n\n\n\n## 9、规范数据库设计\n\n### 9.1、为什么需要设计\n\n**当数据库比较复杂时，需要设计**\n\n+ 数据冗余，浪费空间\n+ 数据库插入删除麻烦，要屏蔽物理外键\n+ 程序性能差，比如查询数据库效率不高。\n\n> 软件开发中，关于数据库设计\n\n+ 分析需求：分析业务和需求处理的数据库的需求\n+ 概要设计：设计关系图E-R图\n\n### 9.2、三大范式\n\n> 第一范式（1NF）\n\n**要求数据库表的每一列都是不可分割的原子数据项。**\n\n> 第二范式（2NF）\n\n**前提：满足第一范式。**\n\n**第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。**\n\n**每张表只描述一件事情。**\n\n>第三范式（3NF）\n\n**前提：满足一二范式。**\n\n**第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。**\n\n\n\n> 规范性 和 性能\n\n阿里规约：关联查询不得超过三张表\n\n+ 考虑商业化需求和目标，数据库性能更重要\n+ 在规范性能问题时考虑规范性\n+ 故意增加某些冗余字段，减少联合查询的表数量\n+ 故意增加计算列（从大数据量降低为小数据量的查询：索引）\n\n## 10、JDBC\n\n### 10.1、数据库驱动\n\n不同数据库有着不同的驱动程序，有数据库厂商提供驱动程序。\n\n**Oracle数据库：**\n驱动程序包名：ojdbc14.jar\n驱动类的名字：oracle.jdbc.driver.OracleDriver\nJDBC URL：jdbc:oracle:thin:@dbip:port:databasename\n说明：驱动程序包名有可能会变\nJDBC URL中各个部分含义如下：\ndbip –为数据库服务器的IP地址，如果是本地可写：localhost或127.0.0.1。\nport –为数据库的监听端口，需要看安装时的配置，缺省为1521。\ndatabasename –为数据库的SID，通常为全局数据库的名字。\n\n**SQL Server数据库：**\n驱动程序包名：msbase.jar mssqlserver.jar msutil.jar\n驱动类的名字：com.microsoft.jdbc.sqlserver.SQLServerDriver\nJDBC URL：jdbc:microsoft:sqlserver://dbip:port;DatabaseName=databasename\n说明：驱动程序包名有可能会变\nJDBC URL中各个部分含义如下：\ndbip –为数据库服务器的IP地址，如果是本地可写：localhost或127.0.0.1。\nport –为数据库的监听端口，需要看安装时的配置，缺省为1433。\ndatabasename –数据库的名字。\n\n**MySQL数据库：**\n驱动程序包名：mysql-connector-Java-3.1.11-bin.jar\n驱动类的名字：com.mysql.jdbc.Driver\nJDBC URL：jdbc:mysql://dbip:port/databasename\n说明：驱动程序包名有可能会变\nJDBC URL其中各个部分含义如下：\ndbip –为数据库服务器的IP地址，如果是本地可写：localhost或127.0.0.1。\nport –为数据库的监听端口，需要看安装时的配置，缺省为3306。\ndatabasename –数据库的名字。\n\n### 10.2、JDBC\n\nJava数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标。\n\n![image-20210215180551671](MySQL/image-20210215180551671.png)\n\n`java.sql`，`javax.sql`\n\n### 10.3、第一个JDBC程序\n\n> 第一个测试程序\n\n```java\npackage com.codefriday.demo01;\n\nimport java.sql.*;\n\npublic class Test {\n    public static void main(String[] args) throws ClassNotFoundException, SQLException {\n        //1.加载驱动\n        Class.forName(\"com.mysql.jdbc.Driver\");\n        //2.连接的url以及用户\n        String url = \"jdbc:mysql://localhost:3306/shop?useUnicode=true&characterEncoding=utf8\";\n        String user = \"root\";\n        String pwd = \"codefriday\";\n        //3.获得连接\n        Connection connection = DriverManager.getConnection(url, user, pwd);\n        //4.获得执行对象\n        Statement statement = connection.createStatement();\n        //5.执行一个sql\n        String sql = \"SELECT * FROM account\";\n        ResultSet resultSet = statement.executeQuery(sql);\n        while(resultSet.next()){\n            System.out.println(\"id=\" + resultSet.getObject(\"id\"));\n            System.out.println(\"name=\" + resultSet.getObject(\"name\"));\n            System.out.println(\"money=\" + resultSet.getObject(\"money\"));\n        }\n\n        //6.关闭连接\n        resultSet.close();\n        statement.close();\n        connection.close();\n    }\n}\n\n```\n\n> DriverManager\n\n```java\n//1.加载驱动\nClass.forName(\"com.mysql.jdbc.Driver\");\n//2.连接的url以及用户\nString url = \"jdbc:mysql://localhost:3306/shop?useUnicode=true&characterEncoding=utf8\";\nString user = \"root\";\nString pwd = \"codefriday\";\n//3.获得连接\nConnection connection = DriverManager.getConnection(url, user, pwd);\n\n//connection代表数据库\n//可以设置事务提交，事务回滚\n```\n\n`Class.forName(\"com.mysql.jdbc.Driver\")`本质是加载`com.mysql.jdbc.Driver`这个类，然后会执行静态代码块注册一个驱动，源码如下：\n\n```java\n//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by FernFlower decompiler)\n//\n\npackage com.mysql.jdbc;\n\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver {\n    public Driver() throws SQLException {\n    }\n\n    static {\n        try {\n            DriverManager.registerDriver(new Driver());\n        } catch (SQLException var1) {\n            throw new RuntimeException(\"Can't register driver!\");\n        }\n    }\n}\n```\n\n> URL\n\n```java\nString url = \"jdbc:mysql://localhost:3306/shop?useUnicode=true&characterEncoding=utf8\";\n\n//mysql默认端口：3306\n//jdbc:mysql://主机地址:端口号/数据库名?参数1&参数2&...\n\n//oracle默认端口：1521\n//jdbc:oracle:thin:@localhost:1521:sid\n```\n\n> Statement：执行SQL的对象（PrepareStatement）\n\n```java\nstatement.executeQuery() // 执行查询操作，返回结果集ResultSet\nstatement.execute(); //可以执行任何sql\nstatement.executeUpdate();// 更新，插入，删除，返回受影响的行数\n    \n```\n\n> ResultSet\n\n```java\n//通过数据表字段名获取结果\nresultSet.getObject();\nresultSet.getString();\nresultSet.getInt();\nresultSet.getDate();\n...\n```\n\n遍历：\n\n```java\nresultSet.next();//移动到下一行\nresultSet.beforeFirst();//移动到最前面\nresultSet.afterLast();//移动到最后面\nresultSet.previous();//移动到前一行\nresultSet.absolute(3);//移动到指定行 \n```\n\n> 释放资源\n\n```java\n//6.关闭连接\n        resultSet.close();\n        statement.close();\n        connection.close();\n//用完必须释放，很占用内存资源\n```\n\n### 10.4、Statement对象\n\n> 代码测试\n\n编写工具类读取配置文件\n\n```java\npackage com.codefriday.demo02.utils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.sql.*;\nimport java.util.Properties;\n\npublic class jdbcUtils {\n    private static String Driver = null;\n    private static String Url = null;\n    private static String User = null;\n    private static String Password = null;\n    static {\n        try {\n            InputStream in = jdbcUtils.class.getClassLoader().getResourceAsStream(\"db.properties\");\n            Properties properties = new Properties();\n            properties.load(in);\n            Driver = properties.getProperty(\"Driver\");\n            Url = properties.getProperty(\"Url\");\n            User = properties.getProperty(\"User\");\n            Password = properties.getProperty(\"Password\");\n            Class.forName(Driver);//驱动只需要加载一次\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n    public static Connection getConnection() throws SQLException {\n        return DriverManager.getConnection(Url,User,Password);\n    }\n    public static void release(Connection con, Statement st, ResultSet rs) throws SQLException {\n        if(rs!=null){\n            rs.close();\n        }\n        if(st!=null){\n            st.close();\n        }\n        if(con!=null){\n            con.close();\n        }\n    }\n}\n```\n\n```properties\nDriver=com.mysql.jdbc.Driver\nUrl=jdbc:mysql://localhost:3306/shop?useUnicode=true&characterEncoding=utf8\nUser=root\nPassword=codefriday\n```\n\n测试插入操作：\n\n```java\npackage com.codefriday.demo02;\n\nimport com.codefriday.demo02.utils.jdbcUtils;\n\nimport java.sql.*;\n\npublic class TestInsert {\n    public static void main(String[] args) throws SQLException {\n        Connection conn = null;\n        Statement st = null;\n        ResultSet rs = null;\n        try {\n            conn =  jdbcUtils.getConnection();\n            st = conn.createStatement();\n            String sql = \"INSERT INTO account(`name`,`money`) VALUES('C',10000.00)\";\n            int s = st.executeUpdate(sql);\n            if(s>0){\n                System.out.println(\"插入成功\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }finally {\n            jdbcUtils.release(conn,st,rs);\n        }\n\n    }\n}\n```\n\n**注意：使用手动拼接字符串的话，会导致SQL注入问题，也就是输入过滤不严格导致的！**\n\n### 10.5、PreparedStatement对象\n\n可以防止SQL注入，效率更高！\n\n区别：预编译sql，使用`?`代替参数，设置参数后提交执行。\n\n```java\npackage com.codefriday.demo02;\n\nimport com.codefriday.demo02.utils.jdbcUtils;\n\nimport java.math.BigDecimal;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\npublic class Test02 {\n    public static void main(String[] args) throws SQLException {\n        Connection conn = null;\n        PreparedStatement psm = null;\n        ResultSet rs = null;\n        try{\n            conn = jdbcUtils.getConnection();\n            String sql = \"insert into account(`name`,`money`) values(?,?)\";\n            psm = conn.prepareStatement(sql);\n            psm.setString(1,\"E\");\n            psm.setBigDecimal(2,new BigDecimal(100.00));\n            int i = psm.executeUpdate();\n            if(i>0){\n                System.out.println(\"插入成功！\");\n            }\n\n        }catch (Exception e){\n            e.printStackTrace();\n        }finally {\n            jdbcUtils.release(conn,psm,rs);\n        }\n    }\n}\n\n```\n\n防止SQL注入的本质：把传递进来的参数当做字符，用``包裹起来，遇到转义字符会被直接转义。\n\n### 10.6、JDBC操作事务\n\n模拟A和B转账的事务：\n\n```java\npackage com.codefriday.demo02;\n\nimport com.codefriday.demo02.utils.jdbcUtils;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\npublic class Test02 {\n    public static void main(String[] args) throws SQLException {\n        Connection conn = null;\n        PreparedStatement psm = null;\n        ResultSet rs = null;\n        try{\n            conn = jdbcUtils.getConnection();\n            //关闭自动提交，事务自动开启\n            conn.setAutoCommit(false);\n            String sql = \"update account set money=money+100 where name = 'A'\";\n            psm = conn.prepareStatement(sql);\n            psm.executeUpdate();\n\n            //模拟事务被意外中断\n            int x = 1/0;\n            String sql1 = \"update account set money=money-100 where name = 'B'\";\n            psm = conn.prepareStatement(sql1);\n            psm.executeUpdate();\n\n        }catch (Exception e){\n            //捕获到异常回滚，其实会自动回滚\n            conn.rollback();\n            e.printStackTrace();\n        }finally {\n            jdbcUtils.release(conn,psm,rs);\n        }\n    }\n}\n\n```\n\n### 10.9、连接池\n\n类似于线程池的池化技术，预先准备资源，开启连接和释放连接消耗资源。\n\n常用连接数——最小连接数\n\n最大连接数——最高允许多少连接\n\n编写连接池：实现DataSource接口\n\nDBCP，C3P0，Druid（阿里巴巴）\n\n> DBCP使用实例\n\n**依赖的jar包：**\n\n![image-20210217132653078](MySQL/image-20210217132653078.png)\n\n下载地址：http://commons.apache.org/\n\n**工具类编写，此处忽略释放资源的方法！**\n\n```java\npackage com.codefriday.demo03.utils;\n\n\nimport org.apache.commons.dbcp2.BasicDataSourceFactory;\n\nimport javax.sql.DataSource;\nimport java.io.InputStream;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Properties;\n\npublic class dbcpUtils {\n    private static DataSource dataSource = null;\n    static{\n        try{\n            InputStream in = dbcpUtils.class.getClassLoader().getResourceAsStream(\"dbconfig.properties\");\n            Properties properties = new Properties();\n            properties.load(in);\n            dataSource = BasicDataSourceFactory.createDataSource(properties);\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n    public static Connection getConnection() throws SQLException {\n        return dataSource.getConnection();\n    }\n}\n\n```\n\n**dbconfig.properties**\n\n```properties\ndriverClassName=com.mysql.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/shop?useUnicode=true&characterEncoding=utf8\nusername=root\npassword=codefriday\n\n\n#初试连接数\ninitialSize=30\n#最大活跃数\nmaxTotal=30\n#最大idle数\nmaxIdle=10\n#最小idle数\nminIdle=5\n#最长等待时间(毫秒)\nmaxWaitMillis=1000\n#程序中的连接不使用后是否被连接池回收(该版本要使用removeAbandonedOnMaintenance和removeAbandonedOnBorrow)\n#removeAbandoned=true\nremoveAbandonedOnMaintenance=true\nremoveAbandonedOnBorrow=true\n#连接在所指定的秒数内未使用才会被删除(秒)(为配合测试程序才配置为1秒)\nremoveAbandonedTimeout=1\n```\n\n**编写测试函数：**\n\n```java\npackage com.codefriday.demo03;\n\nimport com.codefriday.demo03.utils.dbcpUtils;\n\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class Testdbcp {\n    public static void main(String[] args) {\n        Connection conn = null;\n        Statement st = null;\n        try {\n            conn =  dbcpUtils.getConnection();\n            st = conn.createStatement();\n            String sql = \"INSERT INTO account(`name`,`money`) VALUES('C',10000.00)\";\n            int s = st.executeUpdate(sql);\n            if(s>0){\n                System.out.println(\"插入成功\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }finally {\n\t\t\tst.close();\n        }\n\n    }\n}\n\n\n```\n\n> C3P0\n\n可以使用xml自动化配置，也可以使用java代码调用setxxx配置信息。\n\n**工具类编写**\n\n```java\npackage com.codefriday.demo04.utils;\n\nimport com.mchange.v2.c3p0.ComboPooledDataSource;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\npublic class c3p0utils {\n    private static DataSource ds = null;\n    static {\n        ds = new ComboPooledDataSource();//读取默认配置文件\n    }\n    public static Connection getConnection() throws SQLException {\n        return ds.getConnection();//自动加载xml默认配置\n    }\n}\n\n```\n\n**XML配置文件**\n\n```xml\n<c3p0-config>\n  <!-- 默认配置，如果没有指定则使用这个配置 -->\n  <default-config>\n    <property name=\"driverClass\">com.mysql.jdbc.Driver</property>\n    <property name=\"jdbcUrl\">\n      <![CDATA[jdbc:mysql://localhost:3306/shop?useUnicode=true&characterEncoding=UTF-8]]>\n    </property>\n    <property name=\"user\">root</property>\n    <property name=\"password\">codefriday</property>\n    <!-- 初始化池大小 -->\n    <property name=\"initialPoolSize\">2</property>\n    <!-- 最大空闲时间 -->\n    <property name=\"maxIdleTime\">30</property>\n    <!-- 最多有多少个连接 -->\n    <property name=\"maxPoolSize\">10</property>\n    <!-- 最少几个连接 -->\n    <property name=\"minPoolSize\">2</property>\n    <!-- 每次最多可以执行多少个批处理语句 -->\n    <property name=\"maxStatements\">50</property>\n  </default-config>\n  <!-- 命名的配置 -->\n  <named-config name=\"BarryLee\">\n    <property name=\"driverClass\">com.mysql.jdbc.Driver</property>\n    <property name=\"jdbcUrl\">jdbc:mysql://127.0.0.1:3306/aa</property>\n    <property name=\"user\">root</property>\n    <property name=\"password\">000</property>\n    <property name=\"acquireIncrement\">5</property><!-- 如果池中数据连接不够时一次增长多少个 -->\n    <property name=\"initialPoolSize\">100</property>\n    <property name=\"minPoolSize\">50</property>\n    <property name=\"maxPoolSize\">1000</property>\n    <property name=\"maxStatements\">0</property>\n    <property name=\"maxStatementsPerConnection\">5</property> <!-- he's important, but there's only one of him -->\n  </named-config>\n</c3p0-config>\n```\n\n**测试代码**\n\n```java\npackage com.codefriday.demo04;\n\nimport com.codefriday.demo04.utils.c3p0utils;\n\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class TestC3P0 {\n    public static void main(String[] args) {\n        Connection conn = null;\n        Statement st = null;\n        ResultSet rs = null;\n        try {\n            conn =  c3p0utils.getConnection();\n            st = conn.createStatement();\n            String sql = \"INSERT INTO account(`name`,`money`) VALUES('C',10000.00)\";\n            int s = st.executeUpdate(sql);\n            if(s>0){\n                System.out.println(\"插入成功\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }finally {\n\t\t\tst.close();\n        }\n    }\n}\n\n```\n\n","tags":["第三阶段"],"categories":["第三阶段"]},{"title":"前端实战，小米闪购官网","url":"/2021/02/09/前端实战，小米闪购官网/","content":"\n## GitHub仓库地址\n\nhttps://github.com/jinyalong/xiaomi-SecKill\n\n## 前言\n\n之前有过学校0基础写web端页面的经历，自己的写的像shit一样，看着大佬的漂亮页面只能我草。花了几天学习了前端三大基石：`HTML`+`CSS`+`JS`，但是这只是前端的皮毛，真正的开发也不是用原生三大件搞开发，都用框架，然后还接触了一点点`JQuery`，写更少的代码做更多的事。后面会继续学习框架以及“大前端”！\n\n\n\n**在此，为了巩固一下学的三大件，简单复刻了一下小米闪购官网，主要用到的还是`CSS`，`JS`占比很小。**\n\n小米闪购官网：https://www.mi.com/seckill\n\n## 网站结构\n\n首先要复刻一个网站，先分析它的页面组成。主要分了三大块，然后再继续细分！\n\n> 网页结构：\n\n- body\n  -  顶部导航栏\n  - header\n  - 商品界面主体\n\n![image-20210209212004273](\\前端实战，小米闪购官网/image-20210209212004273.png)\n\n## 顶部导航栏\n\n> html结构\n\n```html\n<div class=\"topbar\">\n    <div class=\"container\">\n        <div class=\"topbar-nav\">\n            <a href=\"\">小米商城</a>\n            <span class=\"sep\">|</span>\n            <a href=\"\">MIUI</a><span>|</span>\n            <a href=\"\">IoT</a><span>|</span>\n            <a href=\"\">云服务</a><span>|</span>\n            <a href=\"\">天星数科</a><span>|</span>\n            <a href=\"\">有品</a><span>|</span>\n            <a href=\"\">小爱开放平台</a><span>|</span>\n            <a href=\"\">企业团购</a><<span>|</span>\n        <a href=\"\">资质证照</a><span>|</span>\n        <a href=\"\">协议规则</a><span>|</span>\n        <a href=\"\">下载App</a><span>|</span>\n        <a href=\"\">智能生活</a>\n    </div>\n    <div class=\"topbar-cart\">\n        <a href=\"\"><i class=\"iconfont\">&#xe60c</i>购物车<span>（0）</span></a>\n    </div>\n    <div class=\"topbar-info clearfix\">\n        <a href=\"\">登录</a>\n        <span>|</span>\n        <a href=\"\">注册</a>\n        <span>|</span>\n        <a href=\"\" class=\"sep\">消息通知</a>\n    </div>\n\n\t</div>\n</div>\n```\n\n**结构分析：**\n\n![image-20210209213106957](前端实战，小米闪购官网/image-20210209213106957.png)\n\n> CSS\n\n**主要注意点有，鼠标移动到会变色，并且都是一些a标签，以及设置了浮动使得`ul li`能横向展示，但是浮动一定要记得清除，并且用伪类解决父级边框塌陷问题！**\n\n```css\nbody{\n    margin: 0;\n    padding: 0;\n    font: 14px/1.5 \"Helvetica Neue\",Helvetica,Arial,\"Microsoft Yahei\",\"Hiragino Sans GB\",\"Heiti SC\",\"WenQuanYi Micro Hei\",sans-serif;\n    height: 3000px;\n}\nul,li{\n    margin: 0;\n    padding: 0;\n    list-style-type: none;\n}\na{\n    text-decoration: none;\n}\n.topbar{\n    height: 40px;\n    color: #b0b0b0;\n    font-size: 12px;\n    background: #333;\n\n}\n/*解决父级边框塌陷问题*/\n.container:after,.clearfix:after{\n    content: '';\n    display: block;\n    clear: both;\n}\n.container{\n    margin: 0 auto;\n    width: 1226px;\n}\n.topbar-nav{\n    float: left;\n    height: 40px;\n    line-height: 40px;\n    font-size: 0;\n}\n.topbar a{\n    color: #b0b0b0;\n    line-height: 40px;\n    font-size: 12px;\n    display: inline-block;\n}\n.topbar a:hover{\n    color: #fff;\n}\n.topbar-cart,.topbar-info{\n    float: right;\n\n}\n.topbar-cart{\n    width: 120px;\n    margin-left: 15px;\n}\n.topbar-nav span{\n    font-size: 12px;\n    color: #424242;\n    font-family: sans-serif;\n    margin: 0.5em;\n}\n.topbar-cart a{\n    display: block;\n    line-height: 40px;\n    height: 40px;\n    text-align: center;\n    background-color: #424242;\n}\n.topbar-cart a:hover{\n    background-color: #fff;\n    color: #ff6700;\n}\n.topbar-cart span{\n    margin-left: 4px;\n    font-size: 12px;\n    margin: 0 0 0 -4px;\n}\n.topbar-cart i{\n    font-size: 20px;\n    line-height: 20px;\n    margin-right: 4px;\n    vertical-align: -4px;\n}\n.topbar-info a{\n    float: left;\n    padding: 0 5px;\n}\n.topbar-info span{\n    float: left;\n    font-family: sans-serif;\n    font-size: 12px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    color: #424242;\n}\n.topbar-info .sep{\n    padding: 0 10px;\n}\n```\n\n## Header\n\n> html结构\n\n在此全部商品分类的悬浮显示窗口未实现！\n\n主要分一个logo，导航栏，搜索框。\n\n搜索框和上面一个顶部导航栏的购物车图片均是矢量图，需要导入小米官网上爬到的相关`CSS`文件才能用。\n\nlogo的话官网有移动鼠标悬停时切换的动画，未实现，直接截图当静态背景图片了~\n\n此时也用了浮动！！！\n\n```html\n<div class=\"header\">\n        <div class=\"container\">\n            <div class=\"header-logo\">\n                <a href=\"#\" title=\"小米官网\"></a>\n            </div>\n            <div class=\"header-nav\">\n                <ul class=\"nav-list clearfix\">\n                    <li class=\"nav-category\">\n                        <a href=\"\">全部商品分类</a>\n                    </li>\n                    <li class=\"nav-item\">\n                        <a href=\"\">小米手机</a>\n                    </li>\n                    <li class=\"nav-item\">\n                        <a href=\"\">Redmi 红米</a>\n                    </li>\n                    <li class=\"nav-item\">\n                        <a href=\"\">电视</a>\n                    </li>\n                    <li class=\"nav-item\">\n                        <a href=\"\">笔记本</a>\n                    </li>\n                    <li class=\"nav-item\">\n                        <a href=\"\">家电</a>\n                    </li>\n                    <li class=\"nav-item\">\n                        <a href=\"\">路由器</a>\n                    </li>\n                    <li class=\"nav-item\">\n                        <a href=\"\">智能硬件</a>\n                    </li>\n                    <li class=\"nav-item\">\n                        <a href=\"\">服务</a>\n                    </li>\n                    <li class=\"nav-item\">\n                        <a href=\"\">社区</a>\n                    </li>\n                </ul>\n            </div>\n\n            <div class=\"header-search\">\n                <form action=\"\" class=\"search-form\">\n                    <input type=\"search\" name=\"keywords\" class=\"search-text\">\n                    <input type=\"submit\" value=\"&#xe616\" class=\"search-btn iconfont\">\n                </form>\n            </div>\n        </div>\n    </div>\n```\n\n> CSS\n\n```css\n.header{\n    height: 100px;\n}\n.header-logo{\n    float: left;\n    width: 62px;\n    margin-top: 22px;\n    height: 55px;\n}\n.header-nav{\n    float: left;\n    width: 820px;\n    height: 100px;\n    /*border: 1px solid black;*/\n}\n.header-search{\n    float: right;\n    width: 296px;\n    height: 50px;\n    margin-top: 25px;\n\n    /*border: 1px solid black;*/\n}\n.header-logo a{\n    display: block;\n    width: 55px;\n    height: 55px;\n    background-image: url(\"../image/milog.png\");\n}\n.header-nav .nav-list{\n    width: 820px;\n    height: 88px;\n    font-size: 16px;\n    padding: 12px 0 0 30px;\n}\n.header-nav .nav-list .nav-category{\n    float: left;\n    width: 127px;\n    padding: 0 15px 0 0;\n}\n.header-nav .nav-list .nav-category a{\n    display: block;\n    color: #333;\n    padding: 26px 0 38px;\n    text-align: right;\n}\n.header-nav .nav-list .nav-item{\n    float: left;\n}\n.header-nav .nav-list .nav-item a{\n    display: block;\n    padding: 26px 10px 38px;\n    color: #333;\n}\n.header-nav .nav-list .nav-item a:hover{\n    color: #ff6700;\n}\n.header-search .search-form{\n    position: relative;\n    display: block;\n    width: 296px;\n    height: 50px;\n\n}\n.header-search .search-form .search-text{\n    position: absolute;\n    top: 0;\n    right: 51px;\n    display: block;\n    width: 245px;\n    height: 50px;\n    line-height: 50px;\n    border: 1px solid #e0e0e0;\n    outline: 0;\n}\n.header-search .search-form .search-btn{\n    position: absolute;\n    top: 0;\n    right: 0;\n    display: block;\n    width: 52px;\n    height: 50px;\n    border: 1px solid #e0e0e0;\n    font-size: 24px;\n    line-height: 24px;\n    background-color: #fff;\n    color: #616161;\n    outline: 0;\n\n}\n.header-search .search-form .search-btn:hover{\n    background-color: #ff6700;\n    color: #fff;\n}\n\n```\n\n> SecKill主体\n\n**首先是一张背景图片。**\n\n**然后时一个横向导航栏选项卡！**\n\n**最后就是商品展示部分：**\n\n中间五个ul的重复主要是为了顶部不同栏目切换而设计的。\n\n每个商品对应到`ul`里面的一个`li`元素\n\n`li`元素又细分图片和描述两部分。\n\n```html\n<div class=\"seckill\">\n        <div class=\"seckill-head\"></div>\n        <div class=\"container\">\n            <div class=\"seckill-nav\" id=\"seckill-nav\">\n                <ul id=\"tabs\">\n                    <li class=\"active\"><em>14:00</em><span><em>抢购中<br>距结束 <timer  id=\"timer\">02:41:00</timer></em></span></li>\n                    <li><em>20:00</em><span>即将开始</span></li>\n                    <li><em>22:00</em><span>即将开始</span></li>\n                    <li><em>00:00</em><span>明日开始</span></li>\n                    <li><em>10:00</em><span>明日开始</span></li>\n                </ul>\n            </div>\n            <!--选项卡-->\n            <!--商品-->\n            <div class=\"seckill-goods\" id=\"goods\">\n                <ul class=\"clearfix active\">\n                    <li>\n                        <a href=\"\" class=\"seckill-box\"></a>\n                        <div class=\"bg\"><img src=\"image/1.jpg\" alt=\"\"></div>\n                        <div class=\"info\">\n                            <span class=\"name\">米家自动泡沫洗洁精机套装 白色</span>\n                            <span class=\"desc\">感应出泡，高效清洁</span>\n                            <span class=\"price\">\n                                69.00元\n                                <del>\n                                    79元\n                                </del>\n                            </span>\n                            <a href=\"\" class=\"btn-buy\">登录后抢购</a>\n                        </div>\n\n                    </li>\n                    <li>\n                        <a href=\"\" class=\"seckill-box\"></a>\n                        <div class=\"bg\"><img src=\"image/2.jpg\" alt=\"\"></div>\n                        <div class=\"info\">\n                            <span class=\"name\">小米电视4A 70英寸 黑色 70英寸 </span>\n                            <span class=\"desc\">大屏更享受</span>\n                            <span class=\"price\">\n                                3299.00元\n                                <del>\n                                    3999元\n                                </del>\n                            </span>\n                            <a href=\"\" class=\"btn-buy\">登录后抢购</a>\n                        </div>\n                    </li>\n                    <li>\n                        <a href=\"\" class=\"seckill-box\"></a>\n                        <div class=\"bg\"><img src=\"image/3.jpg\" alt=\"\"></div>\n                        <div class=\"info\">\n                            <span class=\"name\">米家扫拖机器人G1 白色 </span>\n                            <span class=\"desc\">能扫会拖，整屋清洁一步到位</span>\n                            <span class=\"price\">\n                                899.00元\n                                <del>\n                                    999元\n                                </del>\n                            </span>\n                            <a href=\"\" class=\"btn-buy\">登录后抢购</a>\n                        </div>\n                    </li>\n                    <li></li>\n                </ul>\n                <ul class=\"clearfix\">\n                    <li>\n                        <a href=\"\" class=\"seckill-box\"></a>\n                        <div class=\"bg\"><img src=\"image/2.jpg\" alt=\"\"></div>\n                        <div class=\"info\">\n                            <span class=\"name\">小米电视4A 70英寸 黑色 70英寸 </span>\n                            <span class=\"desc\">大屏更享受</span>\n                            <span class=\"price\">\n                                3299.00元\n                                <del>\n                                    3999元\n                                </del>\n                            </span>\n                            <a href=\"\" class=\"btn-buy\">登录后抢购</a>\n                        </div>\n                    </li>\n                    <li>\n                        <a href=\"\" class=\"seckill-box\"></a>\n                        <div class=\"bg\"><img src=\"image/3.jpg\" alt=\"\"></div>\n                        <div class=\"info\">\n                            <span class=\"name\">米家扫拖机器人G1 白色 </span>\n                            <span class=\"desc\">能扫会拖，整屋清洁一步到位</span>\n                            <span class=\"price\">\n                                899.00元\n                                <del>\n                                    999元\n                                </del>\n                            </span>\n                            <a href=\"\" class=\"btn-buy\">登录后抢购</a>\n                        </div>\n                    </li>\n                    <li>\n                        <a href=\"\" class=\"seckill-box\"></a>\n                        <div class=\"bg\"><img src=\"image/1.jpg\" alt=\"\"></div>\n                        <div class=\"info\">\n                            <span class=\"name\">米家自动泡沫洗洁精机套装 白色</span>\n                            <span class=\"desc\">感应出泡，高效清洁</span>\n                            <span class=\"price\">\n                                69.00元\n                                <del>\n                                    79元\n                                </del>\n                            </span>\n                            <a href=\"\" class=\"btn-buy\">登录后抢购</a>\n                        </div>\n\n                    </li>\n                    <li></li>\n                </ul>\n                <ul class=\"clearfix\">\n                    <li>\n                        <a href=\"\" class=\"seckill-box\"></a>\n                        <div class=\"bg\"><img src=\"image/1.jpg\" alt=\"\"></div>\n                        <div class=\"info\">\n                            <span class=\"name\">米家自动泡沫洗洁精机套装 白色</span>\n                            <span class=\"desc\">感应出泡，高效清洁</span>\n                            <span class=\"price\">\n                                69.00元\n                                <del>\n                                    79元\n                                </del>\n                            </span>\n                            <a href=\"\" class=\"btn-buy\">登录后抢购</a>\n                        </div>\n\n                    </li>\n\n                    <li>\n                        <a href=\"\" class=\"seckill-box\"></a>\n                        <div class=\"bg\"><img src=\"image/3.jpg\" alt=\"\"></div>\n                        <div class=\"info\">\n                            <span class=\"name\">米家扫拖机器人G1 白色 </span>\n                            <span class=\"desc\">能扫会拖，整屋清洁一步到位</span>\n                            <span class=\"price\">\n                                899.00元\n                                <del>\n                                    999元\n                                </del>\n                            </span>\n                            <a href=\"\" class=\"btn-buy\">登录后抢购</a>\n                        </div>\n                    </li>\n                    <li>\n                        <a href=\"\" class=\"seckill-box\"></a>\n                        <div class=\"bg\"><img src=\"image/2.jpg\" alt=\"\"></div>\n                        <div class=\"info\">\n                            <span class=\"name\">小米电视4A 70英寸 黑色 70英寸 </span>\n                            <span class=\"desc\">大屏更享受</span>\n                            <span class=\"price\">\n                                3299.00元\n                                <del>\n                                    3999元\n                                </del>\n                            </span>\n                            <a href=\"\" class=\"btn-buy\">登录后抢购</a>\n                        </div>\n                    </li>\n                    <li></li>\n                </ul>\n                <ul class=\"clearfix\">\n                    <li>\n                        <a href=\"\" class=\"seckill-box\"></a>\n                        <div class=\"bg\"><img src=\"image/3.jpg\" alt=\"\"></div>\n                        <div class=\"info\">\n                            <span class=\"name\">米家扫拖机器人G1 白色 </span>\n                            <span class=\"desc\">能扫会拖，整屋清洁一步到位</span>\n                            <span class=\"price\">\n                                899.00元\n                                <del>\n                                    999元\n                                </del>\n                            </span>\n                            <a href=\"\" class=\"btn-buy\">登录后抢购</a>\n                        </div>\n                    </li>\n                    <li>\n                        <a href=\"\" class=\"seckill-box\"></a>\n                        <div class=\"bg\"><img src=\"image/1.jpg\" alt=\"\"></div>\n                        <div class=\"info\">\n                            <span class=\"name\">米家自动泡沫洗洁精机套装 白色</span>\n                            <span class=\"desc\">感应出泡，高效清洁</span>\n                            <span class=\"price\">\n                                69.00元\n                                <del>\n                                    79元\n                                </del>\n                            </span>\n                            <a href=\"\" class=\"btn-buy\">登录后抢购</a>\n                        </div>\n\n                    </li>\n                    <li>\n                        <a href=\"\" class=\"seckill-box\"></a>\n                        <div class=\"bg\"><img src=\"image/2.jpg\" alt=\"\"></div>\n                        <div class=\"info\">\n                            <span class=\"name\">小米电视4A 70英寸 黑色 70英寸 </span>\n                            <span class=\"desc\">大屏更享受</span>\n                            <span class=\"price\">\n                                3299.00元\n                                <del>\n                                    3999元\n                                </del>\n                            </span>\n                            <a href=\"\" class=\"btn-buy\">登录后抢购</a>\n                        </div>\n                    </li>\n\n                    <li></li>\n                </ul>\n                <ul class=\"clearfix\">\n                    <li>\n                        <a href=\"\" class=\"seckill-box\"></a>\n                        <div class=\"bg\"><img src=\"image/3.jpg\" alt=\"\"></div>\n                        <div class=\"info\">\n                            <span class=\"name\">米家扫拖机器人G1 白色 </span>\n                            <span class=\"desc\">能扫会拖，整屋清洁一步到位</span>\n                            <span class=\"price\">\n                                899.00元\n                                <del>\n                                    999元\n                                </del>\n                            </span>\n                            <a href=\"\" class=\"btn-buy\">登录后抢购</a>\n                        </div>\n                    </li>\n                    <li>\n                        <a href=\"\" class=\"seckill-box\"></a>\n                        <div class=\"bg\"><img src=\"image/2.jpg\" alt=\"\"></div>\n                        <div class=\"info\">\n                            <span class=\"name\">小米电视4A 70英寸 黑色 70英寸 </span>\n                            <span class=\"desc\">大屏更享受</span>\n                            <span class=\"price\">\n                                3299.00元\n                                <del>\n                                    3999元\n                                </del>\n                            </span>\n                            <a href=\"\" class=\"btn-buy\">登录后抢购</a>\n                        </div>\n                    </li>\n                    <li>\n                        <a href=\"\" class=\"seckill-box\"></a>\n                        <div class=\"bg\"><img src=\"image/1.jpg\" alt=\"\"></div>\n                        <div class=\"info\">\n                            <span class=\"name\">米家自动泡沫洗洁精机套装 白色</span>\n                            <span class=\"desc\">感应出泡，高效清洁</span>\n                            <span class=\"price\">\n                                69.00元\n                                <del>\n                                    79元\n                                </del>\n                            </span>\n                            <a href=\"\" class=\"btn-buy\">登录后抢购</a>\n                        </div>\n\n                    </li>\n                    <li></li>\n                </ul>\n            </div>\n            <p class=\"seckill-notice\">\n                *小米秒杀活动规则：<br>\n                1.秒杀商品是否参加活动、最终秒杀成功的商品，以订单结算页显示为准，活动包括但不限于优惠券、赠品、满减、满赠等；<br>\n                2.秒杀商品数量有限，活动以下单支付成功为准，请加入购物车后尽快下单支付;<br>\n                3.秒杀价不含运费，最终以订单结算页价格为准；<br>\n                4.订单中商品的数量、颜色、型号等，以订单结算页为准。<br>\n                温馨提示：因可能存在系统缓存、页面更新导致价格变动异常等不确定性情况出现，如您发现活动商品标价或促销信息有异常，请您立即联系小米客服，以便我们及时补正。<br>\n\n            </p>\n\n        </div>\n        </div>\n```\n\n> CSS\n\n```css\n*seckill*/\n.seckill{\n    background-color: #f5f5f5;\n}\n.seckill-head{\n    margin-top: 19px;\n    height: 170px;\n    background: url(\"../image/seckill-head.jpg\") 50% 0;\n}\n.seckill-nav{\n    margin: -68px 0 22px;\n    width: 1226px;\n}\n.seckill-navfixed{\n    position: fixed;\n    z-index: 10;\n    top: 68px;\n}\n.seckill-nav ul{\n    width: 100%;\n    height: 68px;\n    background-color: #414141;\n}\n.seckill-nav li{\n    display: block;\n    float: left;\n    color: #fff;\n    width: 20%;\n    height: 68px;\n    line-height: 68px;\n    text-align: center;\n    cursor: pointer;\n}\n.seckill-nav li em{\n    display: inline-block;\n    font-style: normal;\n    font-size: 18px;\n    line-height: 1;\n    vertical-align: middle;\n    margin-left: 30px;\n\n}\n.seckill-nav li span{\n    display: inline-block;\n    margin-left: 15px;\n    font-size: 14px;\n    text-align: left;\n    line-height: 1;\n    vertical-align: middle;\n}\n.seckill-nav .active{\n    background-color: #fe393a;\n}\n.seckill-nav ul li span em{\n    display: inline-block;\n    font-size: 14px;\n    margin-left: 0;\n    font-style: normal;\n    text-align: left;\n    line-height: 20px;\n}\n\n.seckill-goods .active{\n    display: block;\n    margin-right: -13px;\n}\n.seckill-goods ul{\n    display: none;\n    margin-right: -13px;\n}\n.seckill-goods li{\n    width: 400px;\n    height: 190px;\n    background-color: #fff;\n    float: left;\n    margin-right: 13px;\n    margin-bottom: 13px;\n}\n.seckill-goods .bg{\n    float: left;\n    width: 190px;\n    height: 190px;\n}\n.seckill-goods .info{\n    width: 190px;\n    height: 190px;\n    margin-left: 210px;\n    margin-top: 30px;\n}\n.seckill-goods .bg img{\n    height: 190px;\n}\n\n\n.seckill-goods li .info .name{\n    width: 180px;\n    font-size: 16px;\n    color: #333;\n    height: 16px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    display: block;\n    line-height: 16px;\n}\n\n.seckill-goods li .info .desc{\n    color: rgba(0,0,0,0.54);\n    margin-top: 7px;\n    font-size: 12px;\n    line-height: 16px;\n    height: 32px;\n    width: 100%;\n    display: block;\n    overflow: hidden;\n}\n.seckill-goods li .info .price {\n    font-size: 16px;\n    color: #f1393a;\n    line-height: 1;\n    margin-top: 14px;\n    display: block;\n}\n.seckill-goods li .info .price del{\n    margin-left: 10px;\n    font-size: 12px;\n    color: rgba(0,0,0,0.54);\n    font-style: normal;\n}\n.seckill-goods li .btn-buy{\n    display: block;\n    background: #f1393a;\n    border-color: #f1393a;\n    margin-top: 20px;\n    width: 120px;\n    height: 30px;\n    text-align: center;\n    line-height: 30px;\n    height: 30px;\n    color: #ffffff;\n}\n\n\n.seckill-goods li{\n    position: relative;\n}\n.seckill-goods .seckill-box{\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n    z-index: 2;\n}\n\n\n.seckill-notice{\n    padding-bottom: 35px;\n    font-size: 12px;\n    color: rgba(0,0,0,0.27);\n    margin-top: 100px;\n}\n```\n\n## JS补充功能\n\n### 选项卡点击切换背景颜色\n\n![image-20210209214249324](前端实战，小米闪购官网/image-20210209214249324.png)\n\n**设计思路：**\n\n此处实际对应了`ul`的五个`li`标签，设计一个类名为`active`，当`li`类名含有这个值时背景颜色改为红色（其实不是红色~），`JS`代码中绑定一个鼠标键点击时间，遍历`li`，清空其他`li`标签的`active`这个类名，为自己添加上即可。\n\n```js\n`use strict`;\n//获得秒杀导航栏li对象数组\nvar tabs = document.getElementById('tabs').getElementsByTagName('li');\n//把每个li绑定一个函数\nfor(let i = 0;i <tabs.length;i++){\n    tabs[i].onclick = showlist;\n}\n//每次点击判断，将自己的class设置成active，其他则清空\nfunction showlist(){\n    for (let i = 0; i < tabs.length; i++) {\n        if(tabs[i] === this){\n            tabs[i].className = \"active\";\n            //lists[i].className = \"clearfix active\";\n        }else{\n            tabs[i].className = \"\";\n            //lists[i].className = \"clearfix\";\n        }\n    }\n}\n```\n\n### 不同导航栏切换不同商品列表\n\n在此我只是打乱了一下三个商品的顺序！\n\n思路和上面一致，设置`ul`的`display`属性为`none`即为不显示！始终只显示一个`ul`即可。\n\n```js\nvar lists = document.getElementById('goods').getElementsByTagName('ul');\nfunction showlist(){\n    for (let i = 0; i < tabs.length; i++) {\n        if(tabs[i] === this){\n            //tabs[i].className = \"active\";\n            lists[i].className = \"clearfix active\";\n        }else{\n            //tabs[i].className = \"\";\n            lists[i].className = \"clearfix\";\n        }\n    }\n}\n```\n\n## 导航栏下滑时固定在最上面\n\n这个主要检测侧边栏滚动条高度达到每个阈值时，把导航栏`position`属性设为`fixed`，同样的配合`CSS`修改。\n\n![image-20210209215253552](前端实战，小米闪购官网/image-20210209215253552.png)\n\n```js\nvar nav = document.getElementById('seckill-nav');\nwindow.onscroll = function (){\n\n    let height = document.documentElement.scrollTop;\n    if(height>=260){\n        nav.className=\"seckill-nav seckill-navfixed\";\n    }else{\n        nav.className=\"seckill-nav\";\n    }\n}\n\n```\n\n### 倒计时\n\n自己琢磨写了一种很烂的方法，`bug`肯定有的，但是深深体会到`JavaScript`的随便！！！\n\n```js\n//倒计时功能：\nvar timer = document.getElementById('timer');\nvar hh = timer.textContent[0]+timer.textContent[1];\nvar mm = timer.textContent[3]+timer.textContent[4];\nvar ss = timer.textContent[6]+timer.textContent[7];\n\nsetInterval (function () {\n    timer.innerText = showtime();\n    }, 1000);  //反复执行函数本身\nfunction showtime(){\n    ss--;\n    if(ss==-1){\n        ss = 59;\n        mm--;\n    }\n    if(mm==-1){\n        mm=59;\n        hh--;\n    }\n    if(hh<0) hh=0;\n    return hh+':'+mm+':'+ss;\n}\n\n```\n\n## 最终效果\n\n![image-20210209215434047](前端实战，小米闪购官网/image-20210209215434047.png)","tags":["第二阶段"],"categories":["实战项目"]},{"title":"JavaScript","url":"/2021/02/06/JavaScript/","content":"\n## 1、概述\n\n前端三大件：Html+CSS+JavaScript\n\nJavaScript 和 Java 是完全不同的语言，不论是概念还是设计。\n\nJavaScript 在 1995 年由 Brendan Eich 发明，并于 1997 年成为一部 ECMA 标准。\n\n**是一门全球最火的脚本语言，不需要编译，由浏览器直接解释运行。**\n\n一个合格的后端人员，必须精通`JavaScript`\n\n## 2、快速入门\n\n### 2.1、引入js\n\n1、内部标签\n\n```javascript\n//一般放在head标签底部，或者body标签底部\n<script>\n    //....\n</script>\n```\n\n2、外部引入\n\n```js\n<script src=\"abc.js\"></script>\n```\n\n### 2.2、基本语法\n\n```js\n// 1.定义变量 var\nvar str = \"hello\";\n// 2.条件控制\nif(exp){}else if(){}else{}//可嵌套\n```\n\n> 浏览器控制台指令\n\n`console.log(变量名)`，打印一个变量\n\n### 2.3、数据类型\n\n数值，文本，图形，音频，视频...\n\n+ `number`：\n\n```javascript\n//js不区分小数和整数，统一用number\n123 //整数\n123.1 //小数\nNaN //not a number\nInfinity //表示无限大\n```\n\n+ 字符串：单引号或者双引号，‘hello' \"workday\"\n\n+ 布尔值：true false\n\n+ 逻辑运算：&& || ！\n+ 比较运算符：\n\n```javascript\n=\t\t//赋值\n==\t\t//等于，类型不一样值一样也会判断为true\n===\t\t//绝对等于，类型一样值一样才为true\n```\n\n+ NaN===Nan，为false，这个与所有数值都不相等，包括自己\n+ 只能通过isNaN()来判断\n\n+ 浮点数存在精度问题。\n+ null和undefined：空，未定义\n+ 数组：类型可以不同：\n\n```javascript\nvar arr=[1,2,true,null,12.3];\n//取下标越界，输出undefined\n```\n\n+ 对象是大括号，数组中括号，对象中存`属性：值`用逗号隔开，最后一个不需要逗号\n\n###  2.4、严格检查模式\n\n```javascript\n<script>\n    'use strict'//使用严格检查模式，必须写在第一行\n\t//ES6,let定义局部变量\n</script>\n```\n\n## 3、数据类型\n\n### 3.1、字符串\n\n1、单引号或者双引号包裹\n\n2、特殊符号使用转义字符\n\n3、多行字符串用`包裹\n\n4、模板字符串\n\n```js\n<script>\n        `use strict`\n        let name = \"codefriday\";\n        let mes = `hello,${name}`;\n        console.log(mes);\n</script>\n```\n\n5、字符串长度：`str.length`\n\n6、字符串不可变\n\n7、大小写转换，调用方法\n\n```js\nstr.toUpperCase()\nstr.toLowerCase()\n//索引t字符第一次出现\nstr.indexOf('t')\n//substr\nstr.substr(1)//从第一个字符获取到最后一个\nstr.sunstr(1,3)//[1,3)\n```\n\n### 3.2、数组\n\n+ 可以包含任意数据类型\n\n1、长度可以赋值，数组大小就会改变，如果赋值过小，元素就会丢失。\n\n2、`indexOf`通过元素获得下标索引，字符串和数字不同！\n\n3、`slice()`截取数组的一部分。\n\n4、`push`，`pop`操作有效，在数组最后面操作\n\n5、`unshift`，`shift`：压入头部，弹出头部。\n\n6、`sort`排序，`reverse`翻转，`concat`拼接返回新的\n\n7、连接符`join`，打印拼接数组，使用特点字符串连接。\n\n8、多维数组。\n\n### 3.3、对象\n\n所有键都是字符串，值是任意对象。\n\n1、若干键值对，定义格式：\n\n```javascript\nvar 对象名{\n    属性名：属性值,\n    属性名：属性值,\n    属性名：属性值\n}\n使用`对象名.属性名`引用\n```\n\n2、使用一个不存在的对象属性不会报错！`undefined`\n\n3、动态删减属性，通过`delete`删除，动态添加直接赋值一个新的属性。\n\n4、查询对象是否有某个属性，`xxx in xxx`，可以查询到继承中的属性。\n\n5、查询自己的属性用haveownPrority\n\n### 3.4、流程控制\n\n`if`判断，`while`循环，`for`循环，`do-while`，`for`循环\n\n数组循环：`forEach`，`for...in`\n\n```js\nvar numbers = [45, 4, 9, 16, 25];\nnumbers.forEach(myFunction);\n\nfunction myFunction(value, index, array) {\n  console.log(array[index]==value)\n}\n```\n\n### 3.6、Map和Set\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>第一个程序</title>\n    <script>\n        //使用二维数组初始化\n       var map = new Map([[2,3],[3,4]]);\n       map.set(1,2);\n       map.set(true,'world')\n       var v =map.get(true);\n    </script>\n</head>\n<body>\n<p>hello</p>\n</body>\n</html>\n```\n\n> 遍历Map和Set \n\n使用`iterator`迭代。\n\n`for...of`\n\n## 4、函数\n\n### 4.1、函数定义\n\n第一种：\n\n```js\nfunction abs(x) {\n    if (x >= 0) {\n        return x;\n    } else {\n        return -x;\n    }\n}\n上述abs()函数的定义如下：\n\nfunction指出这是一个函数定义；\nabs是函数的名称；\n(x)括号内列出函数的参数，多个参数以,分隔；\n{ ... }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。\n```\n\n第二种：由于JavaScript的函数也是一个对象，上述定义的`abs()`函数实际上是一个函数对象，而函数名`abs`可以视为指向该函数的变量。\n\n```js\nvar abs = function (x) {\n    if (x >= 0) {\n        return x;\n    } else {\n        return -x;\n    }\n};\n```\n\n如果没有`return`语句，函数执行完毕后也会返回结果，只是结果为`undefined`。\n\n+ 传入参数可以不一样，可多可少\n\n>arguments\n\n它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。`arguments`类似`Array`但它不是一个`Array`。\n\n> rest参数\n\n```js\nfunction foo(a, b, ...rest) {\n    console.log('a = ' + a);\n    console.log('b = ' + b);\n    console.log(rest);\n}\n```\n\nrest参数只能写在最后，前面用`...`标识。\n\n`return`语句和返回值分两行写会有问题！！！`return`后自动加分号！\n\n### 4.2、变量作用域\n\n如果一个变量在函数内部申明，则该变量的作用域是整个函数体。\n\n函数内部可以定义函数，如果同名函数，内部函数变量屏蔽外面的。\n\n```js\n<script>\n   function foo(...rest){\n       var x = '外部变量';\n       function inner(){\n           var x = 'A';\n           console.log(`内部函数x=${x}`);\n       }\n       inner();\n   }\n</script>\n```\n\n![image-20210206200807726](JavaScript/image-20210206200807726.png)\n\n#### 4.2.2、变量提升\n\nJavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部。\n\n#### 4.2.3、全局作用域\n\n不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象`window`，全局作用域的变量实际上被绑定到`window`的一个属性。\n\n+ 定义的函数也绑定到windows\n+ alert也是一个绑定到windows的函数\n+ 这说明JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报`ReferenceError`错误。\n\n#### 4.2.4、名字空间\n\n全局变量会绑定到`window`上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。\n\n减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：\n\n**先定义一个对象，然后定义函数还是变量都当做属性放到自己对象里！**\n\n#### 4.2.5、局部作用域\n\n由于JavaScript的变量作用域实际上是函数内部，我们在`for`循环等语句块中是无法定义具有局部作用域的变量的：\n\n**应该使用ES6中引入的`let`关键字！**\n\n#### 4.2.6、常量\n\nES6标准引入关键字`const`定义常量。\n\n#### 4.2.7、解构赋值\n\n```js\n// x, y, z分别被赋值为数组对应元素:\nvar [x, y, z] = ['hello', 'JavaScript', 'ES6'];\n\n//注意，对数组元素进行解构赋值时，多个变量要用[...]括起来。\n//如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致：\nlet [x, [y, z]] = ['hello', ['JavaScript', 'ES6']];\n\n//解构赋值还可以忽略某些元素：\nlet [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素\n\n//如果需要从一个对象中取出若干属性，也可以使用解构赋值\n'use strict';\nvar person = {\n    name: '小明',\n    age: 20,\n    gender: 'male',\n    passport: 'G-12345678',\n    school: 'No.4 middle school'\n};\nvar {name, age, passport} = person;\n```\n\n### 4.3、方法\n\n#### 4.3.1、方法的定义\n\n在一个对象中绑定函数，称为这个对象的方法。\n\n此时可以使用`this`关键字指代对象来获取并操作对象的其他属性：\n\n> 代码测试\n\n```js\n\t<script>\n        var student= {\n            name : 'Tom',\n            birth : 2000,\n            age:function(){\n                return 2021-this.birth;\n            }\n        };\n        console.log(student.age);//输出的是一个函数的定义\n        console.log(student.age());//调用了该函数\n    </script>\n```\n\n在一个方法内部，`this`是一个特殊变量，它始终指向当前对象。\n\n要保证`this`指向正确，必须用`obj.xxx()`的形式调用！\n\n**单独调用函数不带对象时：**\n\n+ use strict状态下，this指向undefined\n+ this指向window\n\n#### 4.3.2、apply\n\n要指定函数的`this`指向哪个对象，可以用函数本身的`apply`方法，它接收两个参数，第一个参数就是需要绑定的`this`变量，第二个参数是`Array`，表示函数本身的参数。\n\n另一个与`apply()`类似的方法是`call()`，唯一区别是：\n\n- `apply()`把参数打包成`Array`再传入；\n- `call()`把参数按顺序传入。\n\n比如调用`Math.max(3, 5, 4)`，分别用`apply()`和`call()`实现如下：\n\n```js\nMath.max.apply(null, [3, 5, 4]); // 5\nMath.max.call(null, 3, 5, 4); // 5\n```\n\n#### 4.4.3、装饰器\n\n利用`apply()`，我们还可以动态改变函数的行为。\n\nJavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。\n\n假设想要统计内置函数`parseInt`调用了多少次.\n\n```js\nvar count = 0;\n       var oldparseInt = parseInt;//保存windows内置函数\n       window.parseInt = function (){\n           count++;\n           return oldparseInt.apply(null,arguments);\n       }\n```\n\n### 4.4、高阶函数\n\nJavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。\n\n> 实例：\n\n```js\n<script>\n       function foo(a,b,f){\n           return f(a)+f(b);\n       }\n\n    </script>\n```\n\n`foo(1,-10,Math.abs)`==>`Math.abs(1)+Math.abs(-10)`\n\n> map\n\n假设一个数组`arr`需要对每个元素都使用某个函数处理。可以使用`arr.map(函数名)`来得到结果。\n\n```js\n<script>\n        //定义一个求平方的函数\n        function pow(x){\n            return x*x;\n        }\n       var arr = [1,2,3,4,5];\n       //求每个元素的平方\n       var result=arr.map(pow);\n        console.log(result);\n        //result=[1, 4, 9, 16, 25]\n    </script>\n```\n\n注意：`map()`传入的参数是`pow`，即函数对象本身。\n\n> reduce\n\nArray的`reduce()`把一个函数作用在这个`Array`的`[x1, x2, x3...]`上，这个函数必须接收两个参数。\n\n```js\n[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)\n```\n\n> filter\n\n它用于把`Array`的某些元素过滤掉，然后返回剩下的元素。\n\n`filter()`把传入的函数依次作用于每个元素，然后根据返回值是`true`还是`false`决定保留还是丢弃该元素。\n\n帅选出奇数：\n\n```js\n<script>\n       var arr = [1,2,3,4,5];\n       console.log(arr.filter(function (x){\n           return x%2;\n       }))\n    </script>\n```\n\n> sort\n\n它还可以接收一个比较函数来实现自定义的排序。\n\n通常规定，对于两个元素`x`和`y`，如果认为`x < y`，则返回`-1`，如果认为`x == y`，则返回`0`。\n\n> Array\n\n`Array`对象还提供了很多非常实用的高阶函数。\n\n+ `every()`方法可以判断数组的所有元素是否满足测试条件。\n+ `find()`方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回`undefined`\n\n+ `findIndex()`和`find()`类似，也是查找符合条件的第一个元素，不同之处在于`findIndex()`会返回这个元素的索引，如果没有找到，返回`-1`\n\n+ `forEach()`和`map()`类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。`forEach()`常用于遍历数组，因此，传入的函数不需要返回值.\n\n#### 4.4.1、闭包\n\n> 函数作为返回值\n\n使用高阶函数reduce求和，编写的求和函数如下：\n\n```js\n 'use strict';\n       let arr = [1,2,3,4,5];\n       function sum(arr){\n           return arr.reduce(function (x,y){\n               return x+y;\n           });\n       }\n```\n\n该函数会立刻返回结果，而把函数函数当做返回值时。\n\n```js\nfunction lazy_sum(arr){\n\tlet sum = 0;\n\tsum = function (){\n\t\treturn arr.reduce(function (x,y){\n     \t   return x+y;\n   \t \t});\n    }\n    return sum;\n}\n```\n\n当调用`lazy_sum([1,2,3,4,5])`得到的实际是一个函数，不会立刻求值！\n\n![image-20210207121206177](JavaScript/image-20210207121206177.png)\n\n**请再注意一点，当我们调用`lazy_sum()`时，每次调用都会返回一个新的函数，即使传入相同的参数。**\n\n> 闭包\n\n当一个函数返回了一个函数后，其内部的局部变量还被新函数引用。\n\n代码测试：\n\n```js\n'use strict';\n        function count() {\n            var arr = [];\n            for (var i=1; i<=3; i++) {\n                arr.push(function (){\n                    return i*i;\n                });\n                \n            }\n            return arr;\n        }\n\n        var results = count();\n        var f1 = results[0];\n        var f2 = results[1];\n        var f3 = results[2];\n```\n\n最终f1~f3引用到的i都是循环结束的i，即为4；\n\n绑定i的值：\n\n```js\n'use strict';\n        function count() {\n            var arr = [];\n            for (var i=1; i<=3; i++) {\n                arr.push((function (n) {\n                    return function () {\n                        return n * n;\n                    }\n                })(i));\n            }\n            return arr;\n        }\n\n        var results = count();\n        var f1 = results[0];\n        var f2 = results[1];\n        var f3 = results[2];\n```\n\n## 5、标准对象\n\n### 5.1、Date\n\n```js\nvar now = new Date();\n        console.log(now);\n        console.log(now.getDate());\n        console.log(now.getFullYear());\n        console.log(now.getMonth());\n        console.log(now.getDate());\n        console.log(now.getHours());\n        console.log(now.getMinutes());\n        console.log(now.getSeconds());\n        console.log(now.getDay());\n```\n\n![image-20210207124829693](JavaScript/image-20210207124829693.png)\n\n **JavaScript的Date对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。**\n\n**使用Date.parse()时传入的字符串使用实际月份01~12，转换为Date对象后getMonth()获取的月份值为0~11。**\n\n时间戳是一个自增的整数，它表示从1970年1月1日零时整的GMT时区开始的那一刻，到现在的毫秒数。\n\n### 5.2、RegExp（正则）\n\n第一种方式是直接通过`/正则表达式/`写出来，第二种方式是通过`new RegExp('正则表达式')`创建一个RegExp对象。\n\nRegExp对象的`test()`方法用于测试给定的字符串是否符合条件。\n\n> 切分字符串\n\n```js\n'a,b;; c  d'.split(/[\\s\\,\\;]+/); // ['a', 'b', 'c', 'd']\n```\n\n### 5.3、JSON\n\n在JSON中，一共就这么几种数据类型：\n\n- number：和JavaScript的`number`完全一致；\n- boolean：就是JavaScript的`true`或`false`；\n- string：就是JavaScript的`string`；\n- null：就是JavaScript的`null`；\n- array：就是JavaScript的`Array`表示方式——`[]`；\n- object：就是JavaScript的`{ ... }`表示方式。\n\n以及上面的任意组合。\n\n**并且，JSON还定死了字符集必须是UTF-8，表示多语言就没有问题了。为了统一解析，JSON的字符串规定必须用双引号`\"\"`，Object的键也必须用双引号`\"\"`。**\n\n> 序列化\n\n把json格式转字符串\n\n```js\nvar xiaoming = {\n    name: '小明',\n    age: 14,\n    gender: true,\n    height: 1.65,\n    grade: null,\n    'middle-school': '\\\"W3C\\\" Middle School',\n    skills: ['JavaScript', 'Java', 'Python', 'Lisp']\n};\nvar s = JSON.stringify(xiaoming);\nconsole.log(s);\n\n```\n\nJSON.stringify();\n\n+ 第一参数为JSON对象\n+ 第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入`Array`。还可以传入一个函数，这样对象的每个键值对都会被函数先处理。\n\n```js\nfunction convert(key, value) {\n    if (typeof value === 'string') {\n        return value.toUpperCase();\n    }\n    return value;\n}\n\nJSON.stringify(xiaoming, convert, '  ');\n```\n\n\n\n+ 第三个参数表示缩进一个空格就是换行！\n\n> 反序列化\n\n拿到一个JSON格式的字符串，我们直接用`JSON.parse()`把它变成一个JavaScript对象。\n\n## 6、面向对象\n\n面向原型继承，`__proto__`\n\n在JavaScript中，没有类的概念，只有实例化的对象！\n\n`Object.create()`方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有\n\n```js\n'use strict';\n        var Person = {\n            name : 'person',\n            age : 18,\n            speak : function (){\n                console.log('Person Speak')\n            }\n        }\n        var Student = Object.create(Person);\n        console.log(Student.name);\n```\n\n> 创建对象\n\nJavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。\n\n当我们用`obj.xxx`访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到`Object.prototype`对象，最后，如果还没有找到，就只能返回`undefined`。\n\n>构造函数\n\n除了用`{...}`创建一个对象，还可以用一种构造函数的方法。\n\n+ 先定义一个构造函数\n\n```js\nfunction Student(name){\n            this.name = name;\n            this.hello = function (){\n                alert(\"hello!!!\")\n            }\n        }\n\nvar xiaoming = new Student('xiaoming');\n        xiaoming.hello();\n```\n\n实际就是一个普通函数，但是可以使用`new`关键字来调用。\n\n*注意*，如果不写`new`，这就是一个普通函数，它返回`undefined`。但是，如果写了`new`，它就变成了一个构造函数，它绑定的`this`指向新创建的对象，并默认返回`this`，也就是说，不需要在最后写`return this;`。\n\n> class继承\n\n1、定义一个类，属性，方法\n\n`class`关键字是在ES6引入的。\n\n```js\nclass Student{\n    //构造器\n    constructor(name){\n\t\tthis.name = name;\n    }\n    //定义方法\n    hello(){\n        alert('Hello!');\n    }\n}\nvar xiaoming = new Student(\"xiaoming\");\n```\n\n2、继承\n\n`extends`关键字\n\n![image-20210207151134646](JavaScript/image-20210207151134646.png)\n\n## 7、操作BOM对象（重点）\n\n> 浏览器介绍\n\nJavaScript诞生是为了能够在浏览器中运行。\n\nBOM：浏览器对象模型。\n\n+ IE 6~11\n+ Chrome\n+ Safari\n+ FireFox\n\n以上浏览器指的是内核！\n\n> window\n\nwindow代表浏览器尺寸\n\n![image-20210207152446555](JavaScript/image-20210207152446555.png)\n\n> Navigator封装了浏览器信息\n\n![image-20210207153117495](JavaScript/image-20210207153117495.png)\n\n> screen\n\n代表屏幕。\n\n```js\nscreen.width\n1920\nscreen.height\n1080 \n```\n\n> location（重要）\n\n代表当前页面的URL信息\n\n```js\nhost: \"www.baidu.com\"\nhostname: \"www.baidu.com\"\nhref: \"https://www.baidu.com/\"\norigin: \"https://www.baidu.com\"\nlocation.assign('https://www.codefriday.cn')\n```\n\n> document\n\ndocument代表当前页面，HTML DOM文档树\n\n获取具体文档树节点，可以获取`cookie`\n\n```js\ndocument.cookie\n```\n\n劫持cookie原理：别人恶意引入一段js获取了cookie上传到服务器。\n\n> history\n\n代表浏览器的历史记录。\n\n```js\nhistory.back()//后退\nhistory.forword()//前进\n```\n\n## 8、操作DOM对象\n\nDOM：文档对象模型！\n\n> 核心\n\n浏览器网页就是一个Dom树形结构！\n\n+ 更新\n+ 遍历：得到Dom节点\n+ 删除\n+ 添加\n\n要操作个Dom节点，必须先获得这个Dom节点\n\n```js\n//类似CSS选择器\n    document.getElementsByTagName()//标签名\n    document.getElementsByClassName()//类\n    document.getElementById()//id\n```\n\n这是原生代码，尽量使用Jquery！！！\n\n> 更新节点\n\n操作文本：\n\n+ `innerText`修改文本的值\n+ `innerHTML`：修改为超文本！可以解析HTML标签！\n\n操作CSS：\n\n+ 获得节点的`style`：`id.style.color='red'`\n\n> 删除节点\n\n步骤：\n\n+ 先获取父节点\n+ 再通过父节点删除\n\n> 插入节点 \n\n通过`innerHTML`会覆盖了。\n\n追加：移动已经有的节点。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>第一个程序</title>\n</head>\n<body>\n<h1>标题</h1>\n<p id=\"p1\">hello</p>\n<div id=\"father\">\n    <p>p2</p>\n    <p>p3</p>\n    <p>p4</p>\n</div>\n<script>\n    var p1 = document.getElementById('p1');\n    var father = document.getElementById('father');\n    father.appenChild('p1');\n</script>\n</body>\n</html>\n```\n\n+ 通过js新建一个标签\n\n```js\ndocument.createElement('p');\n//修改style，使用appenChild插入\n```\n\n+ insertBefore：`parentElement.insertBefore(newElement, referenceElement);`，子节点会插入到`referenceElement`之前。\n\n## 9、操作表单\n\n> 获得信息\n\n- 文本框，对应的`<input type=\"text\">`，用于输入文本；\n- 口令框，对应的`<input type=\"password\">`，用于输入口令；\n- 单选框，对应的`<input type=\"radio\">`，用于选择一项；\n- 复选框，对应的`<input type=\"checkbox\">`，用于选择多项；\n- 下拉框，对应的`<select>`，用于选择一项；\n- 隐藏文本，对应的`<input type=\"hidden\">`，用户不可见，但表单提交时会把隐藏文本发送到服务器。\n\n`.value`获得输入框的值，对于单元框多选框值已经确定了，应该用`.checked`判断是否被选中。\n\n> 提交表单\n\n+ 表单绑定函数：`onsubmit = return yourFunction()`，函数用来校验！\n\n+ 密码框可以增加一个隐藏的密码框，给隐藏密码框name属性，再加密写回隐藏框中。\n\n## 10、JQuery\n\n其实本质就是一个封装库，更方便的使用！\n\n> 导入JQuery\n\n+ 下载https://jquery.com/download/\n\n  然后放在项目本地文件中\n\n+ 直接script引用在线的JQuery，CDN加速的链接\n\n公式：`$(selector).action();`选择器+事件。\n\n+ $代表JQuery\n+ selector代表选择器\n+ action表示绑定的事件。\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>TestJquery</title>\n    <script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"></script>\n</head>\n<body>\n<button id=\"btn\">点我</button>\n<script>\n    $('#btn').click(function (){\n        alert(\"Hello,Jquery!\");\n    })\n</script>\n</body>\n</html>\n```\n\n> 选择器\n\n```js\n$('p').click();//标签选择器\n$('#id').click();//id选择器\n$('.class').click();//类选择器\n```\n\n> 事件\n\n鼠标事件，键盘事件，其他事件\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>TestJquery</title>\n    <script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"></script>\n    <style>\n        #window{\n            width: 500px;\n            height: 500px;\n            border: 1px solid red;\n        }\n    </style>\n</head>\n<body>\n<p id=\"zb\"></p>\n<div id=\"window\">\n\n</div>\n<script>\n   $(function (){\n       $('#window').mousemove(function (e){\n           $('#zb').text('X = '+e.pageX+' Y = '+e.pageY);\n       })\n   });\n</script>\n</body>\n</html>\n```\n\n\n\n","tags":["第二阶段"],"categories":["第二阶段"]},{"title":"CSS3","url":"/2021/02/04/CSS3/","content":"\n## 1、什么是CSS\n\n层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。\n\n> 发展史\n\n`CSS1.0`\n\n`CSS2.0` DIV（块）+CSS，HTML与CSS结构分离的思想，网页变得简单，SEO\n\n`CSS2.1` 浮动，定位\n\n`CSS3.0` 圆角，阴影，动画... 浏览器兼容性\n\n> 基础语法\n\n**规范：**\n\n```html\n<style>标签中可以写CSS代码\n语法：\n    选择器{\n        声明1；\n        生命2；\n    }   \n单独写一个css文件，使用<link>标签关联\n```\n\n![image-20210204122726886](CSS3/image-20210204122726886.png)\n\n`CSS`优势：\n\n1、内容和表现分离\n\n2、网页结构表现统一，可以实现复用\n\n3、样式十分丰富\n\n4、建议使用独立于`html`的`css`文件\n\n5、利用`SEO`，容易被搜索引擎收录\n\n> CSS的四种导入方式\n\n+ 2.1、行内样式\n\n  在标签元素中，编写一个style属性，编写一个style属性，编写样式即可。\n\n+ 2.2、内部样式 \n\n  `style`标签\n\n+ 2.3、外部样式\n\n  `css`文件，`link`标签\n\n**优先级：就近原则，谁离得更近就是生效**\n\n外部样式的两种写法：\n\n+ 链接式：`link`标签，推荐\n+ 导入式：`<style>@import url(\"css/style.css\")</style>`，`CSS2.1`特有的\n\n## 2、选择器\n\n**作用：选择页面上的某一类或者或者某一个元素**\n\n### 2.1、基本选择器\n\n+ 标签选择器：选择到页面上所有这个标签的元素，一类标签\n+ 类选择器：为标签定义`class`属性，可以为任何值，使用`.class的名称{}`选择到，不同标签可以归为一类\n+ id选择器：标签id全局唯一，格式使用`#id{}`选择使用\n\n**优先级：**`id选择器>class选择器>标签选择器`\n\n### 2.2、层次选择器\n\n1、后代选择器：所有后代\n\n```css\nbody p{\n    background:red;\n}\n```\n\n2、子选择器：只选择子类\n\n```css\nbody>p{\n    background:red;\n}\n```\n\n3、相邻兄弟选择器：只对下邻居有效，只选择一个\n\n```css\n.active + p{\n\tbackground:red;\n}\n```\n\n4、通用选择器：当前选中元素后面的所有同级`p`标签\n\n```css\n.active~p{\n    background:red;\n}\n```\n\n### 2.3、结构伪类选择器\n\n伪类：条件\n\n```css\n<style>\n        /*定位到第一个元素p的父元素下的第3个子元素，计数不看种类，对同类标签才有效*/\n        h1:nth-child(3){\n            background: #3015c7;\n        }\n        /*定位第一个标签的父元素，然后数到第一个同类标签*/\n        p:nth-of-type(1){\n            background: antiquewhite;\n        }\n        /*鼠标悬浮时产生效果*/\n        h1:hover{\n            background: bisque;\n        }\n</style>\n```\n\n![image-20210204210526173](CSS3/image-20210204210526173.png)\n\n### 2.4、属性选择器（常用）\n\nid+class的结合\n\n> html代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>属性选择器 </title>\n    <style>\n        .demo a{\n            float: left;\n            display: block;\n            height: 50px;\n            width: 50px;\n            background: cyan;\n            border-radius: 5px;\n            margin-right: 5px;\n            text-align: center;\n            text-decoration: none;\n            font: bold 20px/50px Arial;\n        }\n    </style>\n</head>\n<body>\n<p class=\"demo\">\n    <a href=\"https://www.baidu.com\" class=\"links items first\" id=\"first\">1</a>\n    <a href=\"https://www.codefriday.cn\" target=\"_blank\" title=\"我的博客\">2</a>\n    <a href=\"3.pdf\" class=\"links items\">3</a>\n    <a href=\"http://\" class=\"links items\">4</a>\n    <a href=\"5.pdf\" class=\"links items\">5</a>\n    <a href=\"6.jpg\" class=\"links items\">6</a>\n    <a href=\"7.doc\" class=\"links items\" id=\"senven\">7</a>\n    <a href=\"8.doc\" class=\"links items\">8</a>\n    <a href=\"9.com\" class=\"links items\">9</a>\n    <a href=\"10.com\" class=\"links items\">10</a>\n</p>\n</body>\n</html>\n```\n\n> CSS选择\n\n```css\n/*a标签带有id属性的*/\n        a[id]{\n            background: yellowgreen;\n        }\n/*a标签id属性确定值的*/\n        a[id=senven]{\n            background: yellow;\n        }\n/*a标签class属性包含first的*/\n        a[class*=first]{\n            background: yellow;\n        }\n/*a标签href属性以https开头的元素*/\n        a[href^=https]{\n            background: yellow;\n        }\n/*a标签href属性以doc结尾的元素*/\n        a[href$=doc]{\n            background: yellow;\n        }\n```\n\n## 3、美化网页元素\n\n**span标签：重点要突出的字(约定俗成)**\n\n### 3.1、字体样式\n\n```css\nfont-family : 字体\nfont-size   : 大小\nfont-weight : 字体粗细\ncolor\t\t: 颜色\n```\n\n### 3.2、文本样式\n\n1、颜色\n\n```css\n单词\nRGB\nRGBA A表示透明度0-1\n```\n\n2、对齐方式\n\n```css\ntext-align : 排版（left,right,center）\n```\n\n3、首行缩进\n\n```css\ntext-indent:2em  em表示缩进字的个数\n```\n\n4、行高\n\n```css\nline-height:\n设置和块大小一样时，就达到上下居中的效果\n```\n\n5、装饰\n\n```css\ntext-decoration:\nline-inderline  下划线\nline-through\t中划线\nline-overline\t上划线\n```\n\n### 3.3、阴影\n\n```css\n:颜色 水平便宜（右为正） 垂直偏移（下为正） 阴影大小\ntext-shadow: aquamarine -10px -10px 1px;\n```\n\n### 3.4、列表样式\n\n未用css之前：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>列表样式练习</title>\n<!--    <link rel=\"stylesheet\" href=\"css/style.css\">-->\n</head>\n<body>\n<div id=\"nav\">\n    <h2 class=\"title\">全部商品分类</h2>\n\n    <ul>\n        <li>\n            <a href=\"#\">图书</a>\n            <a href=\"#\">音像</a>\n            <a href=\"#\">数字商品</a>\n        </li>\n        <li>\n            <a href=\"#\">家用电器</a>\n            <a href=\"#\">手机</a>\n            <a href=\"#\">数码</a>\n        </li>\n        <li>\n            <a href=\"#\">电脑</a>\n            <a href=\"#\">办公</a>\n        </li>\n        <li>\n            <a href=\"#\">家居</a>\n            <a href=\"#\">家装</a>\n            <a href=\"#\">厨具</a>\n        </li>\n        <li>\n            <a href=\"#\">服饰鞋帽</a>\n            <a href=\"#\">个性化妆</a>\n        </li>\n        <li>\n            <a href=\"#\">礼品箱包</a>\n            <a href=\"#\">钟表</a>\n            <a href=\"#\">珠宝</a>\n        </li>\n        <li>\n            <a href=\"#\">食品饮料</a>\n            <a href=\"#\">保健食品</a>\n        </li>\n        <li>\n            <a href=\"#\">彩票</a>\n            <a href=\"#\">旅行</a>\n            <a href=\"#\">充值</a>\n            <a href=\"#\">票务</a>\n        </li>\n    </ul>\n</div>\n\n\n</body>\n</html>\n```\n\n![image-20210205143007074](CSS3/image-20210205143007074.png)\n\n> CSS美化\n\n```css\n#nav{\n    width: 300px;\n    height: 350px;\n    background: aliceblue;\n}\n.title{\n    background: orangered;\n    text-indent: 2em;\n    font-size: 20px;\n    font-weight: bold;\n    line-height: 40px;\n}\nul li{\n    height: 30px;\n    list-style: none;\n    text-indent: 1em;\n}\na{\n    text-decoration: none;\n    font-size: 14px;\n    color: #000000;\n}\na:hover{\n    color: orangered;\n    text-decoration: underline;\n\n}\n```\n\n![image-20210205143058092](CSS3/image-20210205143058092.png)\n\n### 3.5、背景\n\n+ 背景颜色\n+ 背景图片\n\n### 3.6、渐变\n\n开源调色项目：https://www.grabient.com/\n\n+ 径向渐变\n+ 圆形渐变\n\n![image-20210205150002604](CSS3/image-20210205150002604.png)\n\n## 4、盒子模型\n\n### 4.1、什么是盒子\n\n![image-20210205150229956](CSS3/image-20210205150229956.png)\n\n`margin`：外边距\n\n`border`：边框\n\n`padding`：内边距\n\n### 4.2、边框\n\n+ 样式\n\n+ 粗细\n\n+ 颜色\n\n> 练习\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>CodeFriday</title>\n    <style>\n        body{\n            margin: 0;\n        }\n        .main{\n            position: absolute;\n            margin: 0px;\n            width: 100%;\n            height: 100%;\n            background-color: #8EC5FC;\n            background-image: linear-gradient(62deg, #8EC5FC 0%, #E0C3FC 100%);\n        }\n        .UI{\n            margin: 0 auto;\n            width: 60%;\n            height: 98.5%;\n            border: #ffa200 5px solid;\n            border-radius: 20px;\n        }\n        .message_show{\n            width: 75%;\n            height: 70%;\n            border: #bbc1d5 5px solid;\n            border-radius: 20px;\n        }\n        .message_send{\n            width: 75%;\n            height: 27.2%;\n            border: #f60404 5px solid;\n            border-radius: 20px;\n        }\n        .user_list{\n            position: absolute;\n            top: 5px;\n            left:66%;\n            height: 97%;\n            width: 13.4%;\n            border: #f60404 5px solid;\n            border-radius: 20px;\n        }\n    </style>\n</head>\n<body>\n<div class=\"main\">\n    <!--UI界面-->\n    <div class=\"UI\">\n        <div class=\"message_show\">\n\n        </div>\n        <div class=\"message_send\">\n\n        </div>\n        <div class=\"user_list\">\n\n        </div>\n    </div>\n\n</div>\n</body>\n</html>\n```\n\n![image-20210205170344398](CSS3/image-20210205170344398.png)\n\n### 4.3、圆角边框\n\n```css\nborder-radius:\n顺时针方向4个参数！最多为块边长一半！\n```\n\n### 4.4、盒子阴影\n\n```css\nbox-shadow: #85FFBD 0px 0px 100px;\n颜色，水平偏移，垂直偏移，阴影半径\n```\n\n## 5、浮动\n\n### 5.1、标准文档流\n\n自上而下布局\n\n+ 块级元素：独占一行\n\n```css\nh1~h6 p div 列表...\n```\n\n+ 行内元素，不独占一行\n\n```css\nspan a img strong...\n```\n\n行内元素可以包含在块级元素中，反之不可以\n\n### 5.2、display\n\n`block`：块元素\n\n`inline-block`：行内、块级元素\n\n`inline`：行内元素\n\n`none`：消失\n\n### 5.3、浮动\n\n`float: left;`\n\n`float: right;`\n\n### 5.4、父级边框塌陷问题\n\n> clear清除浮动\n\n`left`：左侧不允许有浮动元素，有就排到下一行\n\n`right`：右侧不允许有浮动元素，有就排到下一行\n\n`both`：两侧 \n\n> 解决方案：\n\n1、增加父级元素高度\n\n2、增加一个空的div标签，清除浮动\n\n```html\n<div class=\"clear\"></div>\n.clear{\n    margin: 0;\n    padding: 0;\n    clear: both;\n}\n```\n\n3、overflow\n\n在父级元素中增加一个overflow属性`overflow:hidden;`\n\n4、父类添加伪类：after(推荐！)\n\n```css\n#father:after{\n    content:''\n    display:block;\n    clear:both;\n}\n```\n\n## 6、定位\n\n### 6.1、相对定位\n\n相对自己原来的位置偏移，保留原来的位置\n\n![image-20210205201843802](CSS3/image-20210205201843802.png)\n\n```java\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        #father{\n            border: 2px solid red;\n            padding: 5px;\n            width: 300px;\n            height: 300px;\n        }\n        a{\n            width: 100px;\n            height: 100px;\n            text-decoration: none;\n            text-align: center;\n            color: #FFFFFF;\n            background: pink;\n            line-height: 100px;\n            display: block;\n        }\n        a:hover{\n            background: blue;\n        }\n        .link1{\n            position: relative;\n            top: -100px;\n            left: 200px;\n        }\n        .link2{\n            position: relative;\n            top: -100px;\n            left: 100px;\n        }\n        .link3{\n            position: relative;\n            top: -100px;\n        }\n        .link4{\n            position: relative;\n            top: -200px;\n            left: 200px;\n        }\n    </style>\n</head>\n<body>\n<div id=\"father\">\n    <a class=\"link0\" href=\"https:www.baidu.com\">链接1</a>\n    <a class=\"link1\" href=\"https:www.codefriday.vn\">链接2</a>\n    <a class=\"link2\" href=\"#\">链接3</a>\n    <a class=\"link3\" href=\"#\">链接4</a>\n    <a class=\"link4\" href=\"#\">链接5</a>\n</div>\n</body>\n</html>\n```\n\n### 6.2、绝对定位\n\n定位：基于xxx定位\n\n1、父元素没有定位时，基于浏览器定位。\n\n2、假设父级元素存在定位，通常会基于父级元素绝对定位\n\n3、在父级元素范围类移动\n\n绝对定位不保留原来的位置\n\n### 6.3、固定定位fixed\n\n固定在了浏览器窗口上！\n\n### 6.4、Z-index\n\n图层的概念。\n\n\n\n\n\n\n\n","tags":["第二阶段"],"categories":["第二阶段"]},{"title":"HTML5","url":"/2021/02/03/HTML5/","content":"\n## 什么是HTML\n\n- HTML 指的是超文本**标记语言**: **H**yper**T**ext **M**arkup **L**anguage\n\n- HTML 不是一种编程语言，而是一种**标记**语言\n- 标记语言是一套**标记标签** (markup tag)\n- HTML 使用标记标签来**描述**网页\n- HTML 文档包含了HTML **标签**及**文本**内容\n- HTML文档也叫做 **web 页面**\n\n> W3C标准\n\n+ **W3C**\n\n  + World Wide Web Consortium（万维网联盟）\n  + 成立于1994年，Web技术领域最权威和具有影响力的国际**中立性技术标准机构**\n\n  + http://www.w3.org/\n  + http://www.chinaw3.org/\n\n+ **W3C包括**\n  + **结构**化标准语言（HTML、XML）\n  + **表现**标准语言（CSS）\n  + **行为**标准语言（DMO、ECMAScript）\n\n> HTML基本结构\n\n![image-20210203181741075](HTML5/image-20210203181741075.png)\n\n```html\n<!-- DOCTYPE：告诉浏览器，我们要使用什么规范 -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<!-- head标签表示网页头部 -->\n<head>\n    <!-- meta标签，一般用来描述网页信息 -->\n    <!-- meta标签一般用来做SEO -->\n    <meta charset=\"UTF-8\">\n    <!-- title-网页标题 -->\n    <title>Title</title>\n</head>\n<-- body标签代表网页主体 -->\n<body>\n\n</body>\n</html>\n```\n\n## 网页基本标签\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>基本标签</title>\n</head>\n<body>\n<!--标题标签-->\n<h1>一级标签</h1>\n<h2>二级标签</h2>\n<h3>三级标签</h3>\n<h4>四级标签</h4>\n<h5>五级标签</h5>\n\n<!--段落标签-->\n<p>第一段文字    hello</p>\n<p>第二段文字    world</p>\n\n<!--水平线标签-->\n<hr/>\n\n<!--换行标签-->\n<!--和段落标签间隙不太一样-->\n第一段文字    hello<br/>\n第二段文字    world\n\n<!--字体样式标签-->\n<h1>字体样式</h1>\n<strong>这是粗体</strong>\n<em>这是斜体</em>\n\n<!--特殊符号-->\n空   格\n空&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;格\n<br/>\n&gt;大于\n<br/>\n&lt;\n<br/>\n&copf;版权\n</body>\n</html>\n```\n\n## 图像标签\n\n ![image-20210203185225896](HTML5/image-20210203185225896.png)\n\n`src`和`alt`必填。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<img src=\"../resource/image/1.png\" alt=\"codefriday\" title=\"我的头像\" width=\"200\" height=\"200\">\n</body>\n</html>\n```\n\n## 链接标签\n\n![image-20210203190605136](HTML5/image-20210203190605136.png)\n\n+ `href`标签：必填，表示链接地址。\n\n+ `target`标签：表示窗口在哪里打开\n  + _bank：在新标签打开\n  + _self：在自己的网页中打开\n\n> 页面链接：页面之间的跳转\n\n> 锚链接\n\n+ 定义一个标记点\n+ 通过`#标记名`跳转\n\n> 功能性链接\n\n例如：mailto\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>链接标签学习</title>\n</head>\n<body>\n<a name=\"top\">顶部</a>\n<a href=\"1.我的第一个网页.html\">页面一</a><br/>\n<a href=\"https://www.codefriday.cn\" target=\"_top\"><img src=\"../resource/image/1.png\" alt=\"codefriday\" title=\"我的头像\" width=\"200\" height=\"200\"></a>\n<p><img src=\"../resource/image/1.png\" alt=\"codefriday\" title=\"我的头像\" width=\"200\" height=\"200\"></p>\n<p><img src=\"../resource/image/1.png\" alt=\"codefriday\" title=\"我的头像\" width=\"200\" height=\"200\"></p>\n<p><img src=\"../resource/image/1.png\" alt=\"codefriday\" title=\"我的头像\" width=\"200\" height=\"200\"></p>\n<p><img src=\"../resource/image/1.png\" alt=\"codefriday\" title=\"我的头像\" width=\"200\" height=\"200\"></p>\n<p><img src=\"../resource/image/1.png\" alt=\"codefriday\" title=\"我的头像\" width=\"200\" height=\"200\"></p>\n<a href=\"#top\">回到顶部</a>\n\n<!--功能性链接-->\n<a href=\"mailto:853851430@qq.com\">邮箱</a>\n</body>\n</html>\n```\n\n## 行内元素和块元素\n\n+ 块元素\n  + 无论多少内容，该元素独占一行\n  + （p、h1-h6...)\n\n+ 行内元素\n  + 内容撑开的元素，左右都是行内元素的可以排在一行\n\n## 列表\n\n**分类：**\n\n+ 无序列表\n+ 有序列表\n+ 自定义列表\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>列表学习</title>\n</head>\n<body>\n<!--有序列表-->\n<ol>\n    <li>JAVA</li>\n    <li>多线程</li>\n    <li>网络编程</li>\n    <li>JUI</li>\n    <li>JVM</li>\n</ol>\n<hr/>\n<!--无序列表-->\n<ul>\n    <li>code</li>\n    <li>friday</li>\n    <li>hello</li>\n    <li>world</li>\n</ul>\n<hr/>\n<!--自定义列表\ndl:标签\ndt:列表名称\ndd:列表名字\n\n-->\n<dl>\n    <dt>学科</dt>\n    <dd>JAVA</dd>\n    <dd>Python</dd>\n    <dd>C/C++</dd>\n\n    <dt>地址</dt>\n    <dd>北京</dd>\n    <dd>天津</dd>\n</dl>\n</body>\n</html>\n```\n\n## 表格标签\n\n+ `table`：表格标签\n+ `tr`：行标签\n+ `td`：列标签\n+ `tr colspan=“3”`：跨列\n+ `td rowspan=”2“`：跨行\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>表格学习</title>\n</head>\n<body>\n<table border=\"1px\">\n    <tr>\n        <td colspan=\"3\">1-1</td>\n        <td>1-2</td>\n        <td>1-3</td>\n    </tr>\n    <tr>\n        <td rowspan=\"2\">2-1</td>\n        <td>2-2</td>\n        <td>2-3</td>\n    </tr>\n    <tr>\n        <td>3-1</td>\n        <td>3-2</td>\n        <td>3-3</td>\n    </tr>\n</table>\n</body>\n</html>\n```\n\n## 媒体元素\n\n**视频和音频**\n\n> 视频元素：video\n\n+ src：资源路径\n+ controls：控制栏\n+ autoplay：自动播放\n\n> 音频元素：audio\n\n+ src：资源路径\n+ controls：控制栏\n+ autoplay：自动播放\n\n## 页面结构分析\n\n![image-20210203205202540](HTML5/image-20210203205202540.png)\n\n## iframe内联框架\n\n![image-20210203205924465](HTML5/image-20210203205924465.png)\n\n> 测试代码\n\n```java\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>iframe框架</title>\n</head>\n<body>\n<iframe src=\"\" name=\"hello\" frameborder=\"0\" width=\"1000px\" height=\"500px\" ></iframe>\n<a href=\"https://www.codefriday.cn\" target=\"hello\">点我跳转</a>\n</body>\n</html>\n```\n\n## 表单提交\n\n> 表单语法\n\n![image-20210203210834670](HTML5/image-20210203210834670.png)\n\n+ get方式：url中可以直接看到参数，较为不安全，但高效\n+ post方式：url中看不到参数\n\n> 表单元素格式：\n\n![image-20210203212528740](HTML5/image-20210203212528740.png)\n\n## 单选框\n\n+ `input type=\"radio\"`\n+ `value`：单选框的值\n+ `name`：表示组，同一组只能选择一个\n\n## 多选框和按钮\n\n```html\n<!--多选框-->\n        <p>爱好：\n            <input type=\"checkbox\" value=\"play\" name=\"hobby\">玩\n            <input type=\"checkbox\" value=\"game\" name=\"hobby\">游戏\n            <input type=\"checkbox\" value=\"coding\" name=\"hobby\">写代码\n        </p>\n```\n\n> input的value属性\n\n+ `button`：按钮标签\n+ `image`：也是一个按钮，会提交表单\n+ `submit`：提交表单按钮\n+ `reset`：清空表单按钮\n\n+ `file`：文件域\n+ `range`：滑块\n\n## 列表框、文本域、文件域\n\n> 列表框\n\n```html\n<!--下拉框-->\n\n<p>国家：\n    <select name=\"列表名称\" id=\"\">\n        <option value=\"china\" selected>中国</option>\n        <option value=\"US\" >美国</option>\n        <option value=\"UC\">英国</option>\n    </select>\n</p>\n```\n\n> 文本域\n\n```html\n<!--文本域-->\n        <p>自我简介：\n            <textarea name=\"intro\" cols=\"30\" rows=\"10\"></textarea>\n        </p>\n<!--文件域-->\n        <p>提交简历:\n            <input type=\"file\" name=\"files\"><input type=\"button\" value=\"上传\">\n        </p>\n```\n\n","tags":["第二阶段"],"categories":["第二阶段"]},{"title":"JUC并发编程","url":"/2021/01/31/JUC并发编程/","content":"\n## 1、什么是JUC\n\nJUC是`java.util.concurrent`简称，主要包含以下几个包\n\n- `java.util.concurrent`\n- `java.util.concurrent.atomic`\n- `java.util.concurrent.locks`\n\n## 2、线程与进程\n\n> 线程的状态：\n\n```java\npublic enum State {\n        NEW,\n        RUNNABLE,\n        BLOCKED,\n        WAITING,\n        TIMED_WAITING,\n        TERMINATED;\n    }\n```\n\n> sleep和wait的区别\n\n**（1）来自不同的类**\n\nwait => Object\n\nsleep => Thread\n\n**（2）关于锁的释放**\n\nwait会释放锁，但sleep不会\n\n## 3、Lock锁\n\n> 传统synchronized，锁+队列\n\n1、修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； \n\n2、修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； \n\n3、修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； \n\n4、修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。\n\n```java\npackage com.codefriday;\n\npublic class Demo01 {\n    public static void main(String[] args) {\n        Ticket t1 = new Ticket();\n        new Thread(()->{for(int i = 0;i < 40;i++) t1.buy();},\"A\").start();\n        new Thread(()->{for(int i = 0;i < 40;i++) t1.buy();},\"A\").start();\n        new Thread(()->{for(int i = 0;i < 40;i++) t1.buy();},\"A\").start();\n\n    }\n\n    static class Ticket {\n        private int tickets = 30;\n\n        synchronized void buy() {\n            if (tickets > 0)\n                System.out.println(Thread.currentThread().getName() + \"买到了第\" + (tickets--) + \"张票，剩余：\" + tickets);\n        }\n    }\n}\n\n```\n\n\n\n> Lock接口\n\n![image-20210131124819662](JUC并发编程/image-20210131124819662.png)\n\n![image-20210131131956970](JUC并发编程/image-20210131131956970.png)\n\n```java\npackage com.codefriday;\n\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Demo02 {\n    public static void main(String[] args) {\n        Ticket1 t1 = new Ticket1();\n        new Thread(()->{for(int i = 0;i < 40;i++) t1.buy();},\"A\").start();\n        new Thread(()->{for(int i = 0;i < 40;i++) t1.buy();},\"A\").start();\n        new Thread(()->{for(int i = 0;i < 40;i++) t1.buy();},\"A\").start();\n\n    }\n\n    static class Ticket1 {\n        private int tickets = 30;\n        ReentrantLock lock = new ReentrantLock();\n        void buy() {\n            try {\n                lock.lock();\n                if (tickets > 0)\n                    System.out.println(Thread.currentThread().getName() + \"买到了第\" + (tickets--) + \"张票，剩余：\" + tickets);\n            }catch (Exception e){\n                e.printStackTrace();\n            }finally {\n                lock.unlock();\n            }\n\n        }\n    }\n}\n\n```\n\n> Synchronized 和 Lock区别\n\n1、`Synchronized `是内置的java关键字，`Lock`是一个类\n\n2、`Synchronized `无法判断获取锁的状态，Lock可以判断\n\n3、`Synchronized`会自动释放锁，Lock必须手动释放，不释放会导致死锁。\n\n4、`Synchronized`（线程1：阻塞，线程2：等待）；Lock锁不一定会一直等待下去。\n\n5、`Synchronized`是可重入锁，不可以中断的，非公平；Lock，可重入，可判断锁，公平性可自己设置。\n\n6、`Synchronized`适合锁少量的代码同步问题；Lock适合大量同步代码。\n\n## 4、生产者/消费者问题\n\n> 单值缓冲区，单生产者，单消费者，Synchronized\n\n**判断等待，业务，通知**\n\n```java\npackage com.codefriday.PC;\n\n/***\n * 生产者消费者问题\n * 缓冲区大小为1\n */\npublic class Test {\n    public static void main(String[] args) {\n        Buffer buffer = new Buffer();\n        new Thread(()-> {\n            try {\n                for (int i = 0; i < 10; i++) {\n                    buffer.increment();\n                }\n\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        },\"A\").start();\n\n\n        new Thread(()-> {\n            try {\n                for (int i = 0; i < 10; i++) {\n                    buffer.decrement();\n                }\n\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        },\"B\").start();\n    }\n}\nclass Buffer{\n    private int num = 0;\n    synchronized void increment() throws InterruptedException {\n        if(num!=0){\n            this.wait();\n        }\n        num++;\n        System.out.println(Thread.currentThread().getName()+\"==>\"+num);\n        this.notifyAll();\n    }\n    synchronized void decrement() throws InterruptedException {\n        if(num==0){\n            this.wait();\n        }\n        num--;\n        System.out.println(Thread.currentThread().getName()+\"==>\"+num);\n        this.notifyAll();\n    }\n}\n```\n\n> 多生产者，多消费者时，if判断有问题\n\n会出现虚假唤醒！！！\n\n![image-20210131135810795](JUC并发编程/image-20210131135810795.png)\n\n**解决方案：if改为while**\n\n> JUC中生产者/消费者问题 Condition\n\n必须使用两个条件变量量保证，因为消费者可能唤醒消费者，导致所有线程睡眠！\n\n```java\npackage com.codefriday.PC;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/***\n * @author CodeFriday \n */\npublic class Test2 {\n    public static void main(String[] args) {\n        Buffer1 buffer = new Buffer1();\n        new Thread(()-> {\n            for (int i = 0; i < 20; i++) {\n                try {\n                    buffer.increment();\n                }\n                catch(Exception e){\n                    e.printStackTrace();\n                }\n            }\n        },\"A生产者\").start();\n\n\n        new Thread(()-> {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    buffer.decrement();\n                }\n                catch(Exception e){\n                    e.printStackTrace();\n                }\n            }\n        },\"B消费者\").start();\n\n        new Thread(()-> {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    buffer.decrement();\n                }\n                catch(Exception e){\n                    e.printStackTrace();\n                }\n            }\n        },\"C消费者\").start();\n    }\n}\nclass Buffer1{\n    private int num = 0;\n    ReentrantLock lock  = new ReentrantLock();\n    Condition empty = lock.newCondition();\n    Condition full = lock.newCondition();\n    void increment(){\n        lock.lock();\n        try {\n            while(num!=0){\n                empty.await();\n            }\n            num++;\n            System.out.println(Thread.currentThread().getName()+\"==>\"+num);\n            full.signal();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n\n    }\n    void decrement(){\n        lock.lock();\n        try {\n            while(num==0){\n                full.await();\n            }\n            num--;\n            System.out.println(Thread.currentThread().getName()+\"==>\"+num);\n            empty.signal();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n> condition精准唤醒\n\n背景：一个资源类，其中三个方法，负责打印A，B，C，三个线程操作资源类，一个线程循环调用一种，但是必须安装ABC循环的顺序输出。\n\n```java\npackage com.codefriday.PC;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/***\n * @author CodeFriday \n */\npublic class Test3 {\n    public static void main(String[] args) {\n        Buffer3 buffer3 = new Buffer3();\n        new Thread(()->{\n            for(int i = 0;i < 10;i++){\n                buffer3.PrintA();\n            }\n        }).start();\n        new Thread(()->{\n            for(int i = 0;i < 10;i++){\n                buffer3.PrintB();\n            }\n        }).start();\n        new Thread(()->{\n            for(int i = 0;i < 10;i++){\n                buffer3.PrintC();\n            }\n        }).start();\n    }\n}\nclass Buffer3{\n    ReentrantLock lock = new ReentrantLock();\n    Condition c1 = lock.newCondition();\n    Condition c2 = lock.newCondition();\n    Condition c3 = lock.newCondition();\n    private int num = 1;\n    void PrintA(){\n        lock.lock();\n        try {\n            while(num!=1){\n                c1.await();\n            }\n            System.out.println(\"A\");\n            num++;\n            c2.signal();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n    void PrintB(){\n        lock.lock();\n        try {\n            while(num!=2){\n                c2.await();\n            }\n            System.out.println(\"B\");\n            num++;\n            c3.signal();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n    void PrintC(){\n        lock.lock();\n        try {\n            while(num!=3){\n                c3.await();\n            }\n            System.out.println(\"C\");\n            num=1;\n            c1.signal();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n```\n\n## 5、八锁现象\n\n> 场景一：主函数确保了两个线程调用同步方法的顺序，先打印 发短信 后打印 打电话\n>\n> 答案：发短信\n>\n> 原因：synchronized修饰的方法锁的是调用该方法的对象，也就是new出来的phone\n\n```java\npackage com.codefriday.EightLock;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class Scene1 {\n    public static void main(String[] args) {\n        Phone1 phone = new Phone1();\n        new Thread(()->{\n            phone.sendSms();\n        }).start();\n\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        new Thread(()->{\n            phone.call();\n        }).start();\n    }\n}\nclass Phone1{\n    public synchronized void sendSms(){\n        System.out.println(\"发短信\");\n    }\n    public synchronized void call(){\n        System.out.println(\"打电话\");\n    }\n}\n\n```\n\n> 场景二：给打电话方法加上休眠4秒，谁先输出\n>\n> 答案：发短信\n>\n> 原因：被 synchronized 修饰的方式，锁的对象是方法的调用者\n>\n> 调用的是同一个对象\n\n```java\npackage com.codefriday.EightLock;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class Scene2 {\n    public static void main(String[] args) {\n        Phone2 phone = new Phone2();\n        new Thread(()->{\n            phone.sendSms();\n        }).start();\n\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        new Thread(()->{\n            phone.call();\n        }).start();\n    }\n}\nclass Phone2{\n    public synchronized void sendSms(){\n        try {\n            TimeUnit.SECONDS.sleep(4);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"发短信\");\n    }\n    public synchronized void call(){\n        System.out.println(\"打电话\");\n    }\n}\n```\n\n> 场景三：去掉call方法synchronized，谁先输出\n>\n> 答案：打电话\n>\n> 原因：无synchronized修饰不受锁的影响，发短信线程获得锁休眠对其无影响\n\n```java\npackage com.codefriday.EightLock;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class Scene3 {\n    public static void main(String[] args) {\n        Phone3 phone = new Phone3();\n        new Thread(()->{\n            phone.sendSms();\n        }).start();\n\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        new Thread(()->{\n            phone.call();\n        }).start();\n    }\n}\nclass Phone3{\n    public synchronized void sendSms(){\n        try {\n            TimeUnit.SECONDS.sleep(4);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"发短信\");\n    }\n    public void call(){\n        System.out.println(\"打电话\");\n    }\n}\n```\n\n> 场景四：两个方法都用synchronized修饰，但是两个线程调用不同对象的方法，谁先输出\n>\n> 答案：打电话\n>\n> 原因：发短信线程休眠锁的对象是phone，但是打电话线程需要的对象是phone_1互不影响\n\n```java\npackage com.codefriday.EightLock;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class Scene4 {\n    public static void main(String[] args) {\n        Phone4 phone = new Phone4();\n        Phone4 phone_1 = new Phone4();\n        new Thread(()->{\n            phone.sendSms();\n        }).start();\n\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        new Thread(()->{\n            phone_1.call();\n        }).start();\n    }\n}\nclass Phone4{\n    public synchronized void sendSms(){\n        try {\n            TimeUnit.SECONDS.sleep(4);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"发短信\");\n    }\n    public synchronized void call(){\n        System.out.println(\"打电话\");\n    }\n}\n```\n\n> 场景五：同步方法加static修饰，谁先输出？\n>\n> 答案：发短信\n>\n> 原因：只要方法被 static 修饰，锁的对象就是 Class模板对象,这个则全局唯一！\n\n```java\npackage com.codefriday.EightLock;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class Scene5 {\n    public static void main(String[] args) {\n        Phone5 phone = new Phone5();\n        new Thread(()->{\n            phone.sendSms();\n        }).start();\n\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        new Thread(()->{\n            phone.call();\n        }).start();\n    }\n}\nclass Phone5{\n    public static synchronized void sendSms(){\n        try {\n            TimeUnit.SECONDS.sleep(4);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"发短信\");\n    }\n    public static synchronized void call(){\n        System.out.println(\"打电话\");\n    }\n}\n\n```\n> 场景六：把call的static去掉，谁先输出？\n>\n> 答案：打电话\n>\n> 原因：第一个线程调用sendSms由于是静态同步方法，锁的是class类模板，而第二个线程调用call需要的是对象phone的锁。\n\n```java\npackage com.codefriday.EightLock;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class Scene6 {\n    public static void main(String[] args) {\n        Phone6 phone = new Phone6();\n\n        new Thread(()->{\n            phone.sendSms();\n        }).start();\n\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        new Thread(()->{\n            phone.call();\n        }).start();\n    }\n}\nclass Phone6{\n    public static synchronized void sendSms(){\n        try {\n            TimeUnit.SECONDS.sleep(4);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"发短信\");\n    }\n    public synchronized void call(){\n        System.out.println(\"打电话\");\n    }\n}\n\n```\n\n> 场景七：static+synchronized修饰两个方法，调用不同对象的方法，谁先输出\n>\n> 答案：发短信\n>\n> 原因：static修饰锁定的class类模板，全局唯一\n\n```java\npackage com.codefriday.EightLock;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class Scene7 {\n    public static void main(String[] args) {\n        Phone7 phone = new Phone7();\n        Phone7 phone_1 = new Phone7();\n\n        new Thread(()->{\n            phone.sendSms();\n        }).start();\n\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        new Thread(()->{\n            phone_1.call();\n        }).start();\n    }\n}\nclass Phone7{\n    public static synchronized void sendSms(){\n        try {\n            TimeUnit.SECONDS.sleep(4);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"发短信\");\n    }\n    public static synchronized void call(){\n        System.out.println(\"打电话\");\n    }\n}\n\n```\n\n> 场景八：把call方法static去掉，两个线程调用两个对象的方法，谁先输出？\n>\n> 答案：打电话\n>\n> 原因：第一个线程锁的是类模板，第二个锁的是phone_1，互补影响\n\n```java\npackage com.codefriday.EightLock;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class Scene8 {\n    public static void main(String[] args) {\n        Phone8 phone = new Phone8();\n        Phone8 phone_1 = new Phone8();\n\n        new Thread(()->{\n            phone.sendSms();\n        }).start();\n\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        new Thread(()->{\n            phone_1.call();\n        }).start();\n    }\n}\nclass Phone8{\n    public static synchronized void sendSms(){\n        try {\n            TimeUnit.SECONDS.sleep(4);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"发短信\");\n    }\n    public synchronized void call(){\n        System.out.println(\"打电话\");\n    }\n}\n\n```\n\n## 6、集合类不安全\n\n> List不安全\n\n```java\npackage com.codefriday.UnSafe;\n\nimport java.util.*;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\npublic class TestList {\n    public static void main(String[] args) {\n        /**\n         * 报错：List<String> list = new ArrayList<String>();\n         * 解决方案：\n         * 1、List<String> list = new Vector<>();\n         * 2、List<String> list = Collections.synchronizedList(new ArrayList<>());\n         * 3、List<String> list = new CopyOnWriteArrayList<>();\n         *\n         * CopyOnWrite：写入时复制 COW\n         * 读写分离，写入时先复制一份，写完覆盖回去\n         */\n\n        List<String> list = new CopyOnWriteArrayList<>();\n        for(int i = 0;i < 10;i++){\n            new Thread(()->{\n                list.add(UUID.randomUUID().toString().substring(0,5));\n                System.out.println(list);\n            }).start();\n        }\n    }\n}\n\n```\n\n`CopyOnWriteArrayList`方法源码：\n\n```java\npublic boolean add(E e) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            Object[] elements = getArray();\n            int len = elements.length;\n            Object[] newElements = Arrays.copyOf(elements, len + 1);\n            newElements[len] = e;\n            setArray(newElements);\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n\n> Set不安全\n\n```java\npackage com.codefriday.UnSafe;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.CopyOnWriteArraySet;\n\npublic class TestSet {\n    public static void main(String[] args) {\n        /**\n         * Set<String> set = new HashSet<>();\n         * 报错java.util.ConcurrentModificationException\n         * 解决方案：\n         * 1、Set<String> set = Collections.synchronizedSet(new HashSet<>());\n         * 2、JUC下的 Set<String> set = new CopyOnWriteArraySet<>();\n         */\n        Set<String> set = new CopyOnWriteArraySet<>();\n        for (int i = 1; i <= 30; i++) {\n            new Thread(()->{\n                set.add(UUID.randomUUID().toString().substring(0,5));\n                System.out.println(set);\n            },String.valueOf(i)).start();\n        }\n    }\n}\n\n```\n\n`HashSet`底层：`HashMap`\n\n```java\npublic HashSet() {\n        map = new HashMap<>();\n    }\n\n```\n\n`add`方法：将加入`set`集合的对象作为`Hashmap`的`key`来保证不重复！\n\n```java\npublic boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n}\n// Dummy value to associate with an Object in the backing Map\n    private static final Object PRESENT = new Object();\n```\n\n> HashMap不安全\n\n`HashMap`不安全分`JDK`版本，一般1.8和1.7\n\n1.7版本之前`HashMap`实现数组+链表（冲突解决策略）\n\n1.8版本之后多引入红黑树，解决冲突链表过长问题\n\n**HashMap**\n\n+ 1.7版本中`HashMap`链表使用头插法，并发会出现死循环\n\n+ 1.8版本中HashMap采用尾插法，但是并发导致节点覆盖\n\n**ConcurrentHashMap**\n\n+ 1.7版本采用分段锁实现\n+ 1.8版本采用`CAS` + `synchronized`\n\n测试：\n\n```java\npackage com.codefriday.UnSafe;\n\nimport java.util.HashMap;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class TestMap {\n    public static void main(String[] args) {\n        /**\n         * ConcurrentModificationException\n         * HashMap<String, Integer> hashMap = new HashMap<>();\n         * 解决方案： ConcurrentHashMap<String, Integer> hashMap = new ConcurrentHashMap<>();\n         * \n         */\n        ConcurrentHashMap<String, Integer> hashMap = new ConcurrentHashMap<>();\n        for (int i = 0; i < 20; i++) {\n            new Thread(()->{\n                hashMap.put(UUID.randomUUID().toString().substring(0,5),0);\n                System.out.println(hashMap);\n            }).start();\n\n        }\n    }\n}\n\n```\n\n## 7、Callable\n\n![image-20210131173417268](JUC并发编程/image-20210131173417268.png)\n\n**相比Runnable的好处：**\n1、可以返回值\n\n2、可以抛出异常\n\n![image-20210131185551879](JUC并发编程/image-20210131185551879.png)\n\n> 测试代码\n\n```java\npackage com.codefriday.TestCallable;\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\npublic class Test {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        MyThread thread = new MyThread();\n        FutureTask task = new FutureTask(thread);\n        new Thread(task).start();\n        new Thread(task).start();\n        System.out.println(task.get());\n    }\n}\nclass MyThread implements Callable<Integer>{\n    @Override\n    public Integer call() throws Exception {\n        System.out.println(\"==>call()\");\n        return 1024;\n    }\n}\n\n```\n\n注意：\n1、get方法获得返回值会阻塞。\n\n2、有缓存，上述代码只输出一次\"==>call()\"\n\n## 8、常用的辅助类\n\n### 8.1、CountDownLatch\n\n> JDK文档描述\n\n![image-20210131190803277](JUC并发编程/image-20210131190803277.png)\n\n> 测试代码\n\n ```java\npackage com.codefriday;\n\nimport java.util.concurrent.CountDownLatch;\n\npublic class TestCountDownLatch {\n    public static void main(String[] args) throws InterruptedException {\n        CountDownLatch count = new CountDownLatch(10);\n        for(int i = 1;i <= 10;i++){\n            new Thread(()->{\n                System.out.println(Thread.currentThread().getName()+\" go out!\");\n                count.countDown();\n            },String.valueOf(i)).start();\n        }\n        count.await();//如果计数器不为0，此方法会阻塞，不会继续往下执行\n        System.out.println(\"Close door!\");//一定最后输出！\n    }\n}\n\n ```\n\n实际就是一个减法计数器。\n\n原理：\n\n`CountDownLatch.countDown();`数量减1，不会阻塞\n\n`CountDownLatch.await();`等待计数器为0，会唤醒调用它的线程。\n\n### 8.2、CyclicBarrier\n\n> JDK文档描述\n\n![image-20210131191619447](JUC并发编程/image-20210131191619447.png)\n\n简单理解：当一些线程执行完才会最终获得某个结果，集齐7龙珠召唤神龙！\n\n> 测试代码\n\n```java\npackage com.codefriday;\n\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\n\npublic class TestCyclicBarrier {\n    public static void main(String[] args) {\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()->{\n            System.out.println(\"召唤神龙成功\");\n        });\n        for (int i = 0; i < 7; i++) {\n            final int temp = i;\n            new Thread(()->{\n                System.out.println(\"获得第\"+temp+\"颗龙珠~\");\n                try {\n                    cyclicBarrier.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        }\n    }\n}\n\n```\n\n### 8.3、Semophore\n\n> JDK文档描述\n\n![image-20210131193109296](JUC并发编程/image-20210131193109296.png)\n\n操作系统中的信号量：通俗的说初始化给定一个参数表示做多允许多少条线程`acquire`，其他线程就会阻塞等待，线程调用`release`释放资源。\n\n> 测试代码：以6个车抢车位为例子\n\n```java\npackage com.codefriday;\n\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\npublic class TestSemaphore {\n    public static void main(String[] args) {\n        Semaphore semaphore = new Semaphore(3);\n        for (int i = 0; i < 6; i++) {\n            new Thread(()->{\n                try {\n                    semaphore.acquire();\n                    System.out.println(Thread.currentThread().getName()+\"==>抢到车位\");\n                    TimeUnit.SECONDS.sleep(2);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }finally {\n                    System.out.println(Thread.currentThread().getName()+\"==>离开车位\");\n                    semaphore.release();\n                }\n\n            }).start();\n        }\n\n\n    }\n}\n\n```\n\n**可做限流！**\n\n原理：\n`semaphore.acquire();`获得操作-1，满了就睡眠。\n\n`semaphore.release();`释放操作+1，唤醒睡眠的线程。\n\n## 9、读写锁\n\n+ 读的时候能多个线程同时读\n\n+ 写的时候只能一个锁写\n\n> 操作系统中的实现（C）\n\n![image-20210131200817339](JUC并发编程/image-20210131200817339.png)\n\n**实现思想：**\n\n获取读锁时：首先获取lock，增加reader变量追踪读者数量，当第一个读着获取该锁时，读者也会获得写锁，最后释放lock。\n\n一旦一个读者获得读锁，其他读者也可以获得这个读锁，但是，想要获取写锁的线程必须等到所有读者结束。即最后推出的写者在”writelock\"上调用`sem_post`，从而等待的写者能获得该锁。\n\n**需要达到互斥的操作：**\n\n+ 读-写\n+ 写-写\n\n**总结一句话：读要等待写完，写要等待读者全部退出**\n\n> Java代码测试\n\n```java\npackage com.codefriday;\n\nimport java.util.HashMap;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\npublic class TestReadWrite {\n    public static void main(String[] args) {\n        MyCache cache = new MyCache();\n        for (int i = 0; i < 5; i++) {\n            final int temp = i;\n            new Thread(()->{\n                cache.put(temp+\"\",temp);\n            }).start();\n        }\n        for (int i = 0; i < 5; i++) {\n            final int temp = i;\n            new Thread(()->{\n                cache.get(temp+\"\");\n            }).start();\n        }\n    }\n}\nclass MyCache{\n    private volatile HashMap<String,Object> map = new HashMap<>();\n    ReentrantReadWriteLock RWLock = new ReentrantReadWriteLock();\n    //写\n    void put(String key,Object value){\n        RWLock.writeLock().lock();\n        try {\n            System.out.println(Thread.currentThread().getName()+\"写入\"+key);\n            map.put(key,value);\n            System.out.println(Thread.currentThread().getName()+\"写入完成\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            RWLock.writeLock().unlock();\n        }\n    }\n    //读\n    void get(String key){\n        RWLock.readLock().lock();\n        try {\n            System.out.println(Thread.currentThread().getName()+\"读取\"+key);\n            Object o = map.get(key);\n            System.out.println(Thread.currentThread().getName()+\"读取完成\"+key);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            RWLock.readLock().unlock();\n        }\n\n    }\n}\n```\n\n运行结果：(写不能被打断，读可以同时读)\n\n```java\nThread-0写入0\nThread-0写入完成\nThread-1写入1\nThread-1写入完成\nThread-2写入2\nThread-2写入完成\nThread-3写入3\nThread-3写入完成\nThread-4写入4\nThread-4写入完成\nThread-6读取1\nThread-6读取完成1\nThread-8读取3\nThread-7读取2\nThread-7读取完成2\nThread-8读取完成3\nThread-5读取0\nThread-9读取4\nThread-5读取完成0\nThread-9读取完成4\n```\n\n## 10、阻塞队列BlockingQueue\n\n写入：如果队列满了，就必须阻塞等待取出\n\n取出：如果队列为空，就必须阻塞等待写入\n\n![image-20210131205017912](JUC并发编程/image-20210131205017912.png)\n\n**用途：线程池 多并发处理**\n\n**依据它的基本原理，我们可以实现Web中的长连接聊天功能**\n\n**ArrayBlockingQueue：**\n\n+ 一个对象数组+一把锁+两个条件\n\n+ 入队与出队都用同一把锁\n\n+ 在只有入队高并发或出队高并发的情况下，因为操作数组，且不需要扩容，性能很高\n\n+ 采用了数组，必须指定大小，即容量有限\n\n**LinkedBlockingQueue：**\n\n+ 一个单向链表+两把锁+两个条件\n\n+ 两把锁，一把用于入队，一把用于出队，有效的避免了入队与出队时使用一把锁带来的竞争。\n\n+ 在入队与出队都高并发的情况下，性能比`ArrayBlockingQueue`高很多\n\n采用了链表，最大容量为整数最大值，可看做容量无限\n\n**4组不同的API：**\n\n| 操作\\方式    | 抛出异常 | 有返回值，不抛出异常 | 阻塞 等待 | 超时等待  |\n| ------------ | -------- | -------------------- | --------- | --------- |\n| 添加         | add      | offer()              | put()     | offer(,,) |\n| 移除         | remove   | poll()               | take()    | poll(,)   |\n| 检测队首元素 | element  | peek()               | -         | -         |\n\n> SynchronizedQueue 同步队列\n\n> JDK描述\n\n![image-20210131223318236](JUC并发编程/image-20210131223318236.png)\n\n没有容量，put和take方法\n\n进去一个对象，必须等待去除来！\n\n> Java代码测试 put+take线程\n\n```java\npackage com.codefriday;\n\nimport java.util.concurrent.SynchronousQueue;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class TestSynchronizedQueue {\n    public static void main(String[] args) {\n        SynchronousQueue<Integer> sq = new SynchronousQueue();\n        new Thread(()->{\n            ReentrantLock lock = new ReentrantLock();\n\n            try {\n\n                System.out.println(Thread.currentThread().getName()+\"==>put\");\n                sq.put(1);\n\n                System.out.println(Thread.currentThread().getName()+\"==>put\");\n                sq.put(2);\n\n                System.out.println(Thread.currentThread().getName()+\"==>put\");\n                sq.put(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n        new Thread(()->{\n            try {\n\n                System.out.println(Thread.currentThread().getName()+\"==>take\");\n                sq.take();\n                TimeUnit.SECONDS.sleep(1);\n                System.out.println(Thread.currentThread().getName()+\"==>take\");\n                sq.take();\n                TimeUnit.SECONDS.sleep(1);\n                System.out.println(Thread.currentThread().getName()+\"==>take\");\n                sq.take();\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n}\n```\n\n## 11、线程池\n\n> 池化技术\n\n线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。 \n\n**线程池的好处：**\n\n1、降低资源消耗\n\n2、提高响应速度\n\n3、方便管理\n\n**线程复用，可以控制最大并发数，管理线程。**\n\n> 线程池的执行流程：\n\n![img](JUC并发编程/6024478-88ee7b20f8f45825.png)\n\n> 四个常见线程池，Excutors类创建\n\n**CachedThreadPool:**可缓存的线程池，该线程池中没有核心线程，非核心线程的数量为Integer.max_value，就是无限大，当有需要时创建线程来执行任务，没有需要时回收线程，适用于耗时少，任务量大的情况，超过60s释放线程。\n\n**SecudleThreadPool:**周期性执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大。适用于执行周期性的任务。\n\n**SingleThreadPool:**只有一条线程来执行任务，适用于有顺序的任务的应用场景。\n\n**FixedThreadPool:**定长的线程池，有核心线程，核心线程的即为最大的线程数量，没有非核心线程\n\n> ThreadPoolExecutor七大参数\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,//核心线程数\n                          int maximumPoolSize,//最大线程数\n                          long keepAliveTime,//线程存活时间\n                          TimeUnit unit,//时间单位\n                          BlockingQueue<Runnable> workQueue,//阻塞队列\n                          ThreadFactory threadFactory,//线程工场\n                          RejectedExecutionHandler handler)//拒绝策略\n```\n\n> 四大拒绝策略\n\n**线程池最大容量 = 最大线程数+阻塞队列容量**\n\n+ `ThreadPoolExecutor.AbortPolicy()`\n\n  超过线程池容量，抛出`RejectedExecutionException`\n\n+ `ThreadPoolExecutor.CallerRunsPolicy()`\n\n  由调用者执行被拒绝的线程\n\n+ `ThreadPoolExecutor.DiscardPolicy()`\n\n  丢掉任务，但是不抛出异常\n\n+ `ThreadPoolExecutor.DiscardOldestPolicy()`\n\n  尝试和最早执行的任务的竞争，竞争失败则直接丢弃，不会抛出异常\n\n> 如何选择最大线数\n\n+ CPU密集型：一般获取CPU的核数，即设置成最大线程数\n+ IO密集型：IO耗费时间更多，一般设置成核数*2\n\n**如何获取CPU核数？**\n\n`Runtime.getRuntime().availableProcessors()`\n\n## 12、四大函数式接口\n\n+ 链式编程\n\n  调用方法时返回一个this对象，即可调用方法后面再跟调用方法\n\n+ Lamda表达式\n\n  函数式接口的简化编程\n\n**函数式接口：只有一个抽象方法的接口类**\n\n> 函数型接口Function\n\n![image-20210201120745130](JUC并发编程/image-20210201120745130.png)\n\n```java\npackage com.codefriday.TestFunctionInterface;\n\nimport java.util.function.Function;\n\npublic class TestFunction {\n    public static void main(String[] args) {\n        /**普通实现：匿名内部类。\n         *         Function<String, String> function = new Function<String, String>() {\n         *             @Override\n         *             public String apply(String o) {\n         *                 return o;\n         *             }\n         *         };\n         */\n        //Lambda表达式：第一个o传入参数，第二个o返回参数\n        Function<String, String> function = o -> o;\n        System.out.println(function.apply(\"Hello World!\"));\n    }\n}\n\n```\n\n> Predicate断定型接口\n\n![image-20210201121731054](JUC并发编程/image-20210201121731054.png)\n\n传入一个参数，返回一个boolean值，一般用来做判断用\n\n```java\npackage com.codefriday.TestFunctionInterface;\n\nimport java.util.function.Predicate;\n\npublic class TestPredicate {\n    public static void main(String[] args) {\n        /***\n         * 匿名内部类写法：\n         * Predicate<Integer> predicate = new Predicate<Integer>() {\n         *             @Override\n         *             public boolean test(Integer integer) {\n         *                 return integer > 5;\n         *             }\n         *         };\n         */\n        //Lambda表达式\n        Predicate<Integer> predicate = integer -> integer > 5;\n        System.out.println(predicate.test(10));\n        System.out.println(predicate.test(4));\n    }\n}\n\n```\n\n> Consumer 消费型接口\n\n![image-20210201122653549](JUC并发编程/image-20210201122653549.png)\n\n```java\npackage com.codefriday.TestFunctionInterface;\n\nimport java.util.function.Consumer;\n\npublic class TestConsumer {\n    public static void main(String[] args) {\n        /**\n         * 匿名内部类写法：\n         * Consumer<String> consumer = new Consumer<String>() {\n         *             @Override\n         *             public void accept(String o) {\n         *                 System.out.println(o);\n         *             }\n         *         };\n         */\n        //Lambda表达式\n        Consumer<String> consumer = o -> System.out.println(o);\n        consumer.accept(\"Test\");\n    }\n}\n\n```\n\n> Supplier 供给型接口\n\n![image-20210201123229800](JUC并发编程/image-20210201123229800.png)\n\n```java\npackage com.codefriday.TestFunctionInterface;\n\nimport java.util.Random;\nimport java.util.function.Supplier;\n\npublic class TestSupplier {\n    public static void main(String[] args) {\n        /**\n         * 匿名内部类写法\n         *  Supplier<Integer> supplier = new Supplier<Integer>() {\n         *             @Override\n         *             public Integer get() {\n         *                 return new Random().nextInt();\n         *             }\n         *         };\n         */\n        Supplier<Integer> supplier = () -> new Random().nextInt();\n        System.out.println(supplier.get());\n    }\n}\n\n```\n\n## 13、Stream流式计算\n\n> 什么是Stream流式计算\n\n大数据=存储+计算\n\n集合、MySQL本质就是存储东西的，计算应该交给流\n\n> filter\n\n```java\nStream<T> filter(Predicate<? super T> predicate);\n```\n\n传入一个`Predicate`函数式接口用于判断条件，保留返回值为真的结果。\n\n> map\n\n```java\n<R> Stream<R> map(Function<? super T, ? extends R> mapper);\n```\n\n传入一个`Function`函数式接口，将流中对象某对象替换成其他对象。\n\n> sorted(Comparator)\n\n```java\nStream<T> sorted(Comparator<? super T> comparator);\n```\n\n传入一个比较器排序。\n\n> limit\n\n```java\nStream<T> limit(long maxSize);\n```\n\n输出流中的前`maxSize`个对象\n\n> forEach\n\n```java\nvoid forEach(Consumer<? super T> action);\n```\n\n传入消费性函数式接口遍历流进行一些附加操作。\n\n**共性，一些计算操作都返回了一个Stream流，因此可用作链式编程！**\n\n> 代码测试\n\n```java\npackage com.codefriday.StreamTest;\n\nimport java.util.*;\nimport java.util.stream.Stream;\n\n/**\n * 题目要求：一行代码实现\n * 现在有五个用户，筛选\n * 1、ID必须为偶数\n * 2、年龄必须大于23岁\n * 3、用户名转为大写字母\n * 4、用户名倒叙排序\n * 5、只输出一个用户\n */\npublic class TestStream {\n    public static void main(String[] args) {\n        User u1 = new User(1,\"a\",21);\n        User u2 = new User(2,\"b\",22);\n        User u3 = new User(3,\"c\",23);\n        User u4 = new User(4,\"d\",24);\n        User u5 = new User(6,\"e\",25);\n        List<User> list = Arrays.asList(u1,u2,u3,u4,u5);\n        Stream<User> stream = list.stream();\n        stream.filter(u-> (u.getId()%2)==0)\n                .filter(u->u.getAge()>23)\n                .map(u->new User(u.getId(),u.getName().toUpperCase(Locale.ROOT),u.getAge()))\n                .sorted((o1, o2) -> o2.getName().compareTo(o1.getName()))\n                .limit(1)\n                .forEach(System.out::println);\n    }\n}\nclass User{\n    private int id;\n    private String name;\n    private int age;\n\n    public User(int id, String name, int age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n}\n```\n\n**总结：流式计算=链式编程+函数式接口，函数式接口方便使用Lambda表达式简化编程！**\n\n## 14、ForkJoin\n\n> 什么是ForkJoin\n\nForkJoin是由JDK1.7后提供多线并发处理框架。ForkJoin的框架的基本思想是分而治之。\n\n大数据领域：Map Reduce 任务拆分\n\n\n\n![image-20210201150712556](JUC并发编程/image-20210201150712556.png)\n\n> FrokJoin使用方法\n\n#### 一、 创建Task\n\n使用ForkJoin框架，需要创建一个ForkJoin的任务，而ForkJoinTask是一个抽象类，我们不需要去继承ForkJoinTask进行使用。因为ForkJoin框架为我们提供了RecursiveAction和RecursiveTask。我们只需要继承ForkJoin为我们提供的抽象类的其中一个并且实现compute方法。\n\n#### 二、使用ForkJoinPool进行执行\n\ntask要通过ForkJoinPool来执行，分割的子任务也会添加到当前工作线程的双端队列中，\n进入队列的头部。当一个工作线程中没有任务时，会从其他工作线程的队列尾部获取一个任务(工作窃取)。\n\n#### 三、RecursiveTask和RecursiveAction区别\n\n前者有返回结果，后者没有返回结果。\n\nfork负责分割工作\n\n> ForkJoin特点：工作窃取\n\n类似多CPU调度中，CPU空闲会从其他地方窃取工作执行。\n\n一般工作集都是双端队列！\n\n这个框架是借助了现代计算机多核的优势并行去处理数据。\n\n> 代码测试\n\n```java\npackage com.codefriday.ForkJoinTest;\n\nimport java.util.OptionalLong;\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.ForkJoinTask;\nimport java.util.concurrent.RecursiveTask;\nimport java.util.stream.LongStream;\n\npublic class Test {\n    public static void main(String[] args) {\n        /**\n         * ForkJoinTask<Long> task = new MyTask(1L,10_0000_0000L);\n         *         ForkJoinPool forkJoinPool = new ForkJoinPool();\n         *         Long ans = forkJoinPool.invoke(task);\n         */\n\n\n        //Long ans = new SimpleCal(1L, 10_0000_0000L).CalculateIt();\n        long start = System.currentTimeMillis();\n\n        OptionalLong ans = LongStream.rangeClosed(1L,10_0000_0000L).parallel().reduce(Long::sum);\n\n        long end = System.currentTimeMillis();\n        System.out.println(\"ans = \"+ans+\"，耗时：\"+(end-start));\n    }\n}\n//简单for循环计算  耗时：12628\nclass SimpleCal{\n    Long start;\n    Long end;\n\n    public SimpleCal(Long start, Long end) {\n        this.start = start;\n        this.end = end;\n    }\n    public Long CalculateIt(){\n        Long sum = 0L;\n        for (Long i = start; i <= end; i++) {\n            sum+=i;\n        }\n        return sum;\n    }\n}\n\n//ForkJoin计算5619\nclass MyTask extends RecursiveTask<Long>{\n    Long start;\n    Long end;\n\n    public MyTask(Long start, Long end) {\n        this.start = start;\n        this.end = end;\n    }\n\n    @Override\n    protected Long compute() {\n        if(end-start<10000){\n            Long sum = 0L;\n            for(Long i = start;i<=end;i++){\n                sum+=i;\n            }\n            return sum;\n        }\n        else{\n            Long mid = (start+end)/2;\n            MyTask left = new MyTask(start,mid);\n            left.fork();\n            MyTask right = new MyTask(mid+1,end);\n            right.fork();\n            return left.join() + right.join();\n        }\n    }\n}\n```\n\n## 15、异步回调\n\n> 同步回调\n\n 我们常用的一些请求都是同步回调的，同步回调是阻塞的，单个的线程需要等待结果的返回才能继续执行。\n\n![img](JUC并发编程/2018052219070510)\n\n>  异步回调\n\n有的时候，我们不希望程序在某个执行方法上一直阻塞，需要先执行后续的方法，那就是这里的异步回调。我们在调用一个方法时，如果执行时间比较长，我们可以传入一个回调的方法，当方法执行完时，让被调用者执行给定的回调方法。\n\n![img](JUC并发编程/20180522190716303)\n\n## 16、JMM\n\n> Volatile的特点\n\n1、保证可见性\n\n2、不保证原子性\n\n3、禁止指令重排\n\n> 什么是JMM\n\nJMM：Java内存模型，一个概念。\n\n**关于JMM的一些同步的约定：**\n\n1、线程解锁前，必须立刻把工作内存的变量覆盖回主存。\n\n2、线程加锁前，必须读取主存最新值到自己的工作内存。\n\n3、加锁和解锁必须是同一把。\n\n> 工作内存 和 主存\n\n可以简单的认为主内存是java虚拟机内存区域中的堆，局部变量和方法参数是在虚拟机栈中定义的。但是在堆中的变量如果在多线程中都使用，就涉及到了堆和不同虚拟机栈中变量的值的一致性问题了。\n\n+ 主内存：java虚拟机规定所有的变量(不是程序中的变量)都必须在主内存中产生，为了方便理解，可以认为是堆区。可以与前面说的物理机的主内存相比，只不过物理机的主内存是整个机器的内存，而虚拟机的主内存是虚拟机内存中的一部分。\n\n+ 工作内存：java虚拟机中每个线程都有自己的工作内存，该内存是线程私有的为了方便理解，可以认为是虚拟机栈。可以与前面说的高速缓存相比。线程的工作内存保存了线程需要的变量在主内存中的副本。虚拟机规定，线程对主内存变量的修改必须在线程的工作内存中进行，不能直接读写主内存中的变量。不同的线程之间也不能相互访问对方的工作内存。如果线程之间需要传递变量的值，必须通过主内存来作为中介进行传递。\n\n![img](JUC并发编程/4899162-66736384361f6b8b.png)\n\n***这里需要说明一下：主内存、工作内存与java内存区域中的java堆、虚拟机栈、方法区并不是一个层次的内存划分。这两者是基本上是没有关系的。***\n\n> 工作内存与主内存交互(8中操作)\n\n![image-20210202203941374](JUC并发编程/image-20210202203941374.png)\n\n**lock(锁定)**:作用于主内存的变量，一个变量在同一时间只能一个线程锁定，该操作表示这条线成独占这个变量\n\n**unlock(解锁)**:作用于主内存的变量，表示这个变量的状态由处于锁定状态被释放，这样其他线程才能对该变量进行锁定\n\n**read(读取)**:作用于主内存变量，表示把一个主内存变量的值传输到线程的工作内存，以便随后的load操作使用\n\n**load(载入)**:作用于线程的工作内存的变量，表示把read操作从主内存中读取的变量的值放到工作内存的变量副本中(副本是相对于主内存的变量而言的)\n\n**use(使用)**:作用于线程的工作内存中的变量，表示把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作\n\n**assign(赋值)**:作用于线程的工作内存的变量，表示把执行引擎返回的结果赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作\n\n**store(存储)**:作用于线程的工作内存中的变量，把工作内存中的一个变量的值传递给主内存，以便随后的write操作使用\n\n**write(写入)**:作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中\n\n对于这8中操作，虚拟机也规定了一系列规则，在执行这8中操作的时候必须遵循如下的规则：\n\n**不允许read和load、store和write操作之一单独出现**，也就是不允许从主内存读取了变量的值但是工作内存不接收的情况，或者不允许从工作内存将变量的值回写到主内存但是主内存不接收的情况\n\n**不允许一个线程丢弃最近的assign操作**，也就是不允许线程在自己的工作线程中修改了变量的值却不同步/回写到主内存\n\n**不允许一个线程回写没有修改的变量到主内存**，也就是如果线程工作内存中变量没有发生过任何assign操作，是不允许将该变量的值回写到主内存\n\n**变量只能在主内存中产生**，不允许在工作内存中直接使用一个未被初始化的变量，也就是没有执行load或者assign操作。也就是说在执行use、store之前必须对相同的变量执行了load、assign操作\n\n**一个变量在同一时刻只能被一个线程对其进行lock操作**，也就是说一个线程一旦对一个变量加锁后，在该线程没有释放掉锁之前，其他线程是不能对其加锁的，但是同一个线程对一个变量加锁后，可以继续加锁，同时在释放锁的时候释放锁次数必须和加锁次数相同。\n\n**对变量执行lock操作，就会清空工作空间该变量的值**，执行引擎使用这个变量之前，需要重新load或者assign操作初始化变量的值\n\n**不允许对没有lock的变量执行unlock操作**，如果一个变量没有被lock操作，那也不能对其执行unlock操作，当然一个线程也不能对被其他线程lock的变量执行unlock操作\n\n**对一个变量执行unlock之前，必须先把变量同步回主内存中**，也就是执行store和write操作\n\n问题：程序不知道主内存的值已经被修改过了。\n\n## 17、Volatile\n\n> 1、可见性\n\n**线程知道主存的变量被其他线程修改。**\n\n> 2、不保证原子性\n\n原子性：一个任务，要么执行完，要么没执行。\n\n多线程累加一个整数时，用Volatile修饰有问题，可以使用，JUC包下的Automaitc包装类。\n\n```java\npackage com.codefriday;\n\npublic class TestVolatile {\n    private static int num = 0;\n    public static void main(String[] args) throws InterruptedException {\n        for (int i = 0; i < 2; i++) {\n            new Thread(()->{\n                for (int j = 0; j < 10000; j++) {\n                    add();\n                }\n            }).start();\n        }\n        //主线程休眠等待，保证先加完再输出\n        while(Thread.activeCount()>2){\n            Thread.yield();\n        }\n        System.out.println(num);\n    }\n    public static void add(){\n        num++;\n    }\n}\n\n```\n\nnum++实际不是一个原子操作，需要三个指令！！！\n\n![image-20210202213140886](JUC并发编程/image-20210202213140886.png)\n\n实际原子类中的方法都调用了Unsafe类中的方法，Unsafe类中是一些本地方法JNI，直接和操作系统挂钩。\n\n>什么是指令重排\n\n程序高效执行，写的代码编译之后的指令会经过代码优化阶段，指令重排等。\n\n编译原理中编译器后端代码生成，代码优化中有~\n\n由于内存屏障，所以保证避免指令重拍现象。\n\n## 18、单例模式\n\n单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n\n**注意：**\n\n- 1、单例类只能有一个实例。\n- 2、单例类必须自己创建自己的唯一实例。\n- 3、单例类必须给所有其他对象提供这一实例。\n\n> 介绍\n\n**意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n**主要解决：**一个全局使用的类频繁地创建与销毁。\n\n**何时使用：**当您想控制实例数目，节省系统资源的时候。\n\n**如何解决：**判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\n\n**关键代码：**构造函数是私有的。\n\n> 饿汉式\n\n上来直接新建对象！\n\n```java\npackage com.codefriday.Single;\n//饿汉式单例模式\npublic class Hungry {\n    //可能造成空间浪费\n    private byte[] data1 = new byte[1024*1024];\n    private byte[] data2 = new byte[1024*1024];\n    private byte[] data3 = new byte[1024*1024];\n    private byte[] data4 = new byte[1024*1024];\n\n    //构造器私有\n    private Hungry(){}\n\n    //加载类时就new出对象\n    private final static Hungry HUNGRY = new Hungry();\n\n    public static Hungry getInstance(){\n        return HUNGRY;\n    }\n}\n```\n\n> 静态内部类实现单例模式\n\n```java\npackage com.codefriday.Single;\n\npublic class Holder {\n    private Holder(){}\n    private static class innerClass{\n        private static Holder INSTANCE = new Holder();\n    }\n    public static Holder getInstance(){\n        return innerClass.INSTANCE;\n    }\n}\n/**\n * 静态内部类的优点是：外部类加载时并不需要立即加载内部类，\n * 内部类不被加载则不去初始化INSTANCE，故而不占内存。\n * 即当Holder第一次被加载时，并不需要去加载innerClass，\n * 只有当getInstance()方法第一次被调用时，才会去初始化INSTANCE,\n * 第一次调用getInstance()方法会导致虚拟机加载innerClass类，\n * 这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。\n */\n\n```\n\n\n\n> 懒汉式\n\n对象用的时候再加载。\n\n**(1)有问题的版本**\n\n```java\npackage com.codefriday.Single;\n//懒汉式单例\npublic class LazyMan {\n    private static LazyMan lazyman = null;\n    //构造器私有\n    private LazyMan(){\n        System.out.println(Thread.currentThread().getName()+\"OK\");\n    }\n\n    public static LazyMan getInstance(){\n        //用到时才创建对象\n        if(lazyman==null){\n            lazyman = new LazyMan();\n        }\n        return lazyman;\n    }\n    //问题：多线程下会破坏单例模式\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            new Thread(()->{\n                LazyMan.getInstance();\n            }).start();\n        }\n    }\n}\n\n```\n\n**(2)DCL懒汉式，仍然存在问题**\n\n```java\npackage com.codefriday.Single;\n//懒汉式单例\npublic class LazyMan {\n    private static LazyMan lazyman = null;\n    //构造器私有\n    private LazyMan(){\n        System.out.println(Thread.currentThread().getName()+\"OK\");\n    }\n    //双重检测锁模式，Double-check-lock,DCL懒汉式\n    public static LazyMan getInstance(){\n        //用到时才创建对象\n        if(lazyman==null){\n            synchronized (LazyMan.class){\n                if(lazyman==null) {\n                    lazyman = new LazyMan();\n                }\n            }\n\n        }\n        return lazyman;\n    }\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            new Thread(()->{\n                LazyMan.getInstance();\n            }).start();\n        }\n    }\n}\n\n```\n\n`lazyman = new LazyMan();`不是原子操作，分以下几个步骤\n\n+ 分配内存空间\n+ 执行构造方法初始化对象\n+ 对象指向这个空间\n\n解决方案：`private static LazyMan lazyman = null;`加`volatile`修饰\n\n**(3)反射可以破坏单例模式**\n\n反射获得私有构造器，设置可到达，然后`newinstance`可以通过构造器新建一个对象。\n\n```java\npackage com.codefriday.Single;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\n//懒汉式单例\npublic class LazyMan {\n    private static LazyMan lazyman = null;\n    //构造器私有\n    private LazyMan(){\n        System.out.println(Thread.currentThread().getName()+\"OK\");\n    }\n    //双重检测锁模式，Double-check-lock,DCL懒汉式\n    public static LazyMan getInstance(){\n        //用到时才创建对象\n        if(lazyman==null){\n            synchronized (LazyMan.class){\n                if(lazyman==null) {\n                    lazyman = new LazyMan();\n                }\n            }\n\n        }\n        return lazyman;\n    }\n    public static void main(String[] args) throws Exception {\n        LazyMan instance = LazyMan.getInstance();\n        //获得单例类的构造器\n        Constructor<LazyMan> constructor = LazyMan.class.getDeclaredConstructor(null);\n        constructor.setAccessible(true);\n        LazyMan instance2 = constructor.newInstance();\n        System.out.println(instance);\n        System.out.println(instance2);\n    }\n}\n\n```\n\n**解决方案：在构造器中加一个判断，如果已经被实例，抛出异常。**\n\n**(4)加判断避免反射**\n\n```java\npackage com.codefriday.Single;\n\nimport java.lang.reflect.Constructor;\n\n//懒汉式单例\npublic class LazyMan {\n    private static LazyMan lazyman = null;\n    //构造器私有\n    private LazyMan(){\n        synchronized (LazyMan.class){\n            if(lazyman!=null){\n                throw new RuntimeException(\"不要试图用反射新建对象！！！\");\n            }\n        }\n\n    }\n    //双重检测锁模式，Double-check-lock,DCL懒汉式\n    public static LazyMan getInstance(){\n        //用到时才创建对象\n        if(lazyman==null){\n            synchronized (LazyMan.class){\n                if(lazyman==null) {\n                    lazyman = new LazyMan();\n                }\n            }\n\n        }\n        return lazyman;\n    }\n    public static void main(String[] args) throws Exception {\n        LazyMan instance = LazyMan.getInstance();\n        //获得单例类的构造器\n        Constructor<LazyMan> constructor = LazyMan.class.getDeclaredConstructor(null);\n        constructor.setAccessible(true);\n        LazyMan instance2 = constructor.newInstance();\n        System.out.println(instance);\n        System.out.println(instance2);\n    }\n}\n\n```\n\n运行结果：\n\n![image-20210203121248535](JUC并发编程/image-20210203121248535.png)\n\n**仍然存在问题：**\n\n不使用`getInstance`方法对象就不会被创建，使用反射获得构造器就可以获得两次实例破坏单例模式！\n\n**解决方案：**\n\n增加一个标志位，可以当做一个密码位，调用构造器时修改密码位即可。实现代码如下。\n\n**(5)密码位判断**\n\n```java\npackage com.codefriday.Single;\n\nimport java.lang.reflect.Constructor;\n\n//懒汉式单例\npublic class LazyMan {\n    private boolean password = false;\n    private static LazyMan lazyman = null;\n    //构造器私有\n    private LazyMan(){\n        synchronized (LazyMan.class){\n            if(password){\n                password = true;\n            }else{\n                throw new RuntimeException(\"不要试图用反射新建对象！！！\");\n            }\n        }\n\n    }\n    //双重检测锁模式，Double-check-lock,DCL懒汉式\n    public static LazyMan getInstance(){\n        //用到时才创建对象\n        if(lazyman==null){\n            synchronized (LazyMan.class){\n                if(lazyman==null) {\n                    lazyman = new LazyMan();\n                }\n            }\n\n        }\n        return lazyman;\n    }\n    public static void main(String[] args) throws Exception {\n        //LazyMan instance = LazyMan.getInstance();\n        //获得单例类的构造器\n        Constructor<LazyMan> constructor = LazyMan.class.getDeclaredConstructor(null);\n        constructor.setAccessible(true);\n        LazyMan instance1 = constructor.newInstance();\n        LazyMan instance2 = constructor.newInstance();\n        System.out.println(instance1);\n        System.out.println(instance2);\n    }\n}\n\n```\n\n**问题：**即使标志位经过加密处理，也可能被解密。通过反编译。\n\n**解决方案：**\n\n查看`newInstance`的源码如下：\n\n![image-20210203122910178](JUC并发编程/image-20210203122910178.png)\n\n发现如果是枚举类型就不能破坏单例模式。\n\n> 枚举实现单例模式\n\n```java\npackage com.codefriday.Single;\n\npublic enum SingleEnum {\n    INSTANCE;\n    public SingleEnum getInstance(){\n        return INSTANCE;\n    }\n}\nclass Test{\n    public static void main(String[] args) {\n        System.out.println(SingleEnum.INSTANCE);\n    }\n}\n\n```\n\n但是发现编译完的class文件中有一个私有构造方法：\n\n![image-20210203124419607](JUC并发编程/image-20210203124419607.png)\n\n**尝试用反射获取破坏一下：**\n\n```java\npackage com.codefriday.Single;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\npublic enum SingleEnum {\n    INSTANCE;\n    public SingleEnum getInstance(){\n        return INSTANCE;\n    }\n}\nclass Test{\n    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n        Constructor<SingleEnum> constructor = SingleEnum.class.getDeclaredConstructor(null);\n        constructor.setAccessible(true);\n        SingleEnum instance = constructor.newInstance();\n        System.out.println(instance);\n    }\n}\n\n```\n\n**运行结果：**\n\n![image-20210203124627741](JUC并发编程/image-20210203124627741.png)\n\n按道理应该抛出的是`newInstance`方法中的`Cannot reflectively create enum objects`异常的，然而却抛出一个找不到构造方法的异常。\n\n**使用javap反编译一下：**\n\n![image-20210203125041305](JUC并发编程/image-20210203125041305.png)\n\n发现也存在一个空参构造器。使用更专业的反编译工具！\n\nJAD下载地址：https://varaneckas.com/jad/\n\n![image-20210203131729962](JUC并发编程/image-20210203131729962.png)\n\n查看源码如下：\n\n![image-20210203131758731](JUC并发编程/image-20210203131758731.png)\n\n存在一个有参构造，因此我们可以获得该构造器。\n\n测试代码：\n\n```java\npackage com.codefriday.Single;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\npublic enum SingleEnum {\n    INSTANCE;\n    public SingleEnum getInstance(){\n        return INSTANCE;\n    }\n}\nclass Test{\n    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n        Constructor<SingleEnum> constructor = SingleEnum.class.getDeclaredConstructor(String.class,int.class);\n        constructor.setAccessible(true);\n        SingleEnum instance = constructor.newInstance();\n        SingleEnum instance1 = constructor.newInstance();\n        System.out.println(instance);\n        System.out.println(instance1);\n    }\n}\n\n```\n\n运行结果：达到预期\n\n![image-20210203131956843](JUC并发编程/image-20210203131956843.png)\n\n## 19、深入理解CAS\n\n> 什么是CAS\n\nCompare And Swap比较并交换，如果值等于期望值，就更新它。\n\nCAS是CPU的并发原语！！！\n\n> Unsafe类\n\n![image-20210203140513939](JUC并发编程/image-20210203140513939.png)\n\n发现全部是native方法，Java不可直接操作内存，C++可以，因此Java调用C++可以操作内存。\n\n以`AtomicInteger`为例：\n\n![image-20210203140734620](JUC并发编程/image-20210203140734620.png)\n\n其中的`getAndIncrement`方法调用Unsafe类的`getAndAddInt`方法\n\n```java\npublic final int getAndIncrement() {\n    return unsafe.getAndAddInt(this, valueOffset, 1);\n}\n```\n\n`getAndAddInt`方法：自旋锁。\n\n![image-20210203140835738](JUC并发编程/image-20210203140835738.png)\n\n**缺点：**\n\n1、循环耗时\n\n2、一次性只能保证一个共享变量的原子性\n\n3、ABA问题\n\n> CAS（ABA问题）\n\n也就是一个线程调用CAS想改，但是另一个线程可能在此之前先改为一个其他的值又给他改回来了。\n\n![image-20210203142936500](JUC并发编程/image-20210203142936500.png)\n\n**乐观锁&悲观锁：**\n\n+ 悲观锁：但凡修改数据就加锁，，具有强烈的独占和排他特性。主要分以下两类\n  + 共享锁【shared locks】又称为读锁，简称S锁。共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。、\n  + 排他锁【exclusive locks】又称为写锁，简称X锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改。\n\n+ 乐观锁：乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。\n\n![image-20210203144850438](JUC并发编程/image-20210203144850438.png)\n\n## 20、原子引用(解决ABA问题)\n\n**对应的思想：乐观锁**\n\n> 代码测试\n\n```java\npackage com.codefriday.CAS;\n\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicStampedReference;\n\npublic class Demo02 {\n    private static AtomicStampedReference atomicReference= new AtomicStampedReference<Integer>(1,1);\n    public static void main(String[] args) {\n        //A线程修改两次\n        new Thread(()->{\n            System.out.println(\"A==>\"+atomicReference.getStamp());\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            atomicReference.compareAndSet(1,2,atomicReference.getStamp(),atomicReference.getStamp()+1);\n            System.out.println(\"A==>\"+atomicReference.getStamp());\n            atomicReference.compareAndSet(2,1,atomicReference.getStamp(),atomicReference.getStamp()+1);\n            System.out.println(\"A==>\"+atomicReference.getStamp());\n        }).start();\n        //确保B线程和A线程获得最初的版本号\n        new Thread(()->{\n            int version = atomicReference.getStamp();\n            System.out.println(\"B==>\"+version);\n            try {\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(atomicReference.compareAndSet(1, 3, version, version + 1));\n        }).start();\n    }\n}\n\n```\n\n**大坑：**\n\n查看comepareAndSet源码：\n\n```java\npublic boolean compareAndSet(V   expectedReference,\n                                 V   newReference,\n                                 int expectedStamp,\n                                 int newStamp) {\n        Pair<V> current = pair;\n        return\n            expectedReference == current.reference &&\n            expectedStamp == current.stamp &&\n            ((newReference == current.reference &&\n              newStamp == current.stamp) ||\n             casPair(current, Pair.of(newReference, newStamp)));\n    }\n```\n\n> 传入Integer对象直接用==判断是否相等时有问题！\n\n测试代码：\n\n```java\npackage com.codefriday.CAS;\n\npublic class Demo03 {\n    public static void main(String[] args) {\n        Integer x = 128;\n        Integer y = 128;\n        System.out.println(x==y);\n    }\n}\n\n```\n\n输出结果为false，原因分析：== 比较的是堆中的地址。\n\n查看`Integer`中的源码。\n\n```java\n public static Integer valueOf(int i) {\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n```\n\n默认IntegerCache.low 是-127，Integer.high是128，如果在这个区间内，他就会把变量i当做一个变量，放到内存中；但如果不在这个范围内，就会去new一个Integer对象。\n\n**比较Integer的值这儿说两种方法：**\n\n+ 一个是用equals()比较\n\n+ 一个是用Integer.intValue()转成int\n\n## 21、各种锁的理解\n\n### 1、公平锁、非公平锁\n\n公平锁：非常公平，不能插队，先来后到\n\n非公平锁：可以插队（默认非公平）\n\n### 2、可重入锁\n\n可重入锁（递归锁）：拿到了外面的锁之后就可以拿到里面的锁（自动获得！）\n\n可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。\n\n> Synchronized\n\n```java\npackage com.codefriday.Lock;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class Demo01 {\n    public static void main(String[] args) {\n        Phone phone = new Phone();\n        new Thread(()->{\n            try {\n                phone.sms();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n        new Thread(()->{\n            phone.call();\n        }).start();\n    }\n}\nclass Phone{\n    public synchronized void sms() throws InterruptedException {\n        System.out.println(\"发短息\");\n        TimeUnit.SECONDS.sleep(1);\n        call();\n    }\n    public synchronized void call(){\n        System.out.println(\"打电话\");\n    }\n}\n\n```\n\n> ReentrantLock\n\n使用ReentrantLock调用lock和unlock次数必须相等，否则会死锁。\n\n### 3、自旋锁\n\n自旋等待的锁，调用lock和unlock方法是阻塞的！\n\n### 4、死锁排查\n\n> 工具\n\n1、使用jps定位进程号`jps -l`\n\n2、使用`jstack 进程号`查看堆栈信息\n\n排查问题：\n\n1、日志\n\n2、堆栈信息\n\n> 测试死锁代码\n\n```java\npackage com.codefriday.Lock;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class Demo02 {\n    public static void main(String[] args) {\n        String LockA = \"lockA\";\n        String LockB = \"lockB\";\n        new Thread(new MyThread(LockA,LockB)).start();\n        new Thread(new MyThread(LockB,LockA)).start();\n    }\n}\nclass MyThread implements Runnable{\n    private String LockA;\n    private String LockB;\n\n    public MyThread(String lockA, String lockB) {\n        LockA = lockA;\n        LockB = lockB;\n    }\n\n    @Override\n    public void run() {\n        synchronized (LockA){\n            System.out.println(Thread.currentThread().getName()+\" get \"+LockA);\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            synchronized (LockB){\n                System.out.println(Thread.currentThread().getName()+\" get \"+LockB);\n            }\n        }\n    }\n}\n\n\n```\n\n> 堆栈信息排错：\n\n![image-20210203163557689](JUC并发编程/image-20210203163557689.png)","tags":["第一阶段"],"categories":["第一阶段"]},{"title":"JVM学习笔记","url":"/2021/01/30/JVM学习笔记/","content":"\n## JVM的位置\n\n![img](JVM学习笔记/896914-20191214212820607-179669159.png)\n\n`Java`之所以能跨平台，是由于在程序和操作系统之间还有一层Java虚拟机存在，就是所谓的`JVM`，区别于`C/C++`，由于操作系统基本也是`C/C++`编写的，操作系统本身也是一个应用程序，所以`C/C++`编写的程序当然更亲和硬件，当然`C/C++`语言粒度较细，而`Java`有自己成熟的虚拟机系统，所以能火起来！\n\n一个`C/C++`程序编译成`exe`文件之后，虽然可以直接复制到其他电脑无需安装其他环境，双击运行即可，但是跨平台时，首先需要考虑操作系统提供的`API`是否一致，比如线程相关`API`，其次还要考虑硬件体系，也就是CPU的指令集，是`ARM`还是`X86`等等。\n\n但一个JAVA程序，首先需要设备上安装了`JRE`（运行时环境），然后就可以跑起来了！\n\n## JVM体系结构\n\n![img](JVM学习笔记/1.png)\n\n## 类加载器&双亲委派机制\n\n### 类加载器\n\n![image-20210130110821276](JVM学习笔记/image-20210130110821276.png)\n\n\n\n- 引导类加载器：`C++`编写，是`JVM`自带的类加载器，负责**Java平台核心库（JRE-lib-rt.jar）**,用来装载核心类库。该加载器无法直接获取。\n- 扩展类加载器：负责`jre/lib/ext`目录下的jar包或`- D java.ext.dirs`指定目录下的jar包装入工作库。\n- 系统类加载器：负责`java -classpath`或`-D java.class.path`所指定目录下的类与jar包装入工作，是最常用的加载器。\n\n### 双亲委派机制\n\n所谓双亲，其实就是指引导类加载器和扩展类加载器是系统类加载器的父类加载器。为了防止恶意代干扰运行时环境，比如java.lang包下的String类，如果你自己写一个同包同名的类，自己写的是没用的。\n\n**当加载系统收到一个类加载请求时：**\n\n![image-20210130110731285](E:JVM学习笔记/image-20210130110731285.png)\n\n**测试写一个同包同名类时：**\n\n**首先必须知道的一点：J**AVA虚拟机启动时先加载包含main方法的类，因此我先写一个String类，并给一个静态代码块（如果这个类被加载，静态代码块中的输出语句就会输出东西）。\n\n```java\npackage java.lang;\n\npublic class String {\n    static {\n        System.out.println(\"黑入成功！\");\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Hello world!\");\n    }\n}\n\n```\n\n输出：\n\n![image-20210130111721441](JVM学习笔记/image-20210130111721441.png)\n\n为什么报错找不到主函数？？？\n\n我自己的理解：首先主函数在`String`类中所以先加载这个类，然后在`rt-jar`包中也有这个类，实际往上委派加载器加载时，`BootstrapClassLoader`在`rt-jar`包中成功加载，但是其中确实没有主函数，因此报错！\n\n## Native，方法区\n\n`native`关键字：凡是带了`native`关键字的方法，说明`java`作用范围达不到了，他会调用底层C语言库。会进入本地方法栈，调用本地方法接口（`JNI`）\n\n`JNI`作用：扩展`Java`使用，融合不同编程语言为`Java`使用！最初：`C/C++`\n\n它在内存区域中专门开辟了一个本地方法栈（`Native Method Stack`）,登记`native`方法\n\n在最终执行时，通过`JNI`加载本地方法库的方法。\n\n## PC寄存器\n\n程序计数器：Program Counter Register\n\n每个线程私有一个程序计数器，实际就是一个指针，指向方法区中的方法字节码。\n\n## 方法区\n\nMethod Area方法区\n\n被所有线程共享，静态变量，常量，类信息（构造方法，接口定于）、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法去无关。\n\n存：static，final，Class，常量池\n\n## 栈式计算机\n\nJVM本质是栈式计算机\n\n操作数压栈，运算指令从栈顶取数据运算。\n\n![image-20210130153145040](JVM学习笔记/image-20210130153145040.png)\n\n## 三种JVM\n\n+ Sun公司 `Java HotSpot(TM) Client VM (build 25.271-b09, mixed mode, sharing)`\n+ BEA `JRockit `\n+ IBM `J9VM`\n\n## 堆\n\nHeap，一个JVM只有一个堆内存，堆内存大小是可以调节的。\n\n类加载器读取类文件后，一般会把类，方法，常量，变量放在堆中，以及保存我们所引用类型的真实对象。\n\n堆内存分三个区域：\n\n+ 新生区（伊甸园区-Eden Space）\n+ 养老区\n+ 永久区\n\n![image-20210130133228954](JVM学习笔记/image-20210130133228954.png)\n\nGC垃圾回收主要在伊甸园区和养老区。\n\n假设内存满了，OOM错误，堆内存不够！`java.lang.OutOfMemoryError:java heap space`\n\n在JDK1.8之后，永久存储区改名（元空间）。\n\n### 新生区\n\n+ 类：诞生和应用甚至死亡。\n+ 伊甸园区：所有对象都是在伊甸园区new出来的\n+ 幸存者区（0，1）\n\n伊甸园区满了触发轻GC\n\n养老区新生区都满触发Full GC\n\n![image-20210130154505879](JVM学习笔记/image-20210130154505879.png)\n\n**HotSpot虚拟机默认Eden和Survivor的大小比例是8:1**\n\n### 永久区\n\n这个区域常驻内存，用来存放JDK自身携带的Class对象，interface元数据，存储的是java运行时一些环境或类信息，这个区域不存在垃圾回收！关闭虚拟机就会释放这个区域的内存。\n\n一个启动类，加载了大量第三方jar包，Tomcat部署太多应用，大量动态生成反射类，可能会导致OOM。\n\n+ JDK1.6之前：永久代，常量池在方法区中\n+ JDK1.7：提出去永久代，常量池在堆中\n+ JDK1.8之后：无永久代，常量池在元空间\n\n![image-20210130142126569](JVM学习笔记/image-20210130142126569.png)\n\n\n\n使用JVM参数：\n\n`-Xms1024m -Xmx1024m -XX:+PrintGCDetails`\n\n输出GC的一些详细运行信息\n\n运行一个测试数据，运行结果：\n\n![image-20210130142230049](JVM学习笔记/image-20210130142230049.png)\n\n**元空间逻辑上存在，物理上不存在！**证明如下：\n\n![image-20210130142601948](JVM学习笔记/image-20210130142601948.png)\n\n### 测试OOM\n\n```java\npackage com.codefriday;\n\npublic class Demo02 {\n    public static void main(String[] args) {\n        String str = \"test out of memory\";\n        while(true){\n            str += str;\n        }\n    }\n}\n\n```\n\n输出：\n\n![image-20210130143300781](JVM学习笔记/image-20210130143300781.png)\n\n\n\n## 使用内存分析工具分析OOM\n\n`Eclipse`中有一个`MTA(Memory Analyzer)`\n\n在此使用`Jprofiler`\n\n+ 首先在`IDEA-File-settings-plugins`中搜索`Jprofiler`插件安装\n\n  ![image-20210130145857762](JVM学习笔记/image-20210130145857762.png)\n\n+ 在https://www.ej-technologies.com\n\n  官网下载`Jprofiler`客户端并安装\n\n+ 在IDEA中点击Jprofiler图标并关联到客户端安装目录下的Jprofiler.exe程序。\n\n`-Xms`：设置初始化内存分配大小，默认1/64\n\n`-Xmx`：设置最大分配内存，默认1/4\n\n`-XX:+PrintGCDetails`：打印GC信息\n\n`-XX:HeapDumpOnOutOfMemoryError`：对应错误生成Dump文件\n\n**编写会导致OOM错误的程序：**\n\n使用`JVM`参数修改一个较小的运行内存，并且生成dump文件\n\n```java\npackage com.codefriday;\n\nimport java.util.ArrayList;\n\npublic class Demo02 {\n    byte[] array = new byte[1024];\n    public static void main(String[] args) {\n        ArrayList<Demo02> arrayList = new ArrayList<Demo02>();\n        while(true){\n            arrayList.add(new Demo02());\n        }\n    }\n}\n```\n\n**调参生成dump文件，内存快照**\n\n`-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemory`\n\n![image-20210130183801909](JVM学习笔记/image-20210130183801909.png)\n\n打开生成的hprof后缀的文件可定位错误代码位置\n\n![image-20210130183917444](JVM学习笔记/image-20210130183917444.png)\n\n还可以查看占用较大内存的对象，以及对象的一些操作：\n\n![image-20210130184156775](JVM学习笔记/image-20210130184156775.png)\n\n## GC\n\n![image-20210130152143238](JVM学习笔记/image-20210130152143238.png)\n\nJVM在进行垃圾回收时，大部分时间回收新生代。 \n\n+ 新生代\n  + Eden\n  + From Survivor\n  + To Survivor\n+ 老年区\n\n**GC分类**\n\n+ 轻GC（普通GC）针对Eden以及少部分Survivor\n+ 重GC（全局GC）\n\n### GC算法评价指标\n\nJava万物皆对象，实际回收的垃圾就是所谓的对象，对象都是new出来的，在C/C++中使用new是分配内存用的，但是new完必须delete，否则会造成内存泄漏。\n\n**1、吞吐量**：即单位时间内的处理能力。\n\n**2、最大暂停时间**：因执行GC而暂停执行程序所需的时间。\n\n**3、堆的使用效率**：鱼与熊掌不可兼得，堆使用效率和吞吐量、最大暂停时间是不可能同时满足的。即可用的堆越大，GC运行越快；相反，想要利用有限的堆，GC花费的时间就越长。\n\n**4、访问的局部性**：在存储器的层级构造中，我们知道越是高速存取的存储器容量会越小（具体可以参看我写的存储器那篇文章）。由于程序的局部性原理，将经常用到的数据放在堆中较近的位置，可以提高程序的运行效率。\n\n### 引用计数法\n\n**引用计数算法(reference-counting) :**每个对象有一个引用计数器，当对象被引用一次则计数器加1，当对象引用失效一次则计数器减1，对于计数器为0的对象意味着是垃圾对象，可以被GC回收。\n\n引用计数算法的问题：\n\n```java\npackage com.codefriday;\n\npublic class GcTest {\n    public static void main(String[] args) {\n        TestObj Obj1 = new TestObj();   //新生成一个对象，Obj1引用计数器=1\n        TestObj Obj2 = new TestObj();   //新生成一个对象，Obj2引用计数器=1\n\n        Obj1.reference = Obj2;      //Obj2被引用，Obj2引用计数器+1 --> 2\n        Obj2.reference = Obj1;      //Obj1被引用，Obj1引用计数器+1 --> 2\n\n        Obj1 = null;    //Obj1引用-1 -->1\n        Obj2 = null;    //Obj1引用-1 -->1\n    }\n}\nclass TestObj{\n    public TestObj reference = null;\n}\n```\n\n实际此时两个对象都有引用，即相互引用，但是外部已经不被引用，而由于计数器不为0，不会被GC回收，此时就有内存泄漏！\n\n### 根搜索算法\n\n**可达性算法(GC Roots Tracing):**从GC Roots作为起点开始搜索，那么整个连通图中的对象便都是活对象，对于GC Roots无法到达的对象便成了垃圾回收的对象，随时可被GC回收。\n\n~~刚学完编译原理，代码优化阶段中有一个到达定义分析，有着差不多思想！~~\n\n**根（GC Roots）：**\n\n说到GC roots（GC根），在JAVA语言中，可以当做GC roots的对象有以下几种：\n\n**1、栈（栈帧中的本地变量表）中引用的对象。**\n\n**2、方法区中的静态成员。**\n\n**3、方法区中的常量引用的对象（全局变量）**\n\n**4、本地方法栈中JNI（一般说的Native方法）引用的对象。**\n\n在根搜索算法的基础上，现代虚拟机的实现当中，**垃圾搜集的算法**主要有三种，分别是**标记-清除算法、复制算法、标记-整理**算法。这三种算法都扩充了根搜索算法。\n\n### **标记-清除算法：**\n\n**1、标记清除算法的概念：**\n\n标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，**首先通过根节点，标记所有从根节点开始的可达对象**。因此，未被标记的对象就是未被引用的垃圾对象；然后，在清除阶段，清除所有未被标记的对象。\n\n![img](JVM学习笔记/201002487061086.png)\n\n**2、标记-清除算法详解：**\n\n它的做法是当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被成为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。\n\n- 标记：标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。\n- 清除：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。\n\n也就是说，**就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行**。\n\n**3、标记-清除算法的缺点：**\n\n（1）首先，**它的缺点就是效率比较低（递归与全堆对象遍历）**，导致stop the world的时间比较长，尤其对于交互式的应用程序来说简直是无法接受。试想一下，如果你玩一个网站，这个网站一个小时就挂五分钟，你还玩吗？\n\n（2）第二点主要的缺点，则是**这种方式清理出来的空闲内存是不连续的**，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。\n\n ### 复制算法：（新生代的GC）\n\n**复制算法的概念：**\n\n将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。\n\n- 与标记-清除算法相比，复制算法是一种相对高效的回收方法\n- 不适用于存活对象较多的场合，如老年代（复制算法**适合做新生代的GC**）\n\n![ff1e1846-e49c-4663-aee1-7c63628f567c](JVM学习笔记/201002560357091.png)\n\n- **复制算法的最大的问题是：空间的浪费**\n\n复制算法使得每次都只对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。\n\n现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是**将内存分为一块比较大的Eden空间和两块较小的Survivor空间**，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。\n\n**因此幸存区分From和To两个区域，谁空的谁就是To区域。**\n\n98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活**，当Survivor空间不够用时，需要依赖于老年代进行分配担保，所以大对象直接进入老年代**。整个过程如下图所示：\n\n![7e1f6ed2-e0c4-45e4-b7db-b59c28e1ee9c](JVM学习笔记/201002573639064.png)\n\n当复制超过15次时（默认值），对象进入老年代。\n\n对象晋升老年代的年龄阈值，可以通过参数` -XX:MaxTenuringThreshold `来设置。\n\n### 标记-整理算法：（老年代的GC）\n\n**概念：**\n\n标记-压缩算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记；但之后，它并不简单的清理未标记的对象，而是**将所有的存活对象压缩到内存的一端；**之后，清理边界外所有的空间。\n\n![cc79889a-0856-4018-92c3-c51108c9caea](JVM学习笔记/201003005357866.png)\n\n- **标记：它的第一个阶段与标记/清除算法是一模一样的，均是遍历GC Roots，然后将存活的对象标记。\n  **\n- **整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。**\n\n### GC算法总结\n\n在GC线程开启时，或者说GC过程开始时，它们都要暂停应用程序（stop the world）。\n\n（1）**效率：**复制算法>标记/整理算法>标记/清除算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。\n\n（2）**内存整齐度**：复制算法=标记/整理算法>标记/清除算法。\n\n（3）**内存利用率：**标记/整理算法=标记/清除算法>复制算法。","tags":["第一阶段"],"categories":["第一阶段"]},{"title":"注解和反射","url":"/2021/01/29/注解和反射/","content":"\n## Java.Annotation\n\n### 什么是注解\n\n+ Annotation是JDK5.0开始引入的新技术\n\n+ Annotation的作用\n\n  + 不是程序本身，可以对程序做出解释（这一点和注释（comment）没什么区别）\n\n  + 可以被其他程序读取，如编译器\n\n+ Annotation的格式\n  + 以“@注释名”在代码中存在，还可以添加以下参数值，例如：@SuppressWarnings(value=\"all\")\n\n+ 注解可以附加在package，class，method等上面，可以通过反射机制编程实现对这些元数据的访问。\n\n### 内置注解\n\n+ @Override\n\n  ```java\n  @Target(ElementType.METHOD)\n  @Retention(RetentionPolicy.SOURCE)\n  public @interface Override {\n  }\n  ```\n\n  只修饰方法，表示重写方法。\n\n+ @Deprecated\n\n  ```java\n  @Documented\n  @Retention(RetentionPolicy.RUNTIME)\n  @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})\n  public @interface Deprecated {\n  }\n  ```\n\n  表示被遗弃的方法\n\n+ @SuppressWarnings\n\n  ```java\n  @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})\n  @Retention(RetentionPolicy.SOURCE)\n  public @interface SuppressWarnings {\n      /**\n       * The set of warnings that are to be suppressed by the compiler in the\n       * annotated element.  Duplicate names are permitted.  The second and\n       * successive occurrences of a name are ignored.  The presence of\n       * unrecognized warning names is <i>not</i> an error: Compilers must\n       * ignore any warning names they do not recognize.  They are, however,\n       * free to emit a warning if an annotation contains an unrecognized\n       * warning name.\n       *\n       * <p> The string {@code \"unchecked\"} is used to suppress\n       * unchecked warnings. Compiler vendors should document the\n       * additional warning names they support in conjunction with this\n       * annotation type. They are encouraged to cooperate to ensure\n       * that the same names work across multiple compilers.\n       * @return the set of warnings to be suppressed\n       */\n      String[] value();\n  }\n  ```\n\n  用于抑制警告用的。\n\n### 元注解\n\n+ 元注解的作用就是负责注解其他注解，Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型的说明\n+ 这些类型和他们支持的类在java.lang.annotation中可以找到\n+ @Target：用于描述注解使用范围。\n+ @Retention：表示需要在什么级别保存该注释信息，用于描述生命周期\n  + SOURCE<CLASS<RUNTIME\n\n+ @Document：说明该注释将被包含在javadoc中\n+ @Inherited：说明子类可以继承父类中的该注解\n\n### 自定义注解\n\n+ 使用`@interface`自定义注解，自动继承`java.lang.annotation.Annotation`接口\n+ 可以定义一些参数\n  + 参数类型只能是Class，String，Enum\n  + 格式：参数类型+参数名+（）\n  + 如果只有一个参数，建议命名为value，在使用注解时可以简写\n  + 注解参数无默认值使用时必须给定\n\n实例：\n\n```java\npackage com.codefriday;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Target;\n@MyAnnotation(3)//value = 3简写\npublic class Test {\n\n    public static void main(String[] args) {\n\n\n    }\n}\n@Target({ElementType.METHOD,ElementType.TYPE})\n@interface MyAnnotation{\n    int id() default 0;\n    int value();//定义value\n    String name () default \"\";\n}\n\n```\n\n## Java.Reflection\n\n+ Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。\n\n  `Class c = Class.forName(\"java.lang.String\")`\n\n+ **加载完类之后**，在堆内存的方法区中就产生一个Class类型的对象（一个类只有一个Class对象），这个对象包含完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以形象的称为反射。\n\n### Class类\n\n一个Class对象包含了特定的某个结构中的有关信息\n\n+ Class本身也是一个类\n+ Class对象只能由系统建立对象\n+ 一个加载的类在JVM中只会有一个Class实例\n+ 一个Class对象对应的是一个加载到JVM中的一个class文件\n+ 每个类的实例都会接的自己是由那个Class实例生成\n\n#### Class类常用方法\n\n![image-20210129115000891](注解和反射/image-20210129115000891.png)\n\n#### 获取Class类的实例\n\n+ 已知具体类，通过类的class属性获取，最可靠，性能最高。\n\n  `Class clazz = User.class`\n\n+ 已知某个类的实例，调用实例的`getClass()`方法获取`Class`对象\n\n  `Class clazz = user.getClass();`\n\n+ 已知类的全类名，且该类在路径下，可通过Class类的静态方法`forName()`获取，可能抛出`ClassNotFoundException`\n\n  `Class clazz = Class.forName(\"demo.User\");`\n\n测试：\n\n```java\npackage com.codefriday.demo01;\n\n\n\npublic class Test01 {\n    public static void main(String[] args) throws ClassNotFoundException {\n        //方法一 : 类的class属性\n        Class c1 = User.class;\n        System.out.println(c1);\n        //方法二 : 类实例对象的getClass方法\n        User user = new User();\n        Class c2 = user.getClass();\n        System.out.println(c2);\n        //方法三 : Class的静态方法forName\n        Class c3 = Class.forName(\"com.codefriday.demo01.User\");\n        System.out.println(c3);\n        //方法四 : 基本内置类型的包装类都有一个Type属性\n        Class c4 = Integer.TYPE;\n        System.out.println(c4);\n        //方法五 : 获得父类 类型\n        Class c5 = Man.class;\n        Class c5s = c5.getSuperclass();\n        System.out.println(c5s);\n\n    }\n}\nclass User{\n    private int id;\n    private String name;\n    private int age;\n    public User(){ }\n    public User(int id, String name, int age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\nclass Man extends User{\n}\n```\n\n![image-20210129121137181](注解和反射/image-20210129121137181.png)\n\n#### 哪些类型有Class对象\n\n+ class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类。\n+ interface：接口\n+ []：数组\n+ enum：枚举\n+ annotation：注解\n+ primitive type：基本数据类型\n+ void\n\n测试：\n\n```java\npackage com.codefriday.Demo02;\n\nimport java.lang.annotation.ElementType;\n\npublic class Test02 {\n    public static void main(String[] args) {\n        Class c1 = Override.class;  //注解\n        Class c2 = void.class;  //void\n        Class c3 = int.class;  //基本数据类型\n        Class c4 = ElementType.class;  //枚举\n        Class c5 = String[].class;  //一维数组\n        Class c6 = int[][].class; //二维数组\n        Class c7 = Class.class;  //Class本身\n        Class c8 = Runnable.class;  //接口\n        Class c9 = Object.class;  //类\n\n        System.out.println(c1);\n        System.out.println(c2);\n        System.out.println(c3);\n        System.out.println(c4);\n        System.out.println(c5);\n        System.out.println(c6);\n        System.out.println(c7);\n        System.out.println(c8);\n        System.out.println(c9);\n    }\n}\n\n```\n\n![image-20210129122250058](注解和反射/image-20210129122250058.png)\n\n只要元素类型与维度一样，就是同一个Class！！！\n\n## Java内存分析\n\n![image-20210129122929236](注解和反射/image-20210129122929236.png)\n\n### 类的加载\n\n![image-20210129123021668](注解和反射/image-20210129123021668.png)\n\n+ 加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的`java.lang.Class`对象\n+ 链接：将Java类的二进制代码合并到JVM的运行状态之中的过程\n  + 验证：确保加载的类信息符合JVM规范，没有安全方面问题\n  + 准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配\n  + 解析：虚拟机常量池内的符号引用（常量名）替换成直接引用（地址）的过程\n\n+ 初始化\n  + 执行类构造器\"<\"clinit\">\"()方法的过程。类构造器\"<\"clinit\">\"()方法是由编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类i构造器是构造类信息的，不是构造该类对象的构造器）\n  + 当初始化一个类时，如果怕发现其父类还未初始化，则需要先触发其父类的初始化。\n  + 虚拟机保证一个类的\"<\"clinit\">\"()方法在多线程环境中被正确加锁和同步。\n\n### 类初始化\n\n什么时候发生类的初始化\n\n+ 类的主动引用（一点会发生类的初始化）\n  + 虚拟机启动，先初始化main方法所在的类\n  + new一个类的对象\n  + 调用类的静态成员（除了final常量）和静态方法\n  + 使用`java.lang.reflect`包的方法对类进行反射调用\n  + 当初始化一个类，如果其父没有被初始化，则先初始化它的父类\n\n+ 类的被动引用\n\n  + 当访问一个静态域时，只有真正声明这个域的类才会被初始化，如：当通过**子类引用父类的静态变量**，不会导致子类初始化\n\n  + 通过数组定义类的引用，不会触发此类的初始化\n\n    `Son[] array = new Son();`\n\n  + 引用常量不会触发类的初始化（**常量在链接阶段**就存入调用类的常量池中了）\n\n### 类加载器\n\n+ 类加载器的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区运行时数据结构，然后在堆中生成一个代表这个类的`java.lang.Class`对象，作为方法区中类数据的访问入口。\n+ 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类夹在其中，他将维持加载一段时间。\n\n![image-20210129134225781](注解和反射/image-20210129134225781.png)\n\n![image-20210129134537990](注解和反射/image-20210129134537990.png)\n\n+ 引导类加载器：C++编写，是JVM自带的类加载器，负责**Java平台核心库（JRE-lib-rt.jar）**,用来装载核心类库。该加载器无法直接获取。\n+ 扩展类加载器：负责`jre/lib/ext`目录下的jar包或`- D java.ext.dirs`指定目录下的jar包装入工作库。\n\n+ 系统类加载器：负责`java -classpath`或`-D java.class.path`所指定目录下的类与jar包装入工作，是最常用的加载器。\n\n```java\npackage com.codefriday.Demo03;\n\npublic class Test03 {\n    public static void main(String[] args) throws ClassNotFoundException {\n        //获得系统类加载器\n        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n        System.out.println(systemClassLoader);\n        //获得系统加载器的父类加载器-->扩展类加载器\n        ClassLoader parent = systemClassLoader.getParent();\n        System.out.println(parent);\n        //获得扩展类加载器的父类加载器-->根加载器，引导类加载器，无法获取，将返回null\n        ClassLoader parent1 = parent.getParent();\n        System.out.println(parent1);\n\n        //测试当前类是哪个加载器加载的\n        ClassLoader classLoader = Class.forName(\"com.codefriday.Demo03.Test03\").getClassLoader();\n        System.out.println(classLoader);\n        //测试JDK中的类是哪个加载器加载的\n        ClassLoader classLoader1 = Class.forName(\"java.lang.String\").getClassLoader();\n        System.out.println(classLoader1);\n\n        //如何获得系统类加载器可以加载的路径\n        System.out.println(System.getProperty(\"java.class.path\"));\n        //输出如下：\n        /*\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\charsets.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\deploy.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\access-bridge-32.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\cldrdata.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\dnsns.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\jaccess.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\jfxrt.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\localedata.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\nashorn.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\sunec.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\sunjce_provider.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\sunmscapi.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\sunpkcs11.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\ext\\zipfs.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\javaws.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\jce.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\jfr.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\jfxswt.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\jsse.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\management-agent.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\plugin.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\resources.jar;\n        D:\\Java\\jdk1.8.0_271\\jre\\lib\\rt.jar;\n        D:\\IdeaProjects\\Reflection\\out\\production\\Reflection;\n        D:\\JetBrains\\IntelliJ IDEA 2020.3.1\\lib\\idea_rt.jar\n\n         */\n    }\n}\n\n```\n\n![image-20210129135508876](注解和反射/image-20210129135508876.png)\n\n双亲委派机制：加载类时，根加载器加载了的类，自己写一个同名类被系统加载器加载时会向上查找安全性！！！自己写的用不起来。\n\n## 创建运行时类的对象\n\n### 获取属性，方法，构造器\n\n```java\npackage com.codefriday.Demo04;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\npublic class Test04 {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException {\n        //获得Class\n        Class c1 = Class.forName(\"com.codefriday.Demo04.User\");\n        //通过Class方法获取类名\n        System.out.println(c1.getName());  //获得包名+类名\n        System.out.println(c1.getSimpleName());  //获得类名\n\n\n        //获取属性字段\n        Field[] fields1 = c1.getFields();  //只能获取public\n        System.out.println(c1.getDeclaredField(\"name\"));    //可以获取私有属性\n        Field[] fields = c1.getDeclaredFields();\n        for (Field field : fields) {\n            System.out.println(field);\n        }\n\n        System.out.println(\"==========\");\n        //获得类的方法\n        Method[] methods = c1.getMethods();  //获得本类以及父类的所有public方法\n        for (Method method : methods) {\n            System.out.println(method);\n        }\n        //获得本类的所有方法，包含私有\n        System.out.println(\"===========\");\n        methods = c1.getDeclaredMethods();\n        for (Method method : methods) {\n            System.out.println(method);\n        }\n\n        //获得指定方法\n        //需要给定参数类型，原因：方法重载，参数列表可能不同！！！\n        Method getAge = c1.getMethod(\"getAge\", null);\n        Method setAge = c1.getMethod(\"setAge\", int.class);\n\n        System.out.println(\"=======\");\n        //获得所有构造器\n        Constructor[] constructors = c1.getConstructors();\n        for (Constructor constructor : constructors) {\n            System.out.println(constructor);\n        }\n        //获得指定构造器\n        Constructor constructor = c1.getConstructor(int.class, String.class, int.class);\n        System.out.println(constructor);\n    }\n}\nclass User{\n    private int id;\n    private String name;\n    private int age;\n    public User(){ }\n    public User(int id, String name, int age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n    private void test(){}\n}\n```\n\n### 如何使用\n\n+ 动态创建类对象：调用Class对象的`newInstance()`方法\n  + 1)类必须有一个无参数构造器\n  + 2)类的构造器访问权限需要足够\n\n没有无参构造器时，只要在操作的时候明确调用类中的构造器，并将参数传递进去之后，才可以实例化操作。\n\n步骤如下：\n\n1）通过Class类的`getDeclaredConstructor(Class<?>... parameterTypes)`取得本类指定参数类型的构造器\n\n2）向构造器形参中传递一个对象数组进去，里面包含了构造器所需要的参数。\n\n3）通过`Constructor`实例化对象\n\n+ 操作方法\n+ 操作属性\n+ 操作构造器\n\n```java\npackage com.codefriday.Demo04;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class Test05 {\n    public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {\n        Class c1 = User.class;\n        //反射无参构造\n        User user = (User)c1.newInstance();\n        System.out.println(user);\n        //反射有参构造\n        Constructor constructor = c1.getConstructor(int.class, String.class, int.class);\n        User user2 = (User)constructor.newInstance(1, \"xx\", 2);\n        System.out.println(user2.toString());\n\n        //反射获得方法\n        User user3 = (User) c1.newInstance();\n        Method setName = c1.getMethod(\"setName\", String.class);\n        //调用方法,传入类对象+参数，invoke（激活）\n        setName.invoke(user3,\"codefriday\");\n        System.out.println(user3);\n\n\n        //通过反射操作属性\n\n        User user4 = (User) c1.newInstance();\n        System.out.println(user4);\n        Field name = c1.getDeclaredField(\"name\");\n\n        /**直接操作私有属性修改会报错\n            name.set(user4,\"codefriday\");\n            System.out.println(user4);\n        */\n        //调用setAccessible关闭程序安全检测\n        name.setAccessible(true);\n        name.set(user4,\"codefriday\");\n        System.out.println(user4);\n    }\n}\n```\n\n## 获得泛型信息\n\n![image-20210129152346769](注解和反射/image-20210129152346769.png)\n\n```java\npackage com.codefriday.Demo04;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Test06 {\n    public void test001(Map<String,User> map, List<User> list){\n        System.out.println(\"test001\");\n    }\n\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException {\n        //反射获得Class\n        Class c1 = Class.forName(\"com.codefriday.Demo04.Test06\");\n        //获得方法\n        Method method = c1.getMethod(\"test001\", Map.class, List.class);\n        //获得参数类型\n        Type[] genericParameterTypes = method.getGenericParameterTypes();\n        for (Type genericParameterType : genericParameterTypes) {\n            System.out.println(\"###\"+genericParameterType);\n            //判断是否为参数化类型，强转输出\n            if(genericParameterType instanceof ParameterizedType){\n                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();\n                for (Type actualTypeArgument : actualTypeArguments) {\n                    System.out.println(actualTypeArgument);\n                }\n\n            }\n        }\n    }\n}\n\n```\n\n## 反射操作注解\n\n+ getAnnotations\n+ getAnnotation\n\n`ORM：Object relationship Mapping -->对象关系映射`\n\n练习实例：\n\n```java\npackage com.codefriday.ExeAnnotation;\n\nimport java.lang.annotation.*;\nimport java.lang.reflect.Field;\n\npublic class Practice {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {\n        //1.反射获得Class\n        Class c1 = Class.forName(\"com.codefriday.ExeAnnotation.User\");\n        //2.反射操作获得注解\n        Annotation[] annotations = c1.getAnnotations();\n        for (Annotation annotation : annotations) {\n            System.out.println(annotation);\n        }\n        System.out.println(\"==========\");\n        //3.获得指定注解的值\n        Table table = (Table)c1.getDeclaredAnnotation(Table.class);\n        System.out.println(table.value());\n\n        System.out.println(\"==========\");\n        //4.获得类中属性上的注解\n        Field field = c1.getDeclaredField(\"id\");\n        TableColumn annotation = (TableColumn)field.getAnnotation(TableColumn.class);\n        System.out.println(annotation.name());\n        System.out.println(annotation.type());\n        System.out.println(annotation.length());\n\n    }\n}\n@Table(\"db_user\")\nclass User{\n    @TableColumn(name=\"db_id\",type = \"int\",length = 10)\n    private int id;\n    @TableColumn(name=\"db_name\",type = \"varchar\",length = 3)\n    private String name;\n    @TableColumn(name=\"db_age\",type = \"int\",length = 10)\n    private int age;\n\n    public User() {\n    }\n\n    public User(int id, String name, int age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n}\n//定义注解，表格名字\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@interface Table{\n    String value();\n}\n//定义注解，表格一列\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface TableColumn{\n    String name();\n    String type();\n    int length();\n\n}\n```\n\n## 总结\n\n![](注解和反射/注解&反射思维导图.jpg)","tags":["第一阶段"],"categories":["第一阶段"]},{"title":"多线程编程基础","url":"/2021/01/28/多线程编程基础/","content":"\n## 线程实现的三种方式\n\n### 继承Thread\n\n+ 自定义线程类继承Thread\n+ 重写run()方法，编写线程执行体\n+ 创建线程对象，调用start()方法启动线程\n\n多线程下载网路图片：\n\n```java\npackage com.codefriday.Demo02;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\n//多线程下载网图\npublic class TestThread02 extends Thread{\n    private String url;\n    private String name;\n    public TestThread02(String url,String name){\n        this.url = url;\n        this.name = name;\n    }\n    @Override\n    public void run() {\n        new WebDownloader().downloader(url,name);\n        System.out.println(\"下载了\"+name);\n    }\n\n    public static void main(String[] args) {\n        TestThread02 t1 = new TestThread02(\"https://www.codefriday.cn/2021/01/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1.png\",\"1.png\");\n        TestThread02 t2 = new TestThread02(\"https://www.codefriday.cn/2021/01/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/d8f9d72a6059252d20d93b0a6645fb3e59b5b9d2.jpeg\",\"2.jpeg\");\n        TestThread02 t3 = new TestThread02(\"https://www.codefriday.cn/2021/01/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/861fa058f2da35f8efa70b29bf7c45fd8689.gif\",\"3.gif\");\n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}\nclass WebDownloader{\n    public void downloader(String url,String name){\n        try {\n            FileUtils.copyURLToFile(new URL(url),new File(name));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.out.println(\"IO异常，下载器有问题！\");\n        }\n    }\n}\n```\n\n图片来自个人博客\n\n![image-20210128113223573](多线程编程基础/image-20210128113223573.png)\n\n### 实现Runnable接口\n\nThread类也是实现了Runnable接口\n\n+ 定义MyRunnable类实现Runnable接口\n+ 实现run()方法，编写线程执行体\n+ 创建线程对象，调用start()方法启动线程\n\n\n\n+ 创建实例类对象\n+ 创建代理类对象\n+ 启动\n\n```java\npackage com.codefriday.Demo03;\n\npublic class TestThread implements Runnable{\n    @Override\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            System.out.println(\"我是子线程\"+i);\n        }\n    }\n\n    public static void main(String[] args) {\n\n        TestThread t1 = new TestThread();\n        new Thread(t1).start();\n        for (int i = 0; i < 1000; i++) {\n            System.out.println(\"我是主线程\"+i);\n        }\n    }\n}\n\n```\n\n代理模式方便多个线程使用一个对象\n\n### 实现Callable接口\n\n1.实现Callable接口，需要返回值类型\n\n2.重写call方法，需要抛出异常\n\n3.创建目标对象\n\n4.创建执行服务：`ExcutorService ser = Excutors.newFixedThreadPool(1);`\n\n5.提交执行：`Future<Boolean> result1 = ser.submit(t1);`\n\n6.获取结果：`boolean r1 = result1.get();`\n\n7.关闭服务：`ser.shutdownNow();`\n\n```java\npackage com.codefriday.Demo05;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.concurrent.*;\n\npublic class TestCallable implements Callable<Boolean> {\n    private String url;\n    private String name;\n    public TestCallable(String url,String name){\n        this.url = url;\n        this.name = name;\n    }\n    @Override\n    public Boolean call() {\n        new WebDownloader().downloader(url,name);\n        System.out.println(\"下载了\"+name);\n        return true;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        TestCallable t1 = new TestCallable(\"https://www.codefriday.cn/2021/01/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1.png\",\"1.png\");\n        TestCallable t2 = new TestCallable(\"https://www.codefriday.cn/2021/01/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/d8f9d72a6059252d20d93b0a6645fb3e59b5b9d2.jpeg\",\"2.jpeg\");\n        TestCallable t3 = new TestCallable(\"https://www.codefriday.cn/2021/01/27/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/861fa058f2da35f8efa70b29bf7c45fd8689.gif\",\"3.gif\");\n        //创建执行服务\n        ExecutorService ser = Executors.newFixedThreadPool(3);\n        //提交执行\n        Future<Boolean> r1 = ser.submit(t1);\n        Future<Boolean> r2 = ser.submit(t2);\n        Future<Boolean> r3 = ser.submit(t3);\n        //获取结果\n        boolean rs1 = r1.get();\n        boolean rs2 = r2.get();\n        boolean rs3 = r3.get();\n        //关闭服务\n        ser.shutdownNow();\n\n    }\n}\n\nclass WebDownloader{\n    public void downloader(String url,String name){\n        try {\n            FileUtils.copyURLToFile(new URL(url),new File(name));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.out.println(\"IO异常，下载器有问题！\");\n        }\n    }\n}\n```\n\n\n\n## 并发问题\n\n实现Runnable接口多个线程使用同一个对象时，操作共享数据。\n\n```java\npackage com.codefriday.Demo04;\n\npublic class TestThread04 implements Runnable{\n    private int ticketNums = 10;\n    @Override\n    public void run() {\n        while(true){\n            if(ticketNums<=0){\n                break;\n            }\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName()+\"-->抢到了第\"+ticketNums--+\"张票\");\n        }\n    }\n\n    public static void main(String[] args) {\n        TestThread04 ts = new TestThread04();\n        new Thread(ts,\"A\").start();\n        new Thread(ts,\"B\").start();\n        new Thread(ts,\"C\").start();\n    }\n}\n\n```\n\n![image-20210128125003336](多线程编程基础/image-20210128125003336.png)\n\n## 静态代理\n\n+ 真实对象和代理对象都要实现同一个接口\n+ 代理对象要代理真实角色\n\n**好处：**\n\n+ 代理对象可以做很多真实对象做不了的事\n\n+ 真实对象可以专注自己的事\n\n实例：\n\n```java\npackage com.codefriday.ProxyStatic;\n\npublic class StaticProxy {\n    public static void main(String[] args) {\n        //代理模式\n        You you = new You();\n        new WeddingCompany(you).HappyMarry();\n        /***\n         * 对比Thread\n         * 都实现了Runnable接口\n         * 然后自己实现的类作为Thread的参数\n         */\n    }\n}\n//公共接口\ninterface Marry{\n    void HappyMarry();\n}\n//真实对象实现接口\nclass You implements Marry{\n    @Override\n    public void HappyMarry() {\n        System.out.println(\"你 要结婚了！\");\n    }\n}\n//代理类实现接口\nclass WeddingCompany implements Marry{\n    private Marry target;\n    public WeddingCompany(Marry target){\n        this.target = target;\n    }\n    @Override\n    public void HappyMarry() {\n        before();\n        this.target.HappyMarry();\n        after();\n    }\n\n    private void after() {\n        System.out.println(\"结婚之后！\");\n    }\n\n    private void before() {\n        System.out.println(\"结婚之前！\");\n    }\n}\n\n\n```\n\n## Lamda表达式\n\n+ 避免匿名内部类过多\n+ 实质是函数式编程\n\n+ 理解Function interface（函数式接口）是学习Java8 Lamda表达式关键\n\n+ 函数式接口的定义\n\n  + 任何接口，如果只包含唯一的抽象方法，那么他就是一个函数式接口\n\n    Runnable接口中就只有一个run方法。源码如下：\n\n    ```java\n    @FunctionalInterface\n    public interface Runnable {\n        /**\n         * When an object implementing interface <code>Runnable</code> is used\n         * to create a thread, starting the thread causes the object's\n         * <code>run</code> method to be called in that separately executing\n         * thread.\n         * <p>\n         * The general contract of the method <code>run</code> is that it may\n         * take any action whatsoever.\n         *\n         * @see     java.lang.Thread#run()\n         */\n        public abstract void run();\n    }\n    ```\n\n  + 对于函数式接口，我们可以通过Lamda表达式来创建该接口的对象\n\n  + 参数类型可以简化去掉\n  + 参数的圆括号可以去掉\n  + 多个参数也可以去掉参数类型，但必须统一，并且必须加上括号\n  + 花括号中只有一句话可以去掉花括号\n\n```java\npackage com.codefriday.Lambda;\n\npublic class TestLambda {\n    //静态内部类\n    static class Tiger implements Animal{\n        @Override\n        public void what() {\n            System.out.println(\"方法二：静态内部类\");\n            System.out.println(\"It's a Tiger\");\n        }\n    }\n    public static void main(String[] args) {\n        Animal animal;\n        //外部实现类\n        animal = new Cat();\n        animal.what();\n        //静态内部类\n        animal = new Tiger();\n        animal.what();\n        //局部内部类\n        class Bird implements Animal{\n            @Override\n            public void what() {\n                System.out.println(\"方法三：局部内部类\");\n                System.out.println(\"It's a Bird\");\n            }\n        }\n        animal = new Bird();\n        animal.what();\n        //匿名内部类\n        animal = new Animal() {\n            @Override\n            public void what() {\n                System.out.println(\"方法四：匿名内部类\");\n                System.out.println(\"It's a Dog\");\n            }\n        };\n        animal.what();\n\n        //Lambda表达式\n        animal= ()-> {\n            System.out.println(\"方法五：Lambda表达式\");\n            System.out.println(\"It's a Lion\");\n        };\n        animal.what();\n    }\n}\ninterface Animal{\n    void what();\n}\n//方法一：实现接口中的方法\nclass Cat implements Animal{\n    @Override\n    public void what() {\n        System.out.println(\"方法一：实现接口中的方法\");\n        System.out.println(\"It's a cat\");\n    }\n}\n```\n\n运行结果：\n\n![image-20210128143952341](多线程编程基础/image-20210128143952341.png)\n\nLambda表达式简化实例：\n\n```java\npackage com.codefriday.Lambda;\n\npublic class TestLambda02 {\n    public static void main(String[] args) {\n        Do test = null;\n        //正常Lambda表达式\n        test = (int a,int b,int c)->{\n            System.out.println(a);\n            System.out.println(b);\n            System.out.println(c);\n        };\n        test.DoIt(1,2,3);\n\n        //简化参数\n        test = (a,b,c)->{\n            System.out.println(a+b+c);\n        };\n\n        //简化花括号\n        test = (a,b,c)-> System.out.println(a+b+c);\n        \n    }\n}\ninterface Do{\n    void DoIt(int a,int b,int c);\n}\n```\n\n## 线程状态\n\n![image-20210128144830701](多线程编程基础/image-20210128144830701.png)\n\n线程方法\n\n![image-20210128145123583](多线程编程基础/image-20210128145123583.png)\n\n### 停止线程\n\n+ JDK提供的stop()，destory()方法已经废弃\n\n+ 推荐让线程自己停下来\n+ 建议使用一个标志位进行终止，自定义方法修改标志位\n\n### 线程休眠\n\n+ sleep(时间)指定休眠时间，单位为毫秒\n+ sleep存在异常InterruptionException\n+ sleep时间到后线程变为就绪态\n+ sleep可以模拟网络延时，倒计时等\n+ 每个对象都会有一个锁，sleep不会释放锁\n\n倒计时：\n\n```java\npackage com.codefriday.ThreadState;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n\npublic class TestSleep {\n    public static void main(String[] args) {\n        /*try {\n            tenDown();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }*/\n        Date date = new Date(System.currentTimeMillis());\n        while(true){\n            try {\n                Thread.sleep(1000);\n                System.out.println(new SimpleDateFormat(\"YYYY-MM-dd HH:mm:ss\").format(date));\n                date = new Date(System.currentTimeMillis());\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n\n        }\n\n    }\n    public static void tenDown() throws InterruptedException {\n        int num = 10;\n        while(true){\n            Thread.sleep(1000);\n            System.out.println(num--);\n            if(num<=0){\n                break;\n            }\n        }\n    }\n\n}\n\n```\n\n### 线程礼让yield\n\n+ 让当前线程暂停但不阻塞\n\n```java\npackage com.codefriday.ThreadState;\n\npublic class TestYield {\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread();\n        new Thread(myThread,\"A\").start();\n        new Thread(myThread,\"B\").start();\n    }\n}\nclass MyThread implements Runnable{\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName()+\"线程开始执行\");\n        Thread.yield();\n        System.out.println(Thread.currentThread().getName()+\"线程执行完毕\");\n    }\n}\n\n```\n\n运行结果：\n\n![image-20210128152827898](多线程编程基础/image-20210128152827898.png)\n\nCPU重新调度，礼让不一定成功。\n\n### Join\n\n+ Join合并线程，待此线程执行完后，再执行其他线程\n+ 可以理解为插队\n\n```java\npackage com.codefriday.ThreadState;\n\npublic class TestJoin {\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(()->{\n            for (int i = 0; i < 100; i++) {\n                System.out.println(\"Join-->\"+i);\n            }\n        });\n        thread.start();\n        for (int i = 0; i < 100; i++) {\n            System.out.println(\"main-->\"+i);\n            if(i == 50){\n                thread.join();\n            }\n        }\n\n\n\n    }\n}\n\n```\n\n### 观测线程的状态\n\nThread.State\n\n![image-20210128153511799](多线程编程基础/image-20210128153511799.png)\n\n### 线程的优先级\n\n+ JAVA提供一个线程调度器监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个程序来执行。\n\n+ 线程优先级用户数字1-10表示\n\n  ![image-20210128155035237](多线程编程基础/image-20210128155035237.png)\n\n+ 使用以下两种方法改变或者获取优先级\n  + getPriority\n  + setPriority(int xx)\n\n### 守护线程（daemon）\n\n+ 线程分为用户线程和守护线程\n+ 虚拟机必须确保用户线程执行完毕\n+ 虚拟机不用等待守护线程执行完毕\n+ 如：后台记录操作日志，监控内存，垃圾回收等等\n\n`.setDaemon(true)`，线程默认false是用户线程，调用此方法变为守护线程。\n\n## 线程同步\n\n多个线程操作同一个资源——并发\n\n形成条件：队列+锁\n\n锁机制synchronized\n\n+ 同步方法，使用synchronized修饰一个方法，锁定的就是this对象\n+ 同步块synchronized（Obj）{}\n+ 块中为对对象操作的语句\n\n同步代码块实现线程安全的ArrayList\n\n```java\npackage com.codefriday.UnsafeThread;\n\nimport java.util.*;\n\npublic class UnsafeInsert {\n\n    public static void main(String[] args) throws InterruptedException {\n        List<String> list = new ArrayList<>();\n\n        for (int i = 0; i < 10000; i++) {\n            new Thread(()->{\n                synchronized (list) {\n                    list.add(Thread.currentThread().getName());\n                }\n            }).start();\n        }\n        Thread.sleep(3000);\n        System.out.println(list.size());\n    }\n}\n\n```\n\n`JUC(ava.util.concurrent)`下有一个`CopyOnWriteArrayList`是线程安全的。\n\n## 死锁\n\n多个线程各自占有一些共享资源，并且相互等待其他线程占用的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。\n\n产生死锁的必要条件：\n\n+ 互斥，线程对资源互斥访问\n+ 持有并等待：线程持有资源并在等待其他资源\n\n+ 非抢占：线程获得锁不能被抢占\n+ 循环等待：线程之间存在一个环路，环路每个线程都持有一个资源，而这个资源是其他线程要申请的\n\n```java\npackage com.codefriday.DeadLock;\n\npublic class TestDeadLock {\n    public static void main(String[] args) {\n        GetAB getAB1 = new GetAB(0);\n        GetAB getAB2 = new GetAB(1);\n        new Thread(getAB1,\"线程1\").start();\n        new Thread(getAB2,\"线程2\").start();\n    }\n\n}\nclass A{\n\n}\nclass B{\n\n}\nclass GetAB implements Runnable{\n    private static A a = new A();\n    private static B b = new B();\n    private int flag;//标记拿A和B的顺序\n    GetAB(int flag){\n        this.flag = flag;\n    }\n    @Override\n    public void run() {\n        if(flag == 0){\n            synchronized (a){\n                System.out.println(Thread.currentThread().getName()+\"拿到了资源A\");\n            }\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            synchronized (b){\n                System.out.println(Thread.currentThread().getName()+\"拿到了资源B\");\n            }\n        }else {\n            synchronized (b){\n                System.out.println(Thread.currentThread().getName()+\"拿到了资源B\");\n            }\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            synchronized (a){\n                System.out.println(Thread.currentThread().getName()+\"拿到了资源A\");\n            }\n        }\n    }\n}\n```\n\n## Lock锁\n\n+ `JUC`中的Lock接口是控制多个线程对共享资源进行访问的工具。每次只能一个线程对Lock对象加锁，线程开始访问共享资源之前必须先获得Lock对象。\n\n+ `ReentrantLock`类实现了Lock（可重入的锁），可以显式的加锁，释放锁。\n\n显式加锁的同步计数器：\n\n```java\npackage com.codefriday.TestLock;\n\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class TestLock01 {\n    static int count;\n    private static final ReentrantLock lock = new ReentrantLock();\n    public static void main(String[] args) throws InterruptedException {\n        Thread t1 = new Thread(()->{\n            for (int i = 0; i < 10000; i++) {\n                try{\n                    TestLock01.lock.lock();\n                    TestLock01.count++;\n                }catch (Exception e){\n                    e.printStackTrace();\n                }finally {\n                    TestLock01.lock.unlock();\n                }\n\n            }\n        });\n        Thread t2 = new Thread(()->{\n            for (int i = 0; i < 10000; i++) {\n                try{\n                    TestLock01.lock.lock();\n                    TestLock01.count++;\n                }catch (Exception e){\n                    e.printStackTrace();\n                }finally {\n                    TestLock01.lock.unlock();\n                }\n\n            }\n        });\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        System.out.println(TestLock01.count);\n    }\n}\n\n```\n\n最后输出20000，不加锁时结果随机的错误！！！\n\n## 线程通信\n\nJava提供了几个方法解决线程之间通信的问题\n\n| 方法名             | 作用                                                         |\n| ------------------ | :----------------------------------------------------------- |\n| wait()             | 表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁    |\n| wait(long timeout) | 指定等待的毫秒数                                             |\n| notify             | 唤醒一个处于等待状态的线程                                   |\n| notifyAll()        | 唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度 |\n\n生产者/消费者问题！\n\n### 管程法解决\n\n实际实现同步的一个缓冲区，其中put方法和get方法使用synchronized代码块实现同步。\n\n```java\npackage com.codefriday.TestPC;\n\nimport java.util.LinkedList;\n\n//生产者/消费者问题\npublic class TestPC {\n\n    public static void main(String[] args) {\n        MyBuffer buffer = new MyBuffer();\n        new Producer(buffer).start();\n        new Producer(buffer).start();\n        new Consumer(buffer).start();\n    }\n}\nclass MyBuffer{\n    public static final int MAX_SIZE = 10;//缓冲区大小\n    public static LinkedList<Integer> buffer = new LinkedList<Integer>();\n    void put(){\n        synchronized(buffer){\n            if(buffer.size()==MAX_SIZE){\n                try {\n                    buffer.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            buffer.add(0);\n            System.out.println(Thread.currentThread().getName()+\"生产了，当前容量为\"+buffer.size());\n            buffer.notify();\n        }\n    }\n    void get(){\n        synchronized (buffer){\n            if(buffer.size()==0){\n                try {\n                    buffer.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            buffer.removeLast();\n            System.out.println(Thread.currentThread().getName()+\"消费了，当前容量为\"+buffer.size());\n            buffer.notify();\n        }\n    }\n    int size(){\n        return buffer.size();\n    }\n}\nclass Producer extends Thread{\n    MyBuffer buffer = null;\n\n    public Producer(MyBuffer buffer) {\n        this.buffer = buffer;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            buffer.put();\n\n        }\n    }\n}\nclass Consumer extends Thread{\n    MyBuffer buffer = null;\n\n    public Consumer(MyBuffer buffer) {\n        this.buffer = buffer;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            buffer.get();\n\n        }\n    }\n}\n```\n\n### 信号灯法\n\n用一个标志位\n\n![image-20210128200438789](多线程编程基础/image-20210128200438789.png)\n\n## 线程池\n\n+ 创建和销毁线程有时开销会很大。\n+ 提前创建好多个线程，放入线程池中，使用的时候直接获取，使用完放回线程池，可避免频繁创建和销毁，实现重复利用。\n\n```java\npackage com.codefriday;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class TestPool {\n    public static void main(String[] args) {\n        //创建一个线程池，参数为池子大小\n        ExecutorService pool = Executors.newFixedThreadPool(10);\n        //调用execute传入Runnable对象创建线程\n        pool.execute(new MyThread());\n        pool.execute(new MyThread());\n        pool.execute(new MyThread());\n        pool.execute(new MyThread());\n        //关闭线程池\n        pool.shutdownNow();\n    }\n}\nclass MyThread implements Runnable{\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName());\n    }\n}\n\n```\n\n## 总结\n\n![](多线程编程基础/多线程基础思维导图.jpg)","tags":["第一阶段"],"categories":["第一阶段"]},{"title":"网络编程","url":"/2021/01/27/网络编程/","content":"\n\n\n## 概述\n\n实际网络通信就是发送一个个的包（packet），发送一个包需要直到对方的信息对方的地址以及自己的地址。\n\n打电话 -- 链接 -- 接通 -- 通话---TCP\n\n发送短信 -- 发送就完事\t\t ---UDP\n\n**计算机网络定义**\n\n计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。\n\n**网络编程的目的**\n\n传播交流信息，数据交换。通信。\n\n**想要达到这个效果需要什么？**\n\n+ 如何准确定位网络上的一台主机：IP+端口，定位到这个计算机的某个资源\n+ 找到主机，如何传输数据？\n\nJavaWeb：网页编程  B/S 浏览器访问\n\n网络编程：TCP/IP C/S 客户端服务端\n\n## 网络通信的要素\n\n如何实现网络的通信？\n\n**通信双方地址：**\n\n+ IP\n+ 端口号\n\n**规则：网络通信协议**\n\nTCP/IP参考模型。\n\n![](网络编程/1.png)\n\n## IP\n\nIP地址类：InetAddress\n\n+ 唯一定位一台网络上的计算机\n+ 127.0.0.1：本机localhost\n\n+ IP地址分类\n  + ipv4/ipv6\n    + IPV4：127.0.0.1，四字节，0-255，42亿，2011年用尽\n    + IPV6：128位，8个无符号整数\n  + 公网（互联网）-私网（局域网）\n    + ABCD类地址\n    + 192.168.xx.xx，局域网地址  域名\n\n+ 域名：记忆IP问题！\n\n## 端口\n\n端口表示计算机上一个程序的进程\n\n+ 不同的进程有不同的端口号，用来区分软件\n\n+ 被规定0-65535\n\n+ TCP,UDP：65535*2，单个协议下端口号不能冲突\n\n+ 端口分类\n\n  + 公用端口：0-1023\n    + HTTP：80端口\n    + HTTPS：443端口\n    + FTP：21\n    + Telent：23\n\n  + 程序注册端口：1024-49151，分配给用户或者程序。\n    + Tomcat 8080\n    + MySQL：3306\n    + Oracle：1521\n\n  + 动态、私有：49152-65535\n\n    ```bash\n    # 查看所有的端口\n    netstat -ano\n    # 管道流，查看指定的端口\n    netstat -ano|findstr \"445\"\n    # 查看指定端口的进程\n    tasklist|findstr \"445\n    ```\n\n## 通信协议\n\n**网络通信协议：**速率，传输码率，代码结构，传输控制\n\n**TCP/IP协议簇**\n\n其中代表：\n\n+ TCP\n+ IP：网络互联协议 \n\n重要：\n\n+ TCP：用户传输协议\n+ UDP：用户数据报协议\n\n**TCP对比UDP**\n\nTCP：打电话\n\n + 连接，稳定\n\n + **三次握手，四次挥手**\n\n   ```\n   最少需要三次，保证稳定连接\n   A:你愁啥\n   B:瞅你咋地\n   A:干一场\n   \n   断开连接：\n   A:我要走了\n   B:你真的要走了吗\n   B:你真的要走了吗\n   A:我真的要走了\n   ```\n\n   ![img](网络编程/d8f9d72a6059252d20d93b0a6645fb3e59b5b9d2.jpeg)\n\n   ![img](网络编程/861fa058f2da35f8efa70b29bf7c45fd8689.gif)\n\n   ![](网络编程/48540923dd54564e5260495ce0006487d0584fb6.jpeg)\n\n + 客户端，服务端\n\n + 传输完成，释放连接\n\nUDP：发短信\n\n+ 不连接，不稳定\n+ 客户端、服务端：没有明确界限\n+ 不管有没有准备好，都可以发给你\n+ DDOS：洪水攻击！\n\n##  TCP\n\n### 实现聊天\n\n**服务端：**\n\n1.开启一个端口\n\n2.监听端口获得客户端socket\n\n3.从socket流读取信息\n\n```java\npackage com.codefriday.Demo02;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n//服务端\npublic class TestTCPServer {\n    public static void main(String[] args){\n        ServerSocket serverSocket = null;\n        Socket socket = null;\n        InputStream is = null;\n        ByteArrayOutputStream baos = null;\n        try {\n            //服务端开启一个端口以及IP\n            serverSocket = new ServerSocket(9999);\n            while(true){\n                //等待客户端连接，连接获取到socket\n                socket = serverSocket.accept();\n                //获取输出\n                is = socket.getInputStream();\n                baos = new ByteArrayOutputStream();\n                byte[] buffer = new byte[1024];\n                int len;\n                while((len=is.read(buffer))!=-1){\n                    baos.write(buffer,0,len);\n                }\n                System.out.println(baos.toString());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }finally {\n            if(baos!=null){\n                try {\n                    baos.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(is!=null){\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n\n            }\n            if(socket!=null){\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(serverSocket!=null){\n                try {\n                    serverSocket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n        }\n    }\n\n}\n\n\n```\n\n\n\n**客户端：**\n\n1.通过IP+端口建立连接\n\n2.发信\n\n```java\npackage com.codefriday.Demo02;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\n//客户端\npublic class TestTCPClient {\n    public static void main(String[] args) {\n        Socket socket = null;\n        OutputStream os = null;\n        try {\n            //服务端IP,端口号\n            InetAddress severIP = InetAddress.getByName(\"127.0.0.1\");\n            int port = 9999;\n            //创建连接\n            socket = new Socket(severIP, port);\n            os = socket.getOutputStream();\n            os.write(\"Hello world!\".getBytes());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }finally {\n            if(socket!=null){\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(os!=null){\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n\n```\n\n## UDP\n\n**测试单次发送消息**\n\n发送端：\n\n```java\npackage com.codefriday.Demo03;\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class TestUDPClient {\n    public static void main(String[] args) throws Exception{\n        //建立socket\n        DatagramSocket socket = new DatagramSocket();\n        //建立一个包\n        String msg = \"服务器你好！\";\n        InetAddress inetAddress = InetAddress.getByName(\"127.0.0.1\");\n        int port = 9999;\n        DatagramPacket packet = new DatagramPacket(msg.getBytes(),0,msg.getBytes().length,inetAddress,port);\n        //发送包\n        socket.send(packet);\n        //关闭流\n        socket.close();\n    }\n}\n\n```\n\n接受端\n\n```java\npackage com.codefriday.Demo03;\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class TestUDPServer {\n    public static void main(String[] args) throws Exception{\n        //开放端口\n        DatagramSocket socket = new DatagramSocket(9999);\n        //接受数据包\n        byte[] buffer = new byte[1024];\n        DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length);\n        socket.receive(packet);\n        System.out.println(new String(packet.getData(),0,packet.getData().length));\n        socket.close();\n    }\n}\n\n```\n\n测试循环发送消息\n\n发送方：\n\n```java\npackage com.codefriday.chat;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class UDPSender {\n    public static void main(String[] args) throws Exception{\n        //建立连接\n        DatagramSocket socket = new DatagramSocket(6666);\n        //准备数据\n        while(true){\n            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n            String data = reader.readLine();\n            DatagramPacket packet = new DatagramPacket(data.getBytes(),0,data.getBytes().length, InetAddress.getByName(\"127.0.0.1\"),9999);\n            socket.send(packet);\n            if(data.equals(\"bye\")){\n                break;\n            }\n        }\n        socket.close();\n\n    }\n}\n\n```\n\n```接收方\npackage com.codefriday.chat;\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\npublic class UDPReceiver {\n    public static void main(String[] args) throws Exception{\n        DatagramSocket socket = new DatagramSocket(9999);\n        while(true){\n            byte[] buffer = new byte[1024];\n            DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length);\n            socket.receive(packet);\n            byte[] data = packet.getData();\n            String msg = new String(data,0,data.length);\n            System.out.println(msg);\n            if(msg.equals(\"bye\")){\n                break;\n            }\n        }\n        socket.close();\n    }\n}\n\n```\n\n## 多线程聊天\n\n将消息发送打包成一个线程\n\n将消息接收打包成一个线程\n\n两个程序同时开接受消息和发送消息的线程，端口对应上即可实现实时聊天\n\n消息发送线程：\n\n```java\npackage com.codefriday.chat;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\n\npublic class TalkSend implements Runnable{\n    DatagramSocket socket = null;\n    BufferedReader reader = null;\n    private int fromPort;\n    private String toIP;\n    private int toPort;\n\n    public TalkSend(int fromPort, String toIP, int toPort) {\n        this.fromPort = fromPort;\n        this.toIP = toIP;\n        this.toPort = toPort;\n        try{\n            socket = new DatagramSocket(fromPort);\n            reader = new BufferedReader(new InputStreamReader(System.in));\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n\n    }\n\n    @Override\n    public void run() {\n        try{\n            while(true){\n                String data = reader.readLine();\n                DatagramPacket packet = new DatagramPacket(data.getBytes(),0,data.getBytes().length, InetAddress.getByName(toIP),toPort);\n                socket.send(packet);\n                if(data.equals(\"bye\")){\n                    break;\n                }\n            }\n            socket.close();\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n\n    }\n\n}\n\n```\n\n消息接收线程\n\n```java\npackage com.codefriday.chat;\n\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.PortUnreachableException;\nimport java.net.SocketException;\n\npublic class TalkReceive implements Runnable{\n    private String msgFrom;\n    private int toPort;\n    DatagramSocket socket = null;\n    byte[] buffer = null;\n\n    public TalkReceive(int toPort,String msgFrom) {\n        this.msgFrom = msgFrom;\n        this.toPort = toPort;\n        buffer = new byte[1024];\n        try {\n            socket = new DatagramSocket(toPort);\n        } catch (SocketException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void run() {\n        try{\n            while(true){\n                DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length);\n                socket.receive(packet);\n                byte[] data = packet.getData();\n                String msg = new String(data,0,data.length);\n                System.out.println(msgFrom+\":\"+msg);\n                if(msg.equals(\"bye\")){\n                    break;\n                }\n            }\n            socket.close();\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n\n    }\n}\n\n```\n\n模拟老师和学生开的线程：\n\n```java\npackage com.codefriday.chat;\n\npublic class TalkTeacher {\n    public static void main(String[] args) {\n        new Thread(new TalkSend(5555,\"127.0.0.1\",9999)).start();\n        new Thread(new TalkReceive(6666,\"student\")).start();\n    }\n}\n\n\n\npackage com.codefriday.chat;\n\npublic class TalkStudent {\n    public static void main(String[] args) {\n        new Thread(new TalkSend(7777,\"127.0.0.1\",6666)).start();\n        new Thread(new TalkReceive(9999,\"teacher\")).start();\n    }\n}\n\n```\n\ncmd运行测试如下：\n![](网络编程/image-20210127213812966.png)\n\n## URL\n\n统一资源定位符\n\n协议+IP+项目+具体资源\n\n下载网络资源实例：\n\n```java\npackage com.codefriday.Demo04;\n\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\npublic class TestURL {\n    public static void main(String[] args) throws Exception {\n        URL url = new URL(\"https://codefriday.oss-cn-beijing.aliyuncs.com/author.jpg\");\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        InputStream is = urlConnection.getInputStream();\n        FileOutputStream fos = new FileOutputStream(\"test.jpg\");\n        byte[] buffer = new byte[1024];\n        int len;\n        while((len=is.read(buffer))!=-1){\n            fos.write(buffer,0,len);\n        }\n        fos.close();\n        is.close();\n        urlConnection.disconnect();\n    }\n}\n\n```\n\n![image-20210128104054784](网络编程/image-20210128104054784.png)","tags":["第一阶段"],"categories":["第一阶段"]},{"title":"IO","url":"/2021/01/17/IO/","content":"\n## IO是什么\n\nIO是指Input/Output，即输入和输出。以内存为中心：\n\n- Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。\n- Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。\n\n因为代码是在内存中运行的，数据也必须读到内存，最终的表示方式无非是byte数组，字符串等，都必须存放在内存里。\n\nIO流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为IO流。\n\n+ ### InputStream / OutputStream\n\nIO流以`byte`（字节）为最小单位，因此也称为字节流。\n\n在Java中，`InputStream`代表输入字节流，`OuputStream`代表输出字节流，这是最基本的两种IO流。\n\n+ ### Reader / Writer\n\n如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照`char`来读写显然更方便，这种流称为*字符流*。\n\nJava提供了`Reader`和`Writer`表示字符流，字符流传输的最小数据单位是`char`。\n\n`Reader`和`Writer`本质上是一个能自动编解码的`InputStream`和`OutputStream`。\n\n使用`Reader`，数据源虽然是字节，但我们读入的数据都是`char`类型的字符，原因是`Reader`内部把读入的`byte`做了解码，转换成了`char`。使用`InputStream`，我们读入的数据和原始二进制数据一模一样，是`byte[]`数组，但是我们可以自己把二进制`byte[]`数组按照某种编码转换为字符串。究竟使用`Reader`还是`InputStream`，要取决于具体的使用场景。如果数据源不是文本，就只能使用`InputStream`，如果数据源是文本，使用Reader更方便一些。`Writer`和`OutputStream`是类似的。\n\n+ ### 同步和异步\n\n同步IO是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。\n\n而异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。\n\nJava标准库的包`java.io`提供了同步IO，而`java.nio`则是异步IO。上面我们讨论的`InputStream`、`OutputStream`、`Reader`和`Writer`都是同步IO的抽象类，对应的具体实现类，以文件为例，有`FileInputStream`、`FileOutputStream`、`FileReader`和`FileWriter`。\n\n## File对象\n\n在计算机系统中，文件是非常重要的存储方式。Java的标准库`java.io`提供了`File`对象来操作文件和目录。\n\n要构造一个`File`对象，需要传入文件路径。\n\n注意Windows平台使用`\\`作为路径分隔符，在Java字符串中需要用`\\\\`表示一个`\\`。Linux平台使用`/`作为路径分隔符。\n\n可以用`.`表示当前目录，`..`表示上级目录。\n\n传入相对路径时，相对路径前面加上当前目录就是绝对路径。\n\n**File对象有3种形式表示的路径**\n\n+ `getPath()`\n\n  返回构造方法传入的路径\n\n+ `getAbsolutePath()`\n\n  返回绝对路径\n\n+ `getCanonicalPath`\n\n  它和绝对路径类似，但是返回的是规范路径\n\n### 文件和目录\n\n`File`对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个`File`对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个`File`对象，并不会导致任何磁盘操作。只有当我们调用`File`对象的某些方法的时候，才真正进行磁盘操作。\n\n例如，调用`isFile()`，判断该`File`对象是否是一个已存在的文件，调用`isDirectory()`，判断该`File`对象是否是一个已存在的目录。\n\n用`File`对象获取到一个文件时，还可以进一步判断文件的权限和大小：\n\n- `boolean canRead()`：是否可读；\n- `boolean canWrite()`：是否可写；\n- `boolean canExecute()`：是否可执行；\n- `long length()`：文件字节大小。\n\n### 创建和删除文件\n\n当File对象表示一个文件时，可以通过`createNewFile()`创建一个新文件，用`delete()`删除该文件。\n\n有些时候，程序需要读写一些临时文件，File对象提供了`createTempFile()`来创建一个临时文件，以及`deleteOnExit()`在JVM退出时自动删除该文件。\n\n### 遍历文件和目录\n\n当File对象表示一个目录时，可以使用`list()`和`listFiles()`列出目录下的文件和子目录名。`listFiles()`提供了一系列重载方法，可以过滤不想要的文件和目录。\n\n和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：\n\n- `boolean mkdir()`：创建当前File对象表示的目录；\n- `boolean mkdirs()`：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；\n- `boolean delete()`：删除当前File对象表示的目录，当前目录必须为空才能删除成功。\n\n### Path\n\nJava标准库还提供了一个`Path`对象，它位于`java.nio.file`包。`Path`对象和`File`对象类似，但操作更加简单：\n\n```java\nimport java.io.*;\nimport java.nio.file.*;\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Path p1 = Paths.get(\".\", \"project\", \"study\"); // 构造一个Path对象\n        System.out.println(p1);\n        Path p2 = p1.toAbsolutePath(); // 转换为绝对路径\n        System.out.println(p2);\n        Path p3 = p2.normalize(); // 转换为规范路径\n        System.out.println(p3);\n        File f = p3.toFile(); // 转换为File对象\n        System.out.println(f);\n        for (Path p : Paths.get(\"..\").toAbsolutePath()) { // 可以直接遍历Path\n            System.out.println(\"  \" + p);\n        }\n    }\n}\n\n```\n\n## InputStream\n\n`InputStream`就是Java标准库提供的最基本的输入流。它位于`java.io`这个包里。`java.io`包提供了所有同步IO的功能。\n\n要特别注意的一点是，`InputStream`并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是`int read()`，签名如下：\n\n```\npublic abstract int read() throws IOException;\n```\n\n这个方法会读取输入流的下一个字节，并返回字节表示的`int`值（0~255）。如果已读到末尾，返回`-1`表示不能继续读取了。\n\n`InputStream`和`OutputStream`都是通过`close()`方法来关闭流。关闭流就会释放对应的底层资源。\n\n我们还要注意到在读取或写入IO流的过程中，可能会发生错误，例如，文件不存在导致无法读取，没有写权限导致写入失败，等等，这些底层错误由Java虚拟机自动封装成`IOException`异常并抛出。因此，所有与IO操作相关的代码都必须正确处理`IOException`。\n\n潜在的问题：如果读取过程中发生了IO错误，`InputStream`就没法正确地关闭，资源也就没法及时释放。\n\n因此，我们需要用`try ... finally`来保证`InputStream`在无论是否发生IO错误的时候都能够正确地关闭。\n\n### 缓冲\n\n在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。`InputStream`提供了两个重载方法来支持读取多个字节：\n\n- `int read(byte[] b)`：读取若干字节并填充到`byte[]`数组，返回读取的字节数\n- `int read(byte[] b, int off, int len)`：指定`byte[]`数组的偏移量和最大填充数\n\n利用上述方法一次读取多个字节时，需要先定义一个`byte[]`数组作为缓冲区，`read()`方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。`read()`方法的返回值不再是字节的`int`值，而是返回实际读取了多少个字节。如果返回`-1`，表示没有更多的数据了。\n\n### 阻塞\n\n在调用`InputStream`的`read()`方法读取数据时，我们说`read()`方法是阻塞（Blocking）的。它的意思是要等待`read`调用返回才会继续执行。\n\n### InputStream实现类\n\n用`FileInputStream`可以从文件获取输入流，这是`InputStream`常用的一个实现类。此外，`ByteArrayInputStream`可以在内存中模拟一个`InputStream`。\n\n## OutputStream\n\n和`InputStream`相反，`OutputStream`是Java标准库提供的最基本的输出流。\n\n和`InputStream`类似，`OutputStream`也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是`void write(int b)`，签名如下：\n\n```\npublic abstract void write(int b) throws IOException;\n```\n\n这个方法会写入一个字节到输出流。要注意的是，虽然传入的是`int`参数，但只会写入一个字节，即只写入`int`最低8位表示字节的部分（相当于`b & 0xff`）。\n\n和`InputStream`类似，`OutputStream`也提供了`close()`方法关闭输出流，以便释放系统资源。要特别注意：`OutputStream`还提供了一个`flush()`方法，它的目的是将缓冲区的内容真正输出到目的地。\n\n为什么要有`flush()`？因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个`byte[]`数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以`OutputStream`有个`flush()`方法，能强制把缓冲区内容输出。\n\n通常情况下，我们不需要调用这个`flush()`方法，因为缓冲区写满了`OutputStream`会自动调用它，并且，在调用`close()`方法关闭`OutputStream`之前，也会自动调用`flush()`方法。\n\n### FileOutputStream\n\n每次写入一个字节非常麻烦，更常见的方法是一次性写入若干字节。这时，可以用`OutputStream`提供的重载方法`void write(byte[])`来实现：\n\n```\npublic void writeFile() throws IOException {\n    OutputStream output = new FileOutputStream(\"out/readme.txt\");\n    output.write(\"Hello\".getBytes(\"UTF-8\")); // Hello\n    output.close();\n}\n```\n\n和`InputStream`一样，上述代码没有考虑到在发生异常的情况下如何正确地关闭资源。写入过程也会经常发生IO错误，例如，磁盘已满，无权限写入等等。我们需要用`try(resource)`来保证`OutputStream`在无论是否发生IO错误的时候都能够正确地关闭：\n\n```java\npublic void writeFile() throws IOException {\n    try (OutputStream output = new FileOutputStream(\"out/readme.txt\")) {\n        output.write(\"Hello\".getBytes(\"UTF-8\")); // Hello\n    } // 编译器在此自动为我们写入finally并调用close()\n}\n```\n\n### 阻塞\n\n和`InputStream`一样，`OutputStream`的`write()`方法也是阻塞的。\n\n### OutputStream实现类\n\n用`FileOutputStream`可以从文件获取输出流，这是`OutputStream`常用的一个实现类。\n\n`ByteArrayOutputStream`实际上是把一个`byte[]`数组在内存中变成一个`OutputStream`，虽然实际应用不多，但测试的时候，可以用它来构造一个`OutputStream`。\n\n## Filter模式\n\n直接使用继承，为各种`InputStream`附加更多的功能，根本无法控制代码的复杂度，很快就会失控。\n\n为了解决依赖继承会导致子类数量失控的问题，JDK首先将`InputStream`分为两大类：\n\n一类是直接提供数据的基础`InputStream`，例如：\n\n- FileInputStream\n- ByteArrayInputStream\n- ServletInputStream\n- ...\n\n一类是提供额外附加功能的`InputStream`，例如：\n\n- BufferedInputStream\n- DigestInputStream\n- CipherInputStream\n- ...\n\n当我们需要给一个“基础”`InputStream`附加各种功能时，我们先确定这个能提供数据源的`InputStream`，因为我们需要的数据总得来自某个地方，例如，`FileInputStream`，数据来源自文件：\n\n```\nInputStream file = new FileInputStream(\"test.gz\");\n```\n\n紧接着，我们希望`FileInputStream`能提供缓冲的功能来提高读取的效率，因此我们用`BufferedInputStream`包装这个`InputStream`，得到的包装类型是`BufferedInputStream`，但它仍然被视为一个`InputStream`：\n\n```\nInputStream buffered = new BufferedInputStream(file);\n```\n\n最后，假设该文件已经用gzip压缩了，我们希望直接读取解压缩的内容，就可以再包装一个`GZIPInputStream`：\n\n```\nInputStream gzip = new GZIPInputStream(buffered);\n```\n\n无论我们包装多少次，得到的对象始终是`InputStream`，我们直接用`InputStream`来引用它，就可以正常读取。\n\n## 操作Zip\n\n`ZipInputStream`是一种`FilterInputStream`，它可以直接读取zip包的内容：\n\n```ascii\n┌───────────────────┐\n│    InputStream    │\n└───────────────────┘\n          ▲\n          │\n┌───────────────────┐\n│ FilterInputStream │\n└───────────────────┘\n          ▲\n          │\n┌───────────────────┐\n│InflaterInputStream│\n└───────────────────┘\n          ▲\n          │\n┌───────────────────┐\n│  ZipInputStream   │\n└───────────────────┘\n          ▲\n          │\n┌───────────────────┐\n│  JarInputStream   │\n└───────────────────┘\n```\n\n另一个`JarInputStream`是从`ZipInputStream`派生，它增加的主要功能是直接读取jar文件里面的`MANIFEST.MF`文件。因为本质上jar包就是zip包，只是额外附加了一些固定的描述文件。\n\n### 读取zip包\n\n我们来看看`ZipInputStream`的基本用法。\n\n我们要创建一个`ZipInputStream`，通常是传入一个`FileInputStream`作为数据源，然后，循环调用`getNextEntry()`，直到返回`null`，表示zip流结束。\n\n一个`ZipEntry`表示一个压缩文件或目录，如果是压缩文件，我们就用`read()`方法不断读取，直到返回`-1`：\n\n```\ntry (ZipInputStream zip = new ZipInputStream(new FileInputStream(...))) {\n    ZipEntry entry = null;\n    while ((entry = zip.getNextEntry()) != null) {\n        String name = entry.getName();\n        if (!entry.isDirectory()) {\n            int n;\n            while ((n = zip.read()) != -1) {\n                ...\n            }\n        }\n    }\n}\n```\n\n### 写入zip包\n\n`ZipOutputStream`是一种`FilterOutputStream`，它可以直接写入内容到zip包。我们要先创建一个`ZipOutputStream`，通常是包装一个`FileOutputStream`，然后，每写入一个文件前，先调用`putNextEntry()`，然后用`write()`写入`byte[]`数据，写入完毕后调用`closeEntry()`结束这个文件的打包。\n\n```\ntry (ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(...))) {\n    File[] files = ...\n    for (File file : files) {\n        zip.putNextEntry(new ZipEntry(file.getName()));\n        zip.write(getFileDataAsBytes(file));\n        zip.closeEntry();\n    }\n}\n```\n\n上面的代码没有考虑文件的目录结构。如果要实现目录层次结构，`new ZipEntry(name)`传入的`name`要用相对路径。\n\n## 读取classpath资源\n\n从磁盘的固定目录读取配置文件，不是一个好的办法。\n\n有没有路径无关的读取文件的方式呢？\n\n从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把`default.properties`文件放到classpath中，就不用关心它的实际存放路径。\n\n在classpath中的资源文件，路径总是以`／`开头，我们先获取当前的`Class`对象，然后调用`getResourceAsStream()`就可以直接从classpath读取任意的资源文件：\n\n```\ntry (InputStream input = getClass().getResourceAsStream(\"/default.properties\")) {\n    // TODO:\n}\n```\n\n## 序列化\n\n序列化是指把一个Java对象变成二进制内容，本质上就是一个`byte[]`数组。\n\n为什么要把Java对象序列化呢？因为序列化后可以把`byte[]`保存到文件中，或者把`byte[]`通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。\n\n有序列化，就有反序列化，即把一个二进制内容（也就是`byte[]`数组）变回Java对象。有了反序列化，保存到文件中的`byte[]`数组又可以“变回”Java对象，或者从网络上读取`byte[]`并把它“变回”Java对象。\n\n我们来看看如何把一个Java对象序列化。\n\n一个Java对象要能序列化，必须实现一个特殊的`java.io.Serializable`接口，它的定义如下：\n\n```\npublic interface Serializable {\n}\n```\n\n`Serializable`接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。\n\n### 序列化\n\n把一个Java对象变为`byte[]`数组，需要使用`ObjectOutputStream`。它负责把一个Java对象写入一个字节流：\n\n```java\nimport java.io.*;\nimport java.util.Arrays;\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        try (ObjectOutputStream output = new ObjectOutputStream(buffer)) {\n            // 写入int:\n            output.writeInt(12345);\n            // 写入String:\n            output.writeUTF(\"Hello\");\n            // 写入Object:\n            output.writeObject(Double.valueOf(123.456));\n        }\n        System.out.println(Arrays.toString(buffer.toByteArray()));\n    }\n}\n\n```\n\n`ObjectOutputStream`既可以写入基本类型，如`int`，`boolean`，也可以写入`String`（以UTF-8编码），还可以写入实现了`Serializable`接口的`Object`。\n\n因为写入`Object`时需要大量的类型信息，所以写入的内容很大。\n\n### 反序列化\n\n和`ObjectOutputStream`相反，`ObjectInputStream`负责从一个字节流读取Java对象：\n\n```\ntry (ObjectInputStream input = new ObjectInputStream(...)) {\n    int n = input.readInt();\n    String s = input.readUTF();\n    Double d = (Double) input.readObject();\n}\n```\n\n除了能读取基本类型和`String`类型外，调用`readObject()`可以直接返回一个`Object`对象。要把它变成一个特定类型，必须强制转型。\n\n`readObject()`可能抛出的异常有：\n\n- `ClassNotFoundException`：没有找到对应的Class；\n- `InvalidClassException`：Class不匹配。\n\n对于`ClassNotFoundException`，这种情况常见于一台电脑上的Java程序把一个Java对象，例如，`Person`对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有定义`Person`类，所以无法反序列化。\n\n对于`InvalidClassException`，这种情况常见于序列化的`Person`对象定义了一个`int`类型的`age`字段，但是反序列化时，`Person`类定义的`age`字段被改成了`long`类型，所以导致class不兼容。\n\n为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的`serialVersionUID`静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变`serialVersionUID`的值，这样就能自动阻止不匹配的class版本.\n\n## Reader\n\n`Reader`是Java的IO库提供的另一个输入流接口。和`InputStream`的区别是，`InputStream`是一个字节流，即以`byte`为单位读取，而`Reader`是一个字符流，即以`char`为单位读取：\n\n| InputStream                         | Reader                                |\n| :---------------------------------- | :------------------------------------ |\n| 字节流，以`byte`为单位              | 字符流，以`char`为单位                |\n| 读取字节（-1，0~255）：`int read()` | 读取字符（-1，0~65535）：`int read()` |\n| 读到字节数组：`int read(byte[] b)`  | 读到字符数组：`int read(char[] c)`    |\n\n### FileReader\n\n`FileReader`是`Reader`的一个子类，它可以打开文件并获取`Reader`。\n\n如果我们读取一个纯ASCII编码的文本文件，上述代码工作是没有问题的。但如果文件中包含中文，就会出现乱码，因为`FileReader`默认的编码与系统相关，例如，Windows系统的默认编码可能是`GBK`，打开一个`UTF-8`编码的文本文件就会出现乱码。\n\n要避免乱码问题，我们需要在创建`FileReader`时指定编码：\n\n```java\nReader reader = new FileReader(\"src/readme.txt\", StandardCharsets.UTF_8);\n```\n\n`Reader`还提供了一次性读取若干字符并填充到`char[]`数组的方法：\n\n```\npublic int read(char[] c) throws IOException\n```\n\n它返回实际读入的字符个数，最大不超过`char[]`数组的长度。返回`-1`表示流结束。\n\n利用这个方法，我们可以先设置一个缓冲区，然后，每次尽可能地填充缓冲区。\n\n### CharArrayReader\n\n`CharArrayReader`可以在内存中模拟一个`Reader`，它的作用实际上是把一个`char[]`数组变成一个`Reader`，这和`ByteArrayInputStream`非常类似。\n\n### StringReader\n\n`StringReader`可直接把`String`作为数据源，它和`CharArrayReader`几乎一样：\n\n```java\ntry (Reader reader = new StringReader(\"Hello\")) {\n}\n```\n\n### InputStreamReader\n\n`Reader`和`InputStream`有什么关系？\n\n除了特殊的`CharArrayReader`和`StringReader`，普通的`Reader`实际上是基于`InputStream`构造的，因为`Reader`需要从`InputStream`中读入字节流（`byte`），然后，根据编码设置，再转换为`char`就可以实现字符流。如果我们查看`FileReader`的源码，它在内部实际上持有一个`FileInputStream`。\n\n既然`Reader`本质上是一个基于`InputStream`的`byte`到`char`的转换器，那么，如果我们已经有一个`InputStream`，想把它转换为`Reader`，是完全可行的。`InputStreamReader`就是这样一个转换器，它可以把任何`InputStream`转换为`Reader`\n\n构造`InputStreamReader`时，我们需要传入`InputStream`，还需要指定编码，就可以得到一个`Reader`对象。上述代码可以通过`try (resource)`更简洁地改写如下：\n\n```\ntry (Reader reader = new InputStreamReader(new FileInputStream(\"src/readme.txt\"), \"UTF-8\")) {\n    // TODO:\n}\n```\n\n上述代码实际上就是`FileReader`的一种实现方式。\n\n使用`try (resource)`结构时，当我们关闭`Reader`时，它会在内部自动调用`InputStream`的`close()`方法，所以，只需要关闭最外层的`Reader`对象即可。\n\n## Writer\n\n`Reader`是带编码转换器的`InputStream`，它把`byte`转换为`char`，而`Writer`就是带编码转换器的`OutputStream`，它把`char`转换为`byte`并输出。\n\n`Writer`和`OutputStream`的区别如下：\n\n| OutputStream                           | Writer                                   |\n| :------------------------------------- | :--------------------------------------- |\n| 字节流，以`byte`为单位                 | 字符流，以`char`为单位                   |\n| 写入字节（0~255）：`void write(int b)` | 写入字符（0~65535）：`void write(int c)` |\n| 写入字节数组：`void write(byte[] b)`   | 写入字符数组：`void write(char[] c)`     |\n| 无对应方法                             | 写入String：`void write(String s)`       |\n\n`Writer`是所有字符输出流的超类，它提供的方法主要有：\n\n- 写入一个字符（0~65535）：`void write(int c)`；\n- 写入字符数组的所有字符：`void write(char[] c)`；\n- 写入String表示的所有字符：`void write(String s)`。\n\n### FileWriter\n\n`FileWriter`就是向文件中写入字符流的`Writer`。它的使用方法和`FileReader`类似\n\n### CharArrayWriter\n\n`CharArrayWriter`可以在内存中创建一个`Writer`，它的作用实际上是构造一个缓冲区，可以写入`char`，最后得到写入的`char[]`数组，这和`ByteArrayOutputStream`非常类似\n\n### StringWriter\n\n`StringWriter`也是一个基于内存的`Writer`，它和`CharArrayWriter`类似。实际上，`StringWriter`在内部维护了一个`StringBuffer`，并对外提供了`Writer`接口。\n\n### OutputStreamWriter\n\n除了`CharArrayWriter`和`StringWriter`外，普通的Writer实际上是基于`OutputStream`构造的，它接收`char`，然后在内部自动转换成一个或多个`byte`，并写入`OutputStream`。因此，`OutputStreamWriter`就是一个将任意的`OutputStream`转换为`Writer`的转换器。\n\n## PrintStream和PrintWriter\n\n`PrintStream`是一种`FilterOutputStream`，它在`OutputStream`的接口上，额外提供了一些写入各种数据类型的方法：\n\n- 写入`int`：`print(int)`\n- 写入`boolean`：`print(boolean)`\n- 写入`String`：`print(String)`\n- 写入`Object`：`print(Object)`，实际上相当于`print(object.toString())`\n- ...\n\n以及对应的一组`println()`方法，它会自动加上换行符。\n\n我们经常使用的`System.out.println()`实际上就是使用`PrintStream`打印各种数据。其中，`System.out`是系统默认提供的`PrintStream`，表示标准输出：\n\n```\nSystem.out.print(12345); // 输出12345\nSystem.out.print(new Object()); // 输出类似java.lang.Object@3c7a835a\nSystem.out.println(\"Hello\"); // 输出Hello并换行\n```\n\n`System.err`是系统默认提供的标准错误输出。\n\n`PrintStream`和`OutputStream`相比，除了添加了一组`print()`/`println()`方法，可以打印各种数据类型，比较方便外，它还有一个额外的优点，就是不会抛出`IOException`，这样我们在编写代码的时候，就不必捕获`IOException`。\n\n### PrintWriter\n\n`PrintStream`最终输出的总是byte数据，而`PrintWriter`则是扩展了`Writer`接口，它的`print()`/`println()`方法最终输出的是`char`数据。","tags":["第一阶段"],"categories":["第一阶段"]},{"title":"GUI实战-贪吃蛇小游戏","url":"/2021/01/04/GUI实战-贪吃蛇小游戏/","content":"\n## 前言\n\n之前做过安卓开发实现一个登陆注册界面的东西，完后过了一遍GUI基础知识，模仿别人敲了一个贪食蛇游戏。\n\n主启动类做的事很简单，`new`一个`JFrame`对象，位于`swing`下，然后设置窗口标题，位置，大小，可见性，不可拉伸，以及添加默认的关闭操作。然后把游戏面板添加到窗口中。区别于`AWT`中的`Frame`其实`JFrame`就是实现了更多方法来供使用。\n\n## 主启动类\n\n源码如下：\n\n```java\npackage com.codefriday.snake;\n/**\n * 游戏主启动类\n * by：codefriday\n */\nimport javax.swing.*;\n\npublic class StartGame {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"贪吃蛇小游戏-codefriday\");\n        //加入游戏面板\n        frame.add(new GamePanel());\n\n        //设置窗口参数\n        frame.setBounds(10,10,915,720);\n        frame.setResizable(false);\n        frame.setVisible(true);\n        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n    }\n}\n```\n\n实际看到的效果：\n\n![](GUI实战-贪吃蛇小游戏/1.png)\n\n## 游戏面板类\n\n用到的图片素材：\n\n![](GUI实战-贪吃蛇小游戏/2.png)\n\n设计思路：定义一个蛇其实就是由若干连起来的正方形块组合起来的。其中每个图片素材大小是25*25像素。因此绘制游戏面板时计算好宽度和高度保证为25的倍数。然后用一个数组保存这个蛇没一个元素的坐标。再用定时器控制页面的刷新，此时小蛇就能动起来了。\n\n然后再加上判定系统以及积分系统，最后整个游戏就完成了。\n\n首先，自己定义一个游戏面板类，为了避免代码冗余，直接继承`swing`包下的`JPanel`类，然后需要实现键盘交互，即上下左右控制小蛇移动，以及空格键控制游戏启停。\n\n### 面板初始化\n\n面板其实就分两块，第一块即头部logo以及显示积分。然后下面绘制一个大小为850*600的矩形当作小蛇可以移动的背景。\n\n由之前一个元素大小25*25可推算此处最多可容纳34\\*24个元素。\n\n由于需要用到图片素材，因此写一个数据中心类。取得图片路径后全部封装成`ImageIcon`就可直接调用其中的`paintIcon`方法直接绘制出图片。\n\n### 数据中心类\n\n```java\npackage com.codefriday.snake;\n\nimport javax.swing.*;\nimport java.net.URL;\n\npublic class Data {\n    public static URL headerURL = Data.class.getResource(\"statics/header.png\");\n    public static ImageIcon header = new ImageIcon(headerURL);\n\n    public static URL bodyURL = Data.class.getResource(\"statics/body.png\");\n    public static ImageIcon body = new ImageIcon(bodyURL);\n\n    public static URL foodURL = Data.class.getResource(\"statics/food.png\");\n    public static ImageIcon food = new ImageIcon(foodURL);\n\n    public static URL upURL = Data.class.getResource(\"statics/up.png\");\n    public static ImageIcon up = new ImageIcon(upURL);\n\n    public static URL downURL = Data.class.getResource(\"statics/down.png\");\n    public static ImageIcon down = new ImageIcon(downURL);\n\n    public static URL leftURL = Data.class.getResource(\"statics/left.png\");\n    public static ImageIcon left = new ImageIcon(leftURL);\n\n    public static URL rightURL = Data.class.getResource(\"statics/right.png\");\n    public static ImageIcon right = new ImageIcon(rightURL);\n}\n\n```\n\n### 绘制静态面板\n\n直接重写了继承的`JPanel`类中`paintComponent`方法\n\n代码如下：\n\n```java\n \t\tsuper.paintComponent(g);//清屏\n        //画游戏静态面板\n        this.setBackground(Color.white);\n        Data.header.paintIcon(this,g,25,11);\n        g.fillRect(25,75,850,600);\n```\n\n此时看到的效果应该是上面一个logo，下面一个黑色矩形。\n\n### 初始化一条小蛇\n\n用来存蛇的数据结构：\n\n```java\n\t//存每一节蛇的坐标\n    int DataX[] = new int[820];\n    int DataY[] = new int[820];\n\tint length;//蛇的长度\n```\n\n初始化时：\n\n```java\n\tlength = 3;\n\tDataX[0] = 100; DataY[0] = 100;\n    DataX[1] = 75; DataY[1] = 100;\n    DataX[2] = 50; DataY[2] = 100;\n\n```\n\n默认长度为3的一条小蛇就出现了。\n\n需要用到其他一些属性：\n\n```java\n\tboolean IsStart;//游戏状态，默认false，未开始\n    boolean IsOver;//是否失败\n    int length;//蛇的长度\n    int fx;//蛇的方向，↑0 →1 ↓2 ←3\n    int FoodX,FoodY;//食物位置\n    int score;//得分\n    Random random = new Random();\n    Timer timer = new Timer(200,this);\n```\n\n### 实现`KeyListener`接口\n\n必须重写三个方法，但实际只用到一个，因此重写如下：\n\n主要监听按下上下左右改变蛇头的方向，以及空格控制重开或者暂停继续游戏。\n\n这里改变方向的判断逻辑，蛇头方向不能一次改变超过90°，比如开始朝上，按`↓`时不生效。\n\n具体实现代码如下：\n\n```\nint fx;//蛇的方向，↑0 →1 ↓2 ←3\nboolean IsStart;//游戏状态，默认false，未开始\nboolean IsOver;//是否失败\n```\n\n```java\n//键盘监听事件接口中的方法\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int keyCode = e.getKeyCode();\n        switch (keyCode){\n            case KeyEvent.VK_SPACE:\n                if(IsOver){\n                    init();\n                }else {\n                    IsStart = !IsStart;\n                }\n                repaint();\n                break;\n            case KeyEvent.VK_UP:\n                if(IsStart){\n                    fx = (fx==2?fx:0);\n                }\n                break;\n            case KeyEvent.VK_DOWN:\n                if(IsStart){\n                    fx = (fx==0?fx:2);\n                }\n                break;\n            case KeyEvent.VK_LEFT:\n                if(IsStart){\n                    fx = (fx==1?fx:3);\n                }\n                break;\n            case KeyEvent.VK_RIGHT:\n                if(IsStart){\n                    fx = (fx==3?fx:1);\n                }\n                break;\n        }\n\n    }\n    @Override\n    public void keyTyped(KeyEvent e) {\n\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n\n    }\n```\n\n### 事件监听\n\n事件监听本质就是每隔固定时间会刷新一次。因此实现`ActionListener`接口，其中只有一个`actionPerformed`方法，把小蛇移动以及结果判定，计分都写在其中，配合定时器，调用`repaint`方法重画，就实现动画了。\n\n代码如下：\n\n```java\n//事件监听----通过固定时间刷新\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        if(IsStart){\n            if(FoodX == DataX[0] && FoodY == DataY[0]){//吃食物\n                length++;\n                score += 10;\n                //重新生成食物\n                FoodX = 25 + 25*(random.nextInt(34));\n                FoodY = 75 + 25*(random.nextInt(24));\n            }\n            for(int i = length-1;i>0;i--){\n                DataX[i] = DataX[i-1];\n                DataY[i] = DataY[i-1];\n            }\n            switch (fx){\n                case 0:\n                    DataY[0] = (DataY[0]==75?650:DataY[0]-25);\n                    break;\n                case 1:\n                    DataX[0] = (DataX[0]==850?25:DataX[0]+25);\n                    break;\n                case 2:\n                    DataY[0] = (DataY[0]==650?75:DataY[0]+25);\n                    break;\n                case 3:\n                    DataX[0] = (DataX[0]==25?850:DataX[0]-25);\n                    break;\n            }\n            for(int i = 1;i < length;i++){\n                if(DataX[0] == DataX[i] && DataY[0] == DataY[i]){\n                    IsOver = true;\n                    IsStart = false;\n                }\n            }\n            repaint();//重画\n        }\n        if(length>20){\n            timer.setDelay(50);\n        } else if(length>15){\n            timer.setDelay(100);\n        }\n        else if(length>5){\n            timer.setDelay(150);\n        }\n        timer.start();\n    }\n```\n\n### 完善`paintComponent`，游戏面板类完整代码\n\n```java\npackage com.codefriday.snake;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.util.Random;\n\npublic class GamePanel extends JPanel implements KeyListener, ActionListener {\n    //存每一节蛇的坐标\n    int DataX[] = new int[820];\n    int DataY[] = new int[820];\n    boolean IsStart;//游戏状态，默认false，未开始\n    boolean IsOver;//是否失败\n    int length;//蛇的长度\n    int fx;//蛇的方向，↑0 →1 ↓2 ←3\n    int FoodX,FoodY;//食物位置\n    int score;//得分\n    Random random = new Random();\n    Timer timer = new Timer(200,this);\n    public GamePanel(){\n        init();\n        this.setFocusable(true);//获得焦点事件\n        this.addKeyListener(this);\n        timer.start();\n    }\n    void init(){\n        fx = 1;\n        length = 3;\n        IsStart = false;\n        IsOver = false;\n        score = 0;\n        DataX[0] = 100; DataY[0] = 100;\n        DataX[1] = 75; DataY[1] = 100;\n        DataX[2] = 50; DataY[2] = 100;\n        FoodX = 25 + 25*(random.nextInt(34));\n        FoodY = 75 + 25*(random.nextInt(24));\n    }\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);//清屏\n        //画游戏静态面板\n        this.setBackground(Color.white);\n        Data.header.paintIcon(this,g,25,11);\n        g.fillRect(25,75,850,600);\n        //画积分\n        g.setColor(new Color(145, 19, 173, 255));\n        g.setFont(new Font(\"微软雅黑\",Font.BOLD,18));\n        g.drawString(\"长度 \"+length,750,30);\n        g.drawString(\"分数 \"+score,750,50);\n        //画食物\n        Data.food.paintIcon(this,g,FoodX,FoodY);\n        //画蛇\n        switch (fx){\n            case 0:\n                Data.up.paintIcon(this,g,DataX[0],DataY[0]);\n                break;\n            case 1:\n                Data.right.paintIcon(this,g,DataX[0],DataY[0]);\n                break;\n            case 2:\n                Data.down.paintIcon(this,g,DataX[0],DataY[0]);\n                break;\n            case 3:\n                Data.left.paintIcon(this,g,DataX[0],DataY[0]);\n                break;\n        }\n        for(int i = 1;i < length;i++){\n            Data.body.paintIcon(this,g,DataX[i],DataY[i]);\n        }\n        if(!IsStart&&!IsOver){\n            g.setColor(Color.white);\n            g.setFont(new Font(\"微软雅黑\",Font.BOLD,40));\n            g.drawString(\"按下空格开始游戏!\",300,300);\n        }\n        if(IsOver){\n            g.setColor(Color.red);\n            g.setFont(new Font(\"微软雅黑\",Font.BOLD,40));\n            g.drawString(\"gg,按下空格重新开始!\",250,300);\n        }\n    }\n\n    //键盘监听事件接口中的方法\n    @Override\n    public void keyPressed(KeyEvent e) {\n        int keyCode = e.getKeyCode();\n        switch (keyCode){\n            case KeyEvent.VK_SPACE:\n                if(IsOver){\n                    init();\n                }else {\n                    IsStart = !IsStart;\n                }\n                repaint();\n                break;\n            case KeyEvent.VK_UP:\n                if(IsStart){\n                    fx = (fx==2?fx:0);\n                }\n                break;\n            case KeyEvent.VK_DOWN:\n                if(IsStart){\n                    fx = (fx==0?fx:2);\n                }\n                break;\n            case KeyEvent.VK_LEFT:\n                if(IsStart){\n                    fx = (fx==1?fx:3);\n                }\n                break;\n            case KeyEvent.VK_RIGHT:\n                if(IsStart){\n                    fx = (fx==3?fx:1);\n                }\n                break;\n        }\n\n    }\n    @Override\n    public void keyTyped(KeyEvent e) {\n\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e) {\n\n    }\n\n    //事件监听----通过固定时间刷新\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        if(IsStart){\n            if(FoodX == DataX[0] && FoodY == DataY[0]){//吃食物\n                length++;\n                score += 10;\n                //重新生成食物\n                FoodX = 25 + 25*(random.nextInt(34));\n                FoodY = 75 + 25*(random.nextInt(24));\n            }\n            for(int i = length-1;i>0;i--){\n                DataX[i] = DataX[i-1];\n                DataY[i] = DataY[i-1];\n            }\n            switch (fx){\n                case 0:\n                    DataY[0] = (DataY[0]==75?650:DataY[0]-25);\n                    break;\n                case 1:\n                    DataX[0] = (DataX[0]==850?25:DataX[0]+25);\n                    break;\n                case 2:\n                    DataY[0] = (DataY[0]==650?75:DataY[0]+25);\n                    break;\n                case 3:\n                    DataX[0] = (DataX[0]==25?850:DataX[0]-25);\n                    break;\n            }\n            for(int i = 1;i < length;i++){\n                if(DataX[0] == DataX[i] && DataY[0] == DataY[i]){\n                    IsOver = true;\n                    IsStart = false;\n                }\n            }\n            repaint();//重画\n        }\n        if(length>20){\n            timer.setDelay(50);\n        } else if(length>15){\n            timer.setDelay(100);\n        }\n        else if(length>5){\n            timer.setDelay(150);\n        }\n        timer.start();\n    }\n}\n\n```\n\n### 游戏实现的细节\n\n+ 小蛇从某一边界出去从另外一个边界出来，也可把边界处理部分代码改成判定失败就不可出边界！\n+ 小蛇长度变长，速度会变快，实现原理：修改定时器间隔\n\n## 测试如下\n\n![](GUI实战-贪吃蛇小游戏/3.png)\n\n![](GUI实战-贪吃蛇小游戏/4.png)\n\n![](GUI实战-贪吃蛇小游戏/5.png)\n\n## 打包成jar包\n\n![](GUI实战-贪吃蛇小游戏/6.png)\n\n选择主启动函数。打包成`jar`包。","tags":["第一阶段"],"categories":["实战项目"]},{"title":"HashMap和ConcurrentHashMap","url":"/2021/01/02/HashMap和ConcurrentHashMap/","content":"\n## 前言\n\n`JavaSE`基础知识也学了大部分了，发现Java中有一个数据结构有着举足轻重的重用，什么面试必考啊，你必须掌握啊~~~，那就是`HashMap`，完后谈到这玩意，都拿1.7版本JDK和1.8版本JDK版本作比较。大多数学Java的听说过了，1.7嘛底层数据结构数组+链表，1.8多了个红黑树。完后1.7中它是线程不安全的，它查找效率可能会很低，冲突解决策略是简单用链表把冲突的节点串起来，那必然不会有很高效率，`O(n)`查找。因此1.8之后就加了红黑树，就冲突链表长度超过一个阈值，给他把链表转红黑树结构，但他依旧是线程不安全的。红黑树就是一个不是非常严格的平衡二叉树嘛，查找效率`O(logn)`级别。\n\n都是线程不安全，有啥区别：\n\n1.7中采用的是头插法，即插在链表的都节点处，而1.8是尾插法，这所谓头插尾插都是在扩容时的操作。1.7多线程头插法可能会导致出现环形链表。\n\n线程安全的`HashMap`在`java.util.concurrent`包下\n\n以上都是看了很多博客、视频总结得来的东西。完后我自己用的JDK15也去读了读源码，但是感觉还是不够，于是我下载了1.7版本JDK和1.8版本JDK来读一下源码。\n\n![](HashMap和ConcurrentHashMap/1.png)\n\n接下来分四个部分读源码，1.7版本`HashMap`，1.8版本`Hashmap`，1.7版本`ConcurrentHashMap`\n\n,1.8版本`ConcurrentHashMap`。\n\n## JDK1.7版本HashMap\n\n先看一下如何存键值对，列出`static class Entry<K,V> implements Map.Entry<K,V>`属性：\n\n```java\nfinal K key;\nV value;\nEntry<K,V> next;\nint hash;\n```\n\n`next`主要用来串出现冲突的键值对。单向链表处理冲突！\n\n### new-构造一个HashMap对象\n\n借助强大的IDEA来直接导入1.7版本JDK版本\n\n![](HashMap和ConcurrentHashMap/2.png)\n\n直接写`new HashMap;`\n\n```java\npackage hello;\n\nimport java.util.HashMap;\n\npublic class Test {\n    public static void main(String[] args) {\n        HashMap hashMap = new HashMap();\n        hashMap.put(1,\"code\");\n        hashMap.put(2,\"friday\");\n    }\n}\n```\n\n`Ctrl+鼠标左键`直接进到`HashMap`源码，使用快捷键`Alt+7`查看这个类中的一些方法以及属性\n\n![](HashMap和ConcurrentHashMap/3.png)\n\n可以看到有4种构造方法，完后再看看其中的一些属性，直接上源码如下：\n\n```java\n//其实源码中的注释已经解释得很清楚，中文备注一下\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\t//默认初始容量，必须是2的幂次，MUST be a power of two.\n\n    static final int MAXIMUM_CAPACITY = 1 << 30;\n\t//最大容量\n\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\t//默认加载因子，0.75\n\n    static final Entry<?,?>[] EMPTY_TABLE = {};\n\t//用来比较判断table是否为空用的，后面代码会体现！\n\n    transient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;\n\t//存储底层数据结构：数组\n\n    transient int size;\n\t//已经存的key-value数量\n\n    int threshold;\n\t//阈值，容量*加载因子得的，存的键值对超过这个阈值就要进行数组扩容操作\n\n    final float loadFactor;\n\t//加载因子\n\n```\n\n根据我写的代码，我调用了无参构造，查看源码调用方法的过程如下：\n\n```java\n /**\n     * Constructs an empty <tt>HashMap</tt> with the default initial capacity\n     * (16) and the default load factor (0.75).\n     */\n    public HashMap() {\n        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);\n    }\n//就给默认容量16，加载因子0.75，然后调用有参构造\npublic HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)//1.\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)//2.\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))//3.\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n\n        this.loadFactor = loadFactor;\n        threshold = initialCapacity;//此时没有插入键值对，阈值==容量\n        init();//空函数啥也没做\n    }\n```\n\n+ 1.第一个if判断，传入容量值为负数，抛出一个异常\n+ 2.第二个if判断，传入容量超过允许最大容量，就按最大容量来\n+ 3.第三个if判断，加载因子也可以自己给，判断一下是否0-1范围且是一个有效的数，不是就抛出异常\n\n自此可以得到，调用构造函数new一个`HashMap`对象，实际用来存键值对的数组并没有创建。\n\n自此，`new`操作结束，接下来肯定就是往里存键值对，调用的是`put`方法\n\n### put方法\n\n**put执行流程如下：**\n\n+ 判断数组是否已经创建\n+ 判断key是否为空，针对`key==null`插入有一个方法\n+ 计算哈希值并找一个数组下标去存\n+ 先判断key是否已经存在，存在就更新value值，返回旧的value\n+ 不存在就调用`addEntry`插入\n\n```java\npublic V put(K key, V value) {\n    if (table == EMPTY_TABLE) {//判断数组是否为空\n        inflateTable(threshold);\n    }\n    if (key == null)//key为空，调用一个插入key==null的方法，由此可知可以存key为null的键值对\n        return putForNullKey(value);\n    int hash = hash(key);//计算一下key的hash值\n    int i = indexFor(hash, table.length);//根据哈希值取得应该存在数组中那个位置\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n        //遍历一个数组下标对应的链表，如果key已经存在，更新Value并返回旧的Value\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n\n    modCount++;//修改次数+1\n    addEntry(hash, key, value, i);//实际插入键值对的方法\n    return null;\n}\n```\n\n到此，有两处需要拓展！\n\n#### put方法扩展`indexFor`\n\n**注意：看源码时不能看到一个方法中调用了一个方法就马上点进去看，你会发现，可能一直点，点个好几层都没问题，完后回来你就不知道自己是要干嘛了。**\n\n人家写的代码的函数一般都**见名知意**。重要的方法，看完整体点进去验证一下就行~~~\n\n比如这里得去看看`indexFor`做了些啥，这会解释了为什么数组容量必须2的幂次，扩容也必须2倍扩容~\n\n```java\n/**\n     * Returns index for hash code h.\n     */\n    static int indexFor(int h, int length) {\n        // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\";\n        return h & (length-1);\n    }\n```\n\n简单的做了一个按位与运算。正常把元素映射到数组，想到的映射方法肯定是用取余操作模上数组长度，这是一种相对平均的散列算法。实际这个地方本质就是模数组长度，但是必须保证`length`是2的幂次才能达到这个效果。举个例子：\n\n![](HashMap和ConcurrentHashMap/4.png)\n\n数组长度保证2的幂次，就可用按位与代替取模操作，位运算的速度比取模运算快很多很多~，可以用个计数程序测试一下。\n\n#### put方法扩展`addEntry`\n\n```java\n/**传来的参数\n*@hash：key的哈希值\n*key,value即键值对\n*@bucketIndex：键值对需要插入的桶的索引，就是数组索引，数组每一格当作一个桶\n*/\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    if ((size >= threshold) && (null != table[bucketIndex])) {//如果存的键值对已经超过阈值，就需要扩容\n        resize(2 * table.length);//扩容，2倍扩容，后续分析源码\n        hash = (null != key) ? hash(key) : 0;//重新计算一下key的hash值\n        bucketIndex = indexFor(hash, table.length);//根据hash值重新找应该放在数组哪个位置\n    }\n\n    createEntry(hash, key, value, bucketIndex);//实际放入数组的方法\n}\n```\n\n还得点一层`createEntry`，源码如下：\n\n```java\nvoid createEntry(int hash, K key, V value, int bucketIndex) {\n        Entry<K,V> e = table[bucketIndex];//把同中键值对取出来\n        table[bucketIndex] = new Entry<>(hash, key, value, e);//把新键值对加进入，并把e接到后面，这就是头插法！！！\n        size++;//键值对计数器+1\n    }\n```\n\n画个图演示一下——头插法\n\n![](HashMap和ConcurrentHashMap/5.png)\n\n**补充：key==null时默认插入数组下标为0的地方**\n\n### get方法\n\n上源码：\n\n```java\npublic V get(Object key) {\n        if (key == null)//key为null调用对应方法\n            return getForNullKey();\n        Entry<K,V> entry = getEntry(key);//获取整个Entry对象\n\n        return null == entry ? null : entry.getValue();//如果Entry对象为空表示没有这个映射，否则返回value值\n    }\n```\n\n`getEntry`源码如下：\n\n```java\nfinal Entry<K,V> getEntry(Object key) {\n        if (size == 0) {\n            return null;\n        }\n        int hash = (key == null) ? 0 : hash(key);\n        for (Entry<K,V> e = table[indexFor(hash, table.length)];//找到key对应数组中的位置\n             e != null;\n             e = e.next) {//遍历桶，也就是遍历链表\n            Object k;\n            if (e.hash == hash &&\n                ((k = e.key) == key || (key != null && key.equals(k))))\n                return e;//找到key返回Entry对象\n        }\n        return null;//没找到\n    }\n```\n\n相对简单，主要还是因为数组+链表实现`HashMap`数据结构并不复杂。\n\n接下来必须看看扩容操作了！\n\n### resize方法\n\n```java\nvoid resize(int newCapacity) {\n        Entry[] oldTable = table;//拿个指针指向原来的数组\n        int oldCapacity = oldTable.length;//记录一下原来数组大小\n        if (oldCapacity == MAXIMUM_CAPACITY) {//原来容量已经达到最大值\n            threshold = Integer.MAX_VALUE;//把阈值给扩大一下，没办法，数组不允许再扩大了\n            return;//返回\n        }\n\n        Entry[] newTable = new Entry[newCapacity];//新数组，原来的两倍\n        transfer(newTable, initHashSeedAsNeeded(newCapacity));//把老数组数据转移到新数组\n        table = newTable;//更新一下数组\n        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);//更新一下阈值\n    }\n```\n\n重点那肯定是在`transfer`，这也是并发操作导致双向链表的地方！！！源码如下：\n\n```java\nvoid transfer(Entry[] newTable, boolean rehash) {\n        int newCapacity = newTable.length;\n        for (Entry<K,V> e : table) {\n            while(null != e) {\n                Entry<K,V> next = e.next;\n                if (rehash) {//是否需要重新计算hash值\n                    e.hash = null == e.key ? 0 : hash(e.key);\n                }\n                int i = indexFor(e.hash, newCapacity);//重新计算数组下标\n                e.next = newTable[i];\n                newTable[i] = e;\n                e = next;//一样的的头插法重新放进去\n            }\n        }\n    }\n```\n\n### 并发出现环形链表\n\n![](HashMap和ConcurrentHashMap/6.png)\n\n下一次get查找这个桶时，死循环在里面不出来了！\n\n## JDK1.8版本HashMap\n\n进入Project Structure切换JDK版本：\n\n![](HashMap和ConcurrentHashMap/7.png)\n\n### 数据结构和辅助函数改变\n\n点进源码后，存储一个键值对的数据结构如下：\n\n```java\n static class Node<K,V> implements Map.Entry<K,V> {\n        final int hash;\n        final K key;\n        V value;\n        Node<K,V> next;\n }\n//只列出属性\n```\n\n名字都改了，`Entry`改成`Node`，内容倒是没变。既然引入了红黑树，那肯定由红黑树节点对应的数据结构：(只列出属性)\n\n```java\n static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n        TreeNode<K,V> parent;  // red-black tree links\n        TreeNode<K,V> left;\n        TreeNode<K,V> right;\n        TreeNode<K,V> prev;    // needed to unlink next upon deletion\n        boolean red;\n  }\n```\n\n**hash函数也改了：**\n\n```java\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n//1.7版本直接获取key的hashCode，现在把hashcode高位和低位做了一下异或操作，这玩意叫扰动函数\n\n```\n\n**扰动函数作用：**你求于的时候包含了高16位和第16位的特性 也就是说你所计算出来的hash值包含从而使得你的hash值更加不确定 来降低碰撞的概率。\n\n构造函数其实本质和1.7版本还是差不多。有很大不同的地方还是分析put，get，resize方法\n\n### put方法\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n//直接调用了putVal\n```\n\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)//如果数组还未创建\n            n = (tab = resize()).length;\n        if ((p = tab[i = (n - 1) & hash]) == null)//根据hash值找到对应存放的数组下标\n            tab[i] = newNode(hash, key, value, null);//如果该位置空，直接新建一个链表节点\n        else {//否则就遍历一下链表，看key是否有重复\n            Node<K,V> e; K k;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            else if (p instanceof TreeNode)//如果已经树化，调用红黑树的插入方法\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {//链表的插入方法\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);//链表长度超过阈值，树化\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // key已经存在，覆盖value并返回原来的\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)\n            resize();//判断一下是否需要扩容+\n    \n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n`putVal`插入流程：\n\n+ 判断数组是否已经创建\n+ 根据hash值找到对应存放的数组下标\n+ 分三种情况\n  + 该位置为空\n  + 红黑树的插入\n  + 链表的插入\n+ 插入如果是覆盖就返回旧值\n+ 判断一下是否达到阈值，然后扩容一下\n\n### get方法\n\n```java\npublic V get(Object key) {\n        Node<K,V> e;\n        return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n//调用了getNode方法\n```\n\n```java\nfinal Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {//先判断表不为空，并根据hash索引到数组下标不为空\n            if (first.hash == hash && // always check first node先检查第一个\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;\n            if ((e = first.next) != null) {\n                if (first instanceof TreeNode)//红黑树的查找方法\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                do {//否则就是链表的查找方法\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;//找不到返回null\n    }\n```\n\n执行流程也相对简单，分红黑树和链表的查找方法，重点在扩容（注：我只分析了链表，为了对比1.7版本）\n\n### resize方法\n\n源码挺长：\n\n```java\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;//保存一下原来的表，不再需要传容量大小的参数，区别于1.7\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;//获取原来的容量\n        int oldThr = threshold;//原来的阈值\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            if (oldCap >= MAXIMUM_CAPACITY) {//如果容量已经超过最大容量\n                threshold = Integer.MAX_VALUE;//只能扩大阈值\n                return oldTab;\n            }\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                //扩大两倍容量并判断是否小于允许的最大容量，原来的容量是否大于等于16\n                newThr = oldThr << 1; // double threshold，都满足就扩大阈值，阈值在new的时候没传参数其实就给了默认\n        }\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        else {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n   \t\t//上面主要是更新容量值和阈值的值\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];//创建新表\n        table = newTab;\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {//遍历旧表，准备数据迁移\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;//如果旧桶中只有一个元素\n                    else if (e instanceof TreeNode)//如果是红黑树节点\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order//链表，保留原来的顺序，也就是尾插法\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n```\n\n重点分析链表数据迁移的过程，定义了四个链表节点\n\n```java\nNode<K,V> loHead = null, loTail = null;\nNode<K,V> hiHead = null, hiTail = null;\n```\n\n其实数据迁移过程，无非是把原来链表拆分成两个链表（不考虑红黑树），而且两个链表中的数据根据哈希值和`oldlength-1`求与之后得到的数组索引一定满足以下关系：\n\n`OldIndex == OldIndex 或 OldIndex+oldlength`\n\n分出去到更高索引的其实就是多看一个二进制位，比如原来容量是8，现在看看第4位（从低到高从1开始计），如果是1那就分到更高索引的数组去。因此定义了一个`loHead`和`hiHead`两个链表。接下来模拟操作以一下\n\ndo-while循环完之后：\n\n![](HashMap和ConcurrentHashMap/8.png)\n\n接下来两个if判断：就是把链表放到新数组中去：\n\n```java\nif (loTail != null) {\n\tloTail.next = null;\n\tnewTab[j] = loHead;\n}\nif (hiTail != null) {\n\thiTail.next = null;\n\tnewTab[j + oldCap] = hiHead;\n}\n```\n\n### 并发操作出现的问题\n\n没有任何同步机制，多线程肯定会出现关键节点线程抢占，比如其中`size`表示键值对的数目，其他线程可能对`size`的副本做出修改还未更新本来的值，那必然会出现多个线程数据覆盖的问题。实际就会出现，并发插入键值对，实际插入数量！=size，这只是一个不严谨的举例，实际自己写个测试程序运行就会抛出并发操作异常。\n\n## JDK1.7版本ConcurrentHashMap\n\n由于目前只有只学习了操作系统导论中的并发，讲的也是C/C++下的，还未学习Java中并发的一些实现进制。只能浅显分析一波~~~\n\n出错以后来改，或者欢迎评论区纠正\n\n首先这是它的结构图：\n\n![](HashMap和ConcurrentHashMap/9.png)\n\n为了实现互斥的话，最简单的思路就是只允许一个线程操作哈希表，也就是价格锁，但这样自己用`HashMap`写好同步代码块就完事了，这东西也就没存在的意义，而且并不是所有线程并发操作哈希表都是会导致出错的，因此可以考虑把哈希表分成很多段，每个段保证只能一个线程进去操作，那就可以实现真正意义上的并发操作哈希表，JDK1.7中就是利用了分段锁的机制实现互斥。\n\n### 核心属性以及数据结构\n\n新增的属性：\n\n```java\nstatic final int DEFAULT_CONCURRENCY_LEVEL = 16;\n//默认并发级别，也就是允许多少个线程同时操作\n\nstatic final int MIN_SEGMENT_TABLE_CAPACITY = 2;\n//每个段下默认hash表的长度\n\nstatic final int MAX_SEGMENTS = 1 << 16; // slightly conservative\n//允许最大的段数量\n\n```\n\n数据结构：\n\n```java\nfinal Segment<K,V>[] segments;\n\ntransient Set<K> keySet;\ntransient Set<Map.Entry<K,V>> entrySet;\ntransient Collection<V> values;\n```\n\n查看`Segment`类定义：\n\n```java\nstatic final class Segment<K,V> extends ReentrantLock implements Serializable \n```\n\n实现了`ReentrantLock`，其实就是一种锁的类型。jdk中独占锁的实现除了使用关键字`synchronized`外,还可以使用`ReentrantLock。`\n\n上面的东西暂时没学到。\n\n本质和`HashMap`没多大区别，只不过用到了`volatile `关键字等实现同步互斥。\n\n原理上来说：`ConcurrentHashMap` 采用了分段锁技术，其中` Segment `继承于` ReentrantLock`。不会像` HashTable `那样不管是` put `还是 `get `操作都需要做同步处理，理论上` ConcurrentHashMap `支持` CurrencyLevel` (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个` Segmen`t 时，不会影响到其他的 `Segment`。\n\n\n\n1.7版本解决并发问题之后，但是数组+链表的实现还是会导致查询效率低。\n\n## JDK1.8版本ConcurrentHashMap\n\n在JDK1.8版本丢弃了分段锁。\n\n采用了 `CAS + synchronized` 来保证并发安全性。\n\n`CAS`全称`CompareAndSwap`，在操作系统导论中这是操作系统中硬件提供的功能强大的原子操作，来实现锁机制用的。\n\n此处我觉得是差不多的思想，实际上这个操作似乎也是C++写的，调用了C++写的包，因为Java不能去搞底处的内存管理。\n\n## 总结\n\n1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（`O(logn)`），甚至取消了` ReentrantLock `改为了 `synchronized`，这样可以看出在新版的` JDK` 中对 `synchronized `优化是很到位的。","tags":["第一阶段感悟"],"categories":["第一阶段感悟"]},{"title":"编码和字符集","url":"/2021/01/01/编码和字符集/","content":"\n## ASCII码\n\n世界上只有两种人——一种会二进制，一种不会二进制~~~\n在初学C++时，接触最多的编码就是ASCII码了，全称((American Standard Code for Information Interchange): 美国信息交换标准代码），是老外发明的，老外用的，主要用于显示现代英语和其他西欧语言。\n\n然后C++中的char变量使用的就是ASCII码。用`sizeof（char）`将会得到`1`，C++中一个char类型占用一个字节的内存。一字节=8个二进制位。而ASCII码实际只需要7位就可编码，`2^7=128`，而在标准ASCII中，其最高位(b7)用作奇偶校验位。所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验和偶校验两种。奇校验规定：正确的代码一个字节中1的个数必须是奇数，若非奇数，则在最高位b7添1；偶校验规定：正确的代码一个字节中1的个数必须是偶数，若非偶数，则在最高位b7添1。\n\n**由此引出问题：**\n\n都有哪些字符集和编码规则，以及中文怎么输出的，C语言中用char数组是可以正常保存并输出中文的，但似乎有的字会乱码~\n\n## 字符集&编码\n\n### 编码\n\n在显示器上看见的文字、图片等信息在电脑里面其实并不是我们看见的样子，即使你知道所有信息都存储在硬盘里，把它拆开也看不见里面有任何东西，只有些盘片。假设，你用显微镜把盘片放大，会看见盘片表面凹凸不平，凸起的地方被磁化，凹的地方是没有被磁化；凸起的地方代表数字1，凹的地方代表数字0。硬盘只能用0和1来表示所有文字、图片等信息。\n\n因此需要制定一系列大家共同认可和使用的编码规则来把01的组合表示成有意义的信息。而上面Ascii码就是一种规则，比如用二进制`0100 0001`表示字母`A`，那么信息交换的时候按照编码规则解码就得到了信息本来的意义。\n\n### 字符集\n\n是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。\n\n## 常用的字符集和字符编码\n\n常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等。\n\n### ASCII字符集&编码\n\n图片来自百度百科：\n\n![](编码和字符集/1.png)\n\n老外为了表示更多的欧洲常用字符对ASCII进行了扩展，不要在高位当校验位了，ASCII扩展字符集使用8位（bits）表示一个字符，共256字符。ASCII字符集映射到数字编码规则如下图所示：\n\n![](编码和字符集/2.png)\n\n然而中文都不能表示！！！然后来了GBXXXX字符集&编码\n\n### GB2312字符集&编码\n\n计算机是老外发明的嘛，发明之后很长一段时间只是应用于美国及西方一些发达国家，ASCII完全满足他们。\n\n但是现在基本家家户户都有计算机，因此必须设计一套编码规则显示中文。于是专家们把ASCII码127号之后东西取消掉，规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。而连用两个字符表示一个的符号叫\"全角\"字符，而原来在127号以下的那些就叫\"半角\"字符了。\n\nC/C++程序运行时那个黑框输入东西时会提示！\n\n上述编码规则就是**GB2312**。\n\n这也解决了我的一个疑问，以前只是听老师说两个字符表示一个汉字，他是怎么知道什么时候是两个字符连起来表示呢~~~\n\n### BIG5字符集&编码\n\n**Big5**，又称为**大五码**或**五大码**，是使用繁体中文（正体中文）社区中最常用的电脑汉字字符集)标准，共收录13,060个汉字。中文码分为内码及交换码两类，Big5属中文内码，知名的中文交换码有CCCII、CNS11643。Big5虽普及于台湾、香港与[澳门等繁体中文通行区，但长期以来并非当地的国家标准，而只是业界标准。倚天中文系统、Windows等主要系统的字符集都是以Big5为基准，但厂商又各自增加不同的造字与造字区，派生成多种不同版本。2003年，Big5被收录到CNS11643中文标准交换码的附录当中，取得了较正式的地位。这个最新版本被称为Big5-2003。\n\n## 过度\n\n每个计算机应用广泛的国家都会去制定一套自己的规则，因此肯定会出现一种可能不能做到统一，而现在是互联网时代，~~相信大家都不止会上国内的网站~~，懂的都懂，于是一个伟大的创想出现了，Unicode，顾名思义它是一种统一编码的意思，**统一码**、**万国码**、**单一码**、**标准万国码**。\n\n## Unicode\n\n在计算机科学领域中，**Unicode**（**统一码**、**万国码**、**单一码**、**标准万国码**）是业界的一种标准，它可以使电脑得以体现世界上数十种文字的系统。Unicode 是基于通用字符集（Universal Character Set）的标准来发展，并且同时也以书本的形式对外发表。Unicode 还不断在扩增， 每个新版本插入更多新的字符。直至目前为止的第六版，Unicode 就已经包含了超过十万个字符（在2005年，Unicode 的第十万个字符被采纳且认可成为标准之一）、一组可用以作为视觉参考的代码图表、一套编码方法与一组标准字符编码、一套包含了上标字、下标字等字符特性的枚举等。Unicode 组织（The Unicode Consortium）**是由一个非营利性的机构所运作**，并主导 Unicode 的后续发展，其目标在于：将既有的字符编码方案以Unicode 编码方案来加以取代，特别是既有的方案在多语环境下，皆仅有有限的空间以及不兼容的问题。\n\nUnicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。目前的Unicode字符分为17组编排，0x0000至0x10FFFF，每组称为平面（Plane），而每平面拥有65536个码位，共1114112个。然而目前只用了少数平面。UTF-8、UTF-16、UTF-32都是将数字转换到程序数据的编码方案。\n\n（**可以这样理解：Unicode是字符集，UTF-32/ UTF-16/ UTF-8是三种字符编码方案。**）\n\n### UTF-8\n\nUTF-8以字节为单位对Unicode进行编码。从Unicode到UTF-8的编码方式如下：\n\n| **Unicode编码(十六进制)** | **UTF-8 字节流(二进制)**            |\n| :------------------------ | :---------------------------------- |\n| 000000-00007F             | 0xxxxxxx                            |\n| 000080-0007FF             | 110xxxxx 10xxxxxx                   |\n| 000800-00FFFF             | 1110xxxx 10xxxxxx 10xxxxxx          |\n| 010000-10FFFF             | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |\n\nUTF-8的特点是对不同范围的字符使用不同长度的编码。对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同。UTF-8编码的最大长度是4个字节。从上表可以看出，4字节模板有21个x，即可以容纳21位二进制数字。Unicode的最大码位0x10FFFF也只有21位。\n\n例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。\n\n例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用4字节模板：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。\n\n### UTF-16\n\nUTF-16编码以16位无符号整数为单位。我们把Unicode编码记作U。编码规则如下：\n\n如果U<0x10000，则U的UTF-16编码就是U对应的16位无符号整数（为书写简便，下文将16位无符号整数记作WORD）。\n\n如果U≥0x10000，我们先计算U'=U-0x10000，然后将U'写成二进制形式：yyyy yyyy yyxx xxxx xxxx，U的UTF-16编码（二进制）就是：110110yyyyyyyyyy 110111xxxxxxxxxx。\n\n为什么U'可以被写成20个二进制位？Unicode的最大码位是0x10FFFF，减去0x10000后，U'的最大值是0xFFFFF，所以肯定可以用20个二进制位表示。例如：Unicode编码0x20C30，减去0x10000后，得到0x10C30，写成二进制是：0001 0000 1100 0011 0000。用前10位依次替代模板中的y，用后10位依次替代模板中的x，就得到：1101100001000011 1101110000110000，即0xD843 0xDC30。\n\n按照上述规则，Unicode编码0x10000-0x10FFFF的UTF-16编码有两个WORD，第一个WORD的高6位是110110，第二个WORD的高6位是110111。可见，第一个WORD的取值范围（二进制）是11011000 00000000到11011011 11111111，即0xD800-0xDBFF。第二个WORD的取值范围（二进制）是11011100 00000000到11011111 11111111，即0xDC00-0xDFFF。\n\n为了将一个WORD的UTF-16编码与两个WORD的UTF-16编码区分开来，Unicode编码的设计者将0xD800-0xDFFF保留下来，并称为代理区（Surrogate）：\n\n| D800－DB7F | High Surrogates             | 高位替代     |\n| ---------- | --------------------------- | ------------ |\n| DB80－DBFF | High Private Use Surrogates | 高位专用替代 |\n| DC00－DFFF | Low Surrogates              | 低位替代     |\n\n高位替代就是指这个范围的码位是两个WORD的UTF-16编码的第一个WORD。低位替代就是指这个范围的码位是两个WORD的UTF-16编码的第二个WORD。那么，高位专用替代是什么意思？我们来解答这个问题，顺便看看怎么由UTF-16编码推导Unicode编码。\n\n如果一个字符的UTF-16编码的第一个WORD在0xDB80到0xDBFF之间，那么它的Unicode编码在什么范围内？我们知道第二个WORD的取值范围是0xDC00-0xDFFF，所以这个字符的UTF-16编码范围应该是0xDB80 0xDC00到0xDBFF 0xDFFF。我们将这个范围写成二进制：\n\n1101101110000000 11011100 00000000 - 1101101111111111 1101111111111111\n\n按照编码的相反步骤，取出高低WORD的后10位，并拼在一起，得到1110 0000 0000 0000 0000 - 1111 1111 1111 1111 1111即0xe0000-0xfffff，按照编码的相反步骤再加上0x10000，得到0xf0000-0x10ffff。这就是UTF-16编码的第一个WORD在0xdb80到0xdbff之间的Unicode编码范围，即平面15和平面16。因为Unicode标准将平面15和平面16都作为专用区，所以0xDB80到0xDBFF之间的保留码位被称作高位专用替代。\n\n### UTF-32\n\nUTF-32编码以32位无符号整数为单位。Unicode的UTF-32编码就是其对应的32位无符号整数。\n\n### 字节序\n\n字节序有两种，分别是“大端”（Big Endian, BE）和“小端”（Little Endian, LE）。\n\n根据字节序的不同，UTF-16可被实现为UTF-16LE或UTF-16BE，UTF-32可被实现为UTF-32LE或UTF-32BE。例如：\n\n| **Unicode编码** | **UTF-16LE** | **UTF-16BE** | **UTF32-LE** | **UTF32-BE** |\n| --------------- | ------------ | ------------ | ------------ | ------------ |\n| 0x006C49        | 49 6C        | 6C 49        | 49 6C 00 00  | 00 00 6C 49  |\n| 0x020C30        | 30 DC 43 D8  | D8 43 DC 30  | 30 0C 02 00  | 00 02 0C 30  |\n\nUnicode标准建议用BOM（Byte Order Mark）来区分字节序，即在传输字节流前，先传输被作为BOM的字符“零宽无中断空格”。这个字符的编码是FEFF，而反过来的FFFE（UTF-16）和FFFE0000（UTF-32）在Unicode中都是未定义的码位，不应该出现于实际传输中。\n\n下表是各种UTF编码的BOM：\n\n| **UTF编码**       | **Byte Order Mark (BOM)** |\n| ----------------- | ------------------------- |\n| UTF-8 without BOM | 无                        |\n| UTF-8 with BOM    | EF BB BF                  |\n| UTF-16LE          | FF FE                     |\n| UTF-16BE          | FE FF                     |\n| UTF-32LE          | FF FE 00 00               |\n| UTF-32BE          | 00 00 FE FF               |\n\n## 总结\n\n用的最多的就是UTF-8","tags":["编码和字符集"],"categories":["杂七杂八"]},{"title":"关于HashMap","url":"/2020/12/30/关于HashMap/","content":"\n## HashMap容量\n\n以下是来自JDK15源代码中的定义：\n\n```java\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable\n```\n\n在集合框架中，把`Map`接口实现并继承了`AbstractMap`，所以是一个类\n\n继续往下读这个类，第一个属性定义源码如下：\n\n```java\n /**\n     * The default initial capacity - MUST be a power of two.\n     */\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n/**\n     * The maximum capacity, used if a higher value is implicitly specified\n     * by either of the constructors with arguments.\n     * MUST be a power of two <= 1<<30.\n     */\n    static final int MAXIMUM_CAPACITY = 1 << 30;\n//最大容量为2^31;原因如下，size都只是定义为int型\n/**\n     * The number of key-value mappings contained in this map.\n     */\n    transient int size;\n```\n\n默认初始化容量为16，而且必须初始化为2的n次幂，此处我试了一下，并不是指实例化时必须传一个2次幂整数作为参数。传入初始化容量后，它实际会调用一个修正函数：\n\n```java\n    /**\n     * Returns a power of two size for the given target capacity.\n     */\n    static final int tableSizeFor(int cap) {\n        int n = -1 >>> Integer.numberOfLeadingZeros(cap - 1);\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n个人解读：\nn = -1 对应二进制1111 1111 1111 1111\n    \nnumberOfLeadingZeros方法给定一个int类型数据，返回这个数据的二进制串中从最左边算起连续的“0”的总数量。\n    \n也就是找到遇到第一个1，左边（高位）有多少1，比如9的二进制1001，32位int表示的话，高28位都为0\n    \n>>>表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0\n    \n然后n得到的应该是一个大于等于n的数。\n    \n理由：\n    1.如果cap是2的次幂，如2^x次幂，那么2^x-1应该是x个1（最低位），那么实际n逻辑右移后得到的就是2^x-1\n    比如给16 ： \t\t\t\t\t0000 0000 0001 0000\n    减1得到：   \t\t\t\t\t0000 0000 0000 1111\n    调用numberOfLeadingZeros得到 ：\t28\n    完后：-1 >>> 28得到 \t\t\t\t0000 0000 0000 1111\n    \n    2.如果不是2的次幂，那么得到的就是大于cap的最小的2次幂\n\nreturn语句两个 ？ ： 运算符\n第一个判断n和0的关系，如果n小于0，那么就返回1，否则还得比较一下有没有超过允许的1最大容量，不超过返回n+1\n```\n\n通过高效位运算就完成了容量修正。但是好像并不能直接通过方法返回容量。\n\n查看`HashMap`有参构造函数:\n\n```java\n/* ---------------- Public operations -------------- */\n\n    /**\n     * Constructs an empty {@code HashMap} with the specified initial\n     * capacity and load factor.\n     *\n     * @param  initialCapacity the initial capacity\n     * @param  loadFactor      the load factor\n     * @throws IllegalArgumentException if the initial capacity is negative\n     *         or the load factor is nonpositive\n     */\n    public HashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n        this.loadFactor = loadFactor;\n        this.threshold = tableSizeFor(initialCapacity);\n    }\n```\n\n`threshold`字段存容量~~~，没方法直接获取这个指。\n\n突然想起看过反射了，还没用过。试一试！！！\n\n走起~\n\n```java\npublic class Main {\n    public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException, NoSuchFieldException {\n\n        HashMap<String,Integer> hm = new HashMap<String,Integer>(10);\n        //实例的getClass方法获取Class\n        Class<?> myhash = hm.getClass();\n        //获取指定属性，也可以调用getDeclaredFields()方法获取属性数组\n        Field threshold =  myhash.getDeclaredField(\"threshold\");\n        //将目标属性设置为可以访问\n        threshold.setAccessible(true);\n        System.out.println(threshold.get(hm));\n    }\n}\n```\n\n传参初始化容量为10，不出意外应该输出16\n\n![](关于HashMap/1.png)\n\n有警告，说是JDK版本太高~~~，但却是输出了16。\n\n## put方法\n\n**index = HashCode（Key） & （Length - 1）** \n\n可以说，Hash算法最终得到的index结果，完全取决于Key的Hashcode值的最后几位。\n\n如果Length - 1不是全1的二进制，映射方法不平均，好像根据什么泊松分布得出的结论。\n\n显然不符合Hash算法均匀分布的原则。","tags":["第一阶段感悟"],"categories":["第一阶段感悟"]},{"title":"集合框架","url":"/2020/12/29/集合框架/","content":"\n## 前言\n\nJava语言本身和C语言区别不大，所以很快建立了面向对象的思想后，有语法基础的支持，了解了泛型、注解、反射等概念后。可以开始学习Java强大的数据结构了——集合框架。\n\n集合框架被设计成要满足以下几个目标。\n\n- 该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。\n- 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。\n- 对一个集合的扩展和适应必须是简单的。\n\n## 框架图\n\n来自网络资源\n\n![](集合框架/集合框架.gif)\n\n## 接口&实现（类）&算法\n\n+ **接口：**\n\n  上图中虚线框均是接口，代表集合的抽象数据类型，之所以定义多个接口，是为了以不同的方式操作集合对象。\n\n+ **实现（类）：**\n\n  是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。\n\n+ **算法：**\n\n  实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。\n\n## 直接剖析JDK源码理解集合框架\n\n### 展开Collection\n\n在IDEA中打出关键字`Collection`——按住`Ctrl`点击进入`Collection`源代码——使用`Ctrl+H`快捷键即可查看集合继承关系如图：\n\n![](集合框架/1.png)\n\n首先可以观察到`Collection`本身就是一个接口并且这些东西都有锁，不可更改\n\n+ ```\n  SynchronizedCollection in Collections\n  ```\n\n  具体实现类，与线程安全有关。\n\n+ ```\n  ValuesView in ConcurrentHashMap\n  ```\n\n  具体实现类，与锁，线程安全有关。\n\n+ ```\n  BeanContext\n  ```\n\n  提供与 bean 上下文有关的类和接口，暂时不懂~\n\n+ ```\n  List\n  ```\n\n  一个接口，源码：\n\n  ```java\n  定义：public interface List<E> extends Collection<E>\n      泛型，单继承自Collection\n  ```\n\n  源码1068行，完后只是定义了41种方法，其中一种是重写了父接口的~自己数的不知道准不\n\n  接口只定义方法，不能带具体实现，因此大部分是函数的文档注释。\n\n+ ```\n  AbstractCollection\n  ```\n\n  实现了大部分的集合接口\n\n  最简单的一个`isEmpty()`的实现源码带文档注释如下：\n\n  ```java\n  /**\n       * {@inheritDoc}\n       *\n       * @implSpec\n       * This implementation returns {@code size() == 0}.\n       */\n      public boolean isEmpty() {\n          return size() == 0;\n      }\n  //直接调用size方法的返回值判断\n  ```\n\n+ ```\n  CollectionView\n  ```\n\n  源码中定义如下：\n\n  ```java\n  abstract static class CollectionView<K,V,E>\n          implements Collection<E>, java.io.Serializable\n  ```\n\n  暂时不知道干嘛用的\n\n+ ```\n  CheckedCollection\n  ```\n\n  也不懂干嘛用的\n\n+ ```\n  Set\n  ```\n\n  一个接口，继承至`Collection`\n\n  源码中定义如下：\n\n  ```java\n  public interface Set<E> extends Collection<E>\n  ```\n\n  和`List`一样就定义了一堆方法.\n\n+ ```\n  UnmodifiableCollection\n  ```\n\n  ???\n\n+ ```\n  Queue\n  源码中的定义\n  public interface Queue<E> extends Collection<E>\n  ```\n\n  定义一堆方法。\n\n  \n\n**主要关注接口部分继续展开`List`、`Set`、`Queue`**\n\n#### 展开List\n\n `List`第一条分支实现了`Vector`->`Stack`\n\n![](集合框架/3.png)\n\n`Vector`源码中定义如下：\n\n```java\npublic class Vector<E>\n    extends AbstractList<E>\n    implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n//继承AbstractList类，并实现List接口\n```\n\n`Stack`中源码定义如下：\n\n```java\npublic class Stack<E> extends Vector<E>\n//继承一个实体类，Vector基础新增一些方法\n//如：\n /**\n     * Pushes an item onto the top of this stack. This has exactly\n     * the same effect as:\n     * <blockquote><pre>\n     * addElement(item)</pre></blockquote>\n     *\n     * @param   item   the item to be pushed onto this stack.\n     * @return  the {@code item} argument.\n     * @see     java.util.Vector#addElement\n     */\n    public E push(E item) {\n        addElement(item);\n\n        return item;\n    }\n```\n\n`ArrayList`也是直接实现了List接口\n\n```java\n//源码定义如下：\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n//先继承了AbstractList然后实现List接口\n```\n\n`LinkedList`\n\n```java\n\npublic class LinkedList<E>\n    extends AbstractSequentialList<E>\n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n    //实现了List和Deque接口\n```\n\n#### 展开Queue\n\n![](集合框架/5.png)\n\n```java\npublic interface BlockingQueue<E> extends Queue<E> \n```\n\n```\npublic interface Deque<E> extends Queue<E>\n```\n\n`Deque`接口被`LinkedList`和`ArrayDeque`实现，定义源码如下：\n\n```java\npublic class LinkedList<E>\n    extends AbstractSequentialList<E>\n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable\n    \npublic class ArrayDeque<E> extends AbstractCollection<E>\n                           implements Deque<E>, Cloneable, Serializable\n```\n\n阻塞队列接口`BlockingQueue`继承自Queue接口，然后`BlockingDeque`继承`BlockingQueue`和`Deque`\n\n```java\npublic interface BlockingQueue<E> extends Queue<E> \n    \npublic interface BlockingDeque<E> extends BlockingQueue<E>, Deque<E> \n```\n\n#### 展开set\n\n源码中的重要定义\n\n![](集合框架/6.png)\n\n```java\npublic class HashSet<E>\n    extends AbstractSet<E>\n    implements Set<E>, Cloneable, java.io.Serializable\n \n public class LinkedHashSet<E>\n    extends HashSet<E>\n    implements Set<E>, Cloneable, java.io.Serializable\n```\n\n然后`AbstractSet`下生成很多种`Set`已经开始有点懵~\n\n大致框架最重要的部分应该是`Collection`下生成的一些的抽象类，即实现了接口中大部分方法的类\n\n![](集合框架/7.png)\n\n然后大致理出`Collection`这条线生成的直接用的，并且用的多的数据结构如图，不全~~~\n\n![](集合框架/8.png)\n\n### 展开Map\n\n![](集合框架/9.png)\n\n大致关系如下：(红色表示接口，绿色表示可用的实现类)\n\n![](集合框架/10.png)\n\n## 总结\n\n集合可以看作是一种容器，用来存储对象信息。所有集合类都位于java.util包下，但支持多线程的集合类位于java.util.concurrent包下。","tags":["第一阶段感悟"],"categories":["第一阶段感悟"]},{"title":"Java面向对象总结","url":"/2020/12/29/Java面向对象总结/","content":"\n## Java面向对象三大特性脑图\n\n![](Java面向对象总结/OOP总结.jpg)\n\n## instanceof关键字\n\n`X instance of Y`\n\n+ 编译通过的条件\n\n  X是Y的子类，X和Y的类型应该去看定义的左边，而不是new的右边所指向的东西\n\n+ 比较结果\n\n  X指向的类（看右边引用）是Y的子类\n\n**类型之间的转换**\n\n```java\n父类 -------> 子类\n高类 -------> 低类\n    必须使用强制类型装换\n  \n子类 -------> 父类\n低 -------> 高\n    不需要强制类型转换，但是会丢失子类的方法\n```\n\n## static关键字\n\n### 修饰变量\n\n静态的：可以直接通过`类名.变量名`格式直接访问，无论实例化多少对象，都只有一个！\n\n//多线程\n\n非静态的：必须先实例化类，才能使用\n\n### 修饰方法\n\n静态的：可直接调用（类加载时就加载了static修饰的）\n\n非静态的：必须先实例化类，才能通过实例的对象使用\n\n### 修饰代码块\n\n```java\n静态代码块\nstatic{} —— 最先执行，只执行一次，第一次加载类时执行\n匿名代码块：\n{} \t-- 先于构造器之前执行\n```\n\n## 抽象类\n\n**本质还是类！！！**\n\n抽象（封装继承多态）的抽象\n\n抽象类是一种约束~~\n\n### 特点\n\n1.不能new这个抽线类，只能有子类实现\n\n2.抽线类可以写普通方法\n\n3.抽象方法必须存在于抽象类中\n\n**4.存在构造器**\n\n## 接口\n\n**递进关系：**\n\n普通类：只有具体实现\n\n抽象类：具体实现，规范（抽象方法）都可以有\n\n**接口：只有规范**\n\n声明类的关键字：`class`\n\n声明接口的关键字：`interface `（本质就不是类了）\n\n### 特点\n\n其中定义一个方法默认有的修饰符：`public abstract`\n\n定义变量默认有的修饰符：`public static final`\n\n`implements`关键字实现，可多继承，侧面实现了多继承！！！\n\n继承时必须重写接口中所有方法\n\n## 扩展概念——内部类\n\n一个类的内部去定义一个新的类\n\n### 1.成员内部类\n\n类作为类的成员之一\n\n内部类可以获得外部类的私有属性（通过方法）\n\n内部类实例化方法：先实例化外部类，再使用外部类来实例化内部类\n\n### 2.静态内部类\n\nstatic修饰之后就不能用外部类私有属性了\n\n原因：static最先加载，都还不知道私有属性是啥！！！\n\n### 3.一个java类\n\n可以有多个`class`类但只能有一个`public class`类\n\n### 4.局部内部类\n\n方法中定义类\n\n### 5.匿名内部类\n\n接口也可new但是必须重写方法\n\n","tags":["第一阶段感悟"],"categories":["第一阶段感悟"]},{"title":"泛型","url":"/2020/12/28/泛型/","content":"\n## 概述\n\n其实Java中的泛型也就是C++中的模板类。C++中用的最多的就是STL中。之所以用到泛型其实就是使得一个函数的功能更强大，或者说一个类的功能更强大。比如写一个函数比较两个元素大小，在C++中有float类型，int类型，double甚至string时每种格式数据都需要写一个函数，很麻烦。\n\n什么是泛型？为什么要使用泛型？\n\n**泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。**\n\n**泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）**。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。\n\n## 举例\n\n在JDK1.5版本之前没有泛型，因此可以定义一个可以接收任何对象的List，\n\n![](泛型/1.png)\n\n定义一个ArrayList，格式是Object，所有类的父类\n\n![](泛型/2.png)\n\n上述问题是运行是产生问题。\n\n为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。\n\n## 特性\n\n泛型只在编译阶段有效。编译之后程序会采取去泛型化的措施，也就是说Java中的泛型，只在编译阶段有效。\n\n在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。\n\n**型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。**\n\n## 泛型的使用\n\n泛型的三种使用方法：泛型类，泛型接口，泛型方法\n\n### 泛型类\n\n在类的定义中使用类，然后就可让类中的操作都能使用泛型。最典型的就是Java各种容器类——List，Set，Map\n\n一个泛型类例子：\n\n```java\npackage Fanxing;\n\nclass Point<K,V> {       // 此处可以随便写标识符号，T是type的简称\n    private K key;\n    private V value;\n    public void set(K akey,V avalue){\n        this.key = akey;\n        this.value = avalue;\n    }\n    public V getValue(){//作为方法返回类型\n        return this.value;\n    }\n\n};\npublic class Test{\n    public static void main(String args[]){\n        Point<Integer,String> p = new Point<Integer,String>();\n        p.set(1,\"one\");\n        System.out.println(p.getValue());\n        fun(p);\n    }\n    public static void fun(Point<?,?> temp){//通配符 ？\n        System.out.println(temp.getValue());\n    }\n};\n```\n\n声明方法是在类名后面用尖括号把会用到的标识符号列出来。\n\n然后在类中就可以直接使用这些标识符，作为变量类型或者方法的返回类型都可以。\n\n### 泛型接口\n\n泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：\n\n```java\npackage Fanxing;\n\ninterface Info<T>{        // 在接口上定义泛型\n    public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型\n}\nclass InfoImpl<T> implements Info<T>{   // 定义泛型接口的子类\n    private T var ;             // 定义属性\n    public InfoImpl(T avar){     // 通过构造方法设置属性内容\n        this.var = avar;\n    }\n    public T getVar(){//实现接口\n        return this.var ;\n    }\n};\npublic class Test2{\n    public static void main(String arsg[]){\n        Info<String> i =new InfoImpl<String>(\"Codefriday\") ;\n        System.out.println(\"作者：\" + i.getVar()) ;\n    }\n};\n```\n\n### 泛型方法\n\n第一个泛型类例子中\n\n```java\n public V getValue()//作为方法返回类型\n```\n\n并不是一个泛型方法，这只是类中一个普通成员方法，下面引用泛型方法：\n\n\tpublic class Test1 {\n\t    public <T> void testMethod(T t){\n\t\n\t    }\n\t}\n类型参数位置在返回类型之前\n\n### 通配符\n\n除了用 `<T>`表示泛型外，还有 `<?>`这种形式。**？** 被称为通配符。\n\n通配符有 3 种形式。\n\n1. `<?>`被称作无限定的通配符。\n2. `<? extends T>`被称作有上限的通配符。\n3. `<? super T>`被称作有下限的通配符。\n\n## 类型擦除\n\n**泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除**。\n\n### 带来的局限性\n\n类型擦除，是泛型能够与之前的 java 版本代码兼容共存的原因。但也因为类型擦除，它会抹掉很多继承相关的特性，这是它带来的局限性。\n\n## 泛型中值得注意的地方\n\n### 不接受 8 种基本数据类型\n\n原因：只接受对象！！！\n\n```\nint->integer\n\nboolean->Boolean\n```\n\n## 总结\n\n泛型其实就是方便编程以及减小代码冗余度，但是只是编译阶段起作用。\n\n抽离了数据类型与代码逻辑，本意是提高程序代码的简洁性和可读性，并提供可能的编译时类型转换安全检测功能。","tags":["第一阶段"],"categories":["第一阶段"]},{"title":"Java数据结构","url":"/2020/12/27/Java数据结构/","content":"\n## 前言\n\n我有过数据结构的基础，学C++时都实现了一遍数据结构，所以相当于做记录，更偏向实际应用。\n\n本博客相当于是笔记，只为了给自己以后方便查资料等，并不是自己写的内容，因为我也是正在学。\n\n基本复制来的加上自己手敲代码给自己加深印象。\n\n资源来自[菜鸟网](https://www.runoob.com/java/java-tutorial.html)\n\n## Java 数据结构\n\nJava工具包提供了强大的数据结构。在Java中的数据结构主要包括以下几种接口和类：\n\n- 枚举（Enumeration）\n- 位集合（BitSet）\n- 向量（Vector）\n- 栈（Stack）\n- 字典（Dictionary）\n- 哈希表（Hashtable）\n- 属性（Properties）\n\n### 枚举（Enumeration）\n\n枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。 枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。\n\n例如，枚举定义了一个叫nextElement 的方法，该方法用来得到一个包含多元素的数据结构的下一个元素。\n\nEnumeration接口中定义了一些方法，通过这些方法可以枚举（一次获得一个）对象集合中的元素。\n\n这种传统接口已被迭代器取代，虽然Enumeration 还未被遗弃，但在现代代码中已经被很少使用了。尽管如此，它还是使用在诸如Vector和Properties这些传统类所定义的方法中，除此之外，还用在一些API类，并且在应用程序中也广泛被使用。 下表总结了一些Enumeration声明的方法：\n\n| **序号** |                         **方法描述**                         |\n| :------- | :----------------------------------------------------------: |\n| 1        | **boolean hasMoreElements( )**  测试此枚举是否包含更多的元素。 |\n| 2        | **Object nextElement( )** 如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素。 |\n\n实例：\n\n```cpp\npackage hello;\nimport java.util.Vector;\nimport java.util.Enumeration;\npublic class EnumerationTest {\n    public static void main(String args[]) {\n        Enumeration<String> days;\n        Vector<String> week = new Vector<String>();\n        week.add(\"Sunday\");\n        week.add(\"Monday\");\n        week.add(\"Tuesday\");\n        week.add(\"Wednesday\");\n        week.add(\"Thursday\");\n        week.add(\"Friday\");\n        week.add(\"Saturday\");\n        days = week.elements();\n        while(days.hasMoreElements()){\n            System.out.println(days.nextElement());\n        }\n    }\n}\n\n```\n\n运行结果：\n\n![](Java数据结构/1.png)\n\n### 位集合（BitSet）\n\n位集合类实现了一组可以单独设置和清除的位或标志。\n\n该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一\"位\"，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。\n\n一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。这和位向量（vector of bits）比较类似。\n\n这是一个传统的类，但它在Java 2中被完全重新设计。\n\nBitSet定义了两个构造方法。\n\n第一个构造方法创建一个默认的对象：\n\n```\nBitSet()\n```\n\n第二个方法允许用户指定初始大小。所有位初始化为0。\n\n```\nBitSet(int size)\n```\n\n### 向量（Vector）\n\n向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。\n\n和数组一样，Vector对象的元素也能通过索引访问。\n\n使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。\n\nVector 类实现了一个动态数组。和 ArrayList 很相似，但是两者是不同的：\n\n- Vector 是同步访问的。\n- Vector 包含了许多传统的方法，这些方法不属于集合框架。\n\nVector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。\n\nVector 类支持 4 种构造方法。\n\n第一种构造方法创建一个默认的向量，默认大小为 10：\n\n```\nVector()\n```\n\n第二种构造方法创建指定大小的向量。\n\n```\nVector(int size)\n```\n\n第三种构造方法创建指定大小的向量，并且增量用 incr 指定。增量表示向量每次增加的元素数目。\n\n```\nVector(int size,int incr)\n```\n\n第四种构造方法创建一个包含集合 c 元素的向量：\n\n```\nVector(Collection c)\n```\n\n一堆接口：比较两个接口，其他接口用到再写：\n\n int size()   返回此向量中的组件数。\n\n Enumeration elements()  返回此向量的组件的枚举。\n\nint capacity() 返回此向量的当前容量。\n\n**容量可以构造时指定，而size表示容器中现在有的对象个数。**\n\n### 栈（Stack）\n\n栈（Stack）实现了一个后进先出（LIFO）的数据结构。\n\n你可以把栈理解为对象的垂直分布的栈，当你添加一个新元素时，就将新元素放在其他元素的顶部。\n\n当你从栈中取元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。\n\n**除了由Vector定义的所有方法，自己也定义了一些方法：**\n\n堆栈只定义了默认构造函数，用来创建一个空栈。 堆栈除了包括由Vector定义的所有方法，也定义了自己的一些方法。\n\n```\nStack()\n```\n\n| 序号 |                           方法描述                           |\n| :--: | :----------------------------------------------------------: |\n|  1   |             boolean empty()  测试堆栈是否为空。              |\n|  2   |   Object peek( ) 查看堆栈顶部的对象，但不从堆栈中移除它。    |\n|  3   | Object pop( ) 移除堆栈顶部的对象，并作为此函数的值返回该对象。 |\n|  4   |        Object push(Object element) 把项压入堆栈顶部。        |\n|  5   | int search(Object element) 返回对象在堆栈中的位置，以 1 为基数。 |\n\n### 字典（Dictionary）\n\n字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。\n\n当你想要通过特定的键而不是整数索引来访问数据的时候，这时候应该使用Dictionary。\n\n由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。\n\n类似于C++的map\n\nDictionary 类是一个抽象类，用来存储键/值对，作用和Map类相似。\n\n给出键和值，你就可以将值存储在Dictionary对象中。一旦该值被存储，就可以通过它的键来获取它。所以和Map一样， Dictionary 也可以作为一个键/值对列表。\n\nDictionary定义的抽象方法如下表所示：\n\n| **序号** |                         **方法描述**                         |\n| :------: | :----------------------------------------------------------: |\n|    1     |  **Enumeration elements( )** 返回此 dictionary 中值的枚举。  |\n|    2     | **Object get(Object key)** 返回此 dictionary 中该键所映射到的值。 |\n|    3     | **boolean isEmpty( )** 测试此 dictionary 是否不存在从键到值的映射。 |\n|    4     |   **Enumeration keys( )** 返回此 dictionary 中的键的枚举。   |\n|    5     | **Object put(Object key, Object value)** 将指定 key 映射到此 dictionary 中指定 value。 |\n|    6     | **Object remove(Object key)** 从此 dictionary 中移除 key （及其相应的 value）。 |\n|    7     |  **int size( )** 返回此 dictionary 中条目（不同键）的数量。  |\n\nDictionary类已经过时了。在实际开发中，你可以实现Map接口来获取键/值的存储功能。\n\n### 哈希表（Hashtable）\n\nHashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。\n\n例如，在地址列表的哈希表中，你可以根据邮政编码作为键来存储和排序数据，而不是通过人名。\n\n哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。\n\n#### Java Hashtable 类\n\nHashtable是原始的java.util的一部分， 是一个Dictionary具体的实现 。\n\n然而，Java 2 重构的Hashtable实现了Map接口，因此，Hashtable现在集成到了集合框架中。它和HashMap类很相似，但是它支持同步。\n\n像HashMap一样，Hashtable在哈希表中存储键/值对。当使用一个哈希表，要指定用作键的对象，以及要链接到该键的值。\n\n然后，该键经过哈希处理，所得到的散列码被用作存储在该表中值的索引。\n\nHashtable定义了四个构造方法。第一个是默认构造方法：\n\n```\nHashtable()\n```\n\n第二个构造函数创建指定大小的哈希表：\n\n```\nHashtable(int size)\n```\n\n第三个构造方法创建了一个指定大小的哈希表，并且通过fillRatio指定填充比例。\n\n填充比例必须介于0.0和1.0之间，它决定了哈希表在重新调整大小之前的充满程度：\n\n```\nHashtable(int size,float fillRatio)\n```\n\n第四个构造方法创建了一个以M中元素为初始化元素的哈希表。\n\n哈希表的容量被设置为M的两倍。\n\n```\nHashtable(Map m)\n```\n\n### 属性（Properties）\n\nProperties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。\n\nProperties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。\n\n#### Java Properties 类\n\nProperties 继承于 Hashtable。表示一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。\n\nProperties 类被许多 Java 类使用。例如，在获取环境变量时它就作为 System.getProperties() 方法的返回值。\n\nProperties 定义如下实例变量.这个变量持有一个 Properties 对象相关的默认属性列表。\n\n```\nProperties defaults;\n```\n\nProperties类定义了两个构造方法. 第一个构造方法没有默认值。\n\n```\nProperties()\n```\n\n第二个构造方法使用propDefault 作为默认值。两种情况下，属性列表都为空：\n\n```\nProperties(Properties propDefault)\n```\n\n## 总结\n\n先大致过一遍，后面搞项目练手时不至于遇到就卡住！","tags":["第一阶段"],"categories":["第一阶段"]},{"title":"Java面向对象","url":"/2020/12/27/Java面向对象/","content":"\n<!--more-->\n\nJAVA是一门纯面向对象的语言。\n\n## 1.Java 继承\n\n### 1.1继承的概念\n\n继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。\n\n继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。\n\n所以继承需要符合的关系是：is-a，父类更通用，子类更具体。\n\n### 1.2类的继承格式\n\n在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：\n\n```java\nclass 父类 {\n}\n \nclass 子类 extends 父类 {\n}\n```\n\n### 1.3为什么需要继承\n\n一个简单例子：\n\n不使用继承，代码重复：\n\n![](Java面向对象/1.png)\n\n![](Java面向对象/2.png)\n\n使用继承之后：\n\n![](Java面向对象/3.png)\n\n从这两段代码可以看出来，代码存在重复了，导致后果就是代码量大且臃肿，而且维护性不高(维护性主要是后期需要修改的时候，就需要修改很多的代码，容易出错)，所以要从根本上解决这两段代码的问题，就需要继承，将两段代码中相同的部分提取出来组成 一个父类.\n\n### 1.4继承类型\n\n需要注意的是 Java 不支持多继承，但支持多重继承。(C++支持多继承)\n\n![](Java面向对象/4.png)\n\n### 1.5继承的特性\n\n- 子类拥有父类非 private 的属性、方法。\n- 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\n- 子类可以用自己的方式实现父类的方法。\n- Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。\n- 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。\n\n### 1.6 继承关键字\n\n继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 **java.lang** 包中，所以不需要 **import**）祖先类。\n\n#### 1.6.1extends关键字\n\n在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。\n\n#### 1.6.2implements关键字\n\n使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。\n\n#### 1.6.3super 与 this 关键字\n\nsuper关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。\n\nthis关键字：指向自己的引用。\n\n#### 1.6.4final关键字\n\nfinal 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：\n\n#### 1.6.5 构造器\n\n子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 **super** 关键字调用父类的构造器并配以适当的参数列表。\n\n如果父类构造器没有参数，则在子类的构造器中不需要使用 **super** 关键字调用父类构造器，系统会自动调用父类的无参构造器。\n\n## 2.Java 重写(Override)与重载(Overload)\n\n### 2.1重写(Override)\n\n重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。**即外壳不变，核心重写！**\n\n重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。\n\n重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。\n\n在编译阶段，只检查参数的引用类型。\n\n然而在运行时，Java 虚拟机(JVM)指定对象的类型并且运行该对象的方法。\n\n#### 2.1.1方法的重写规则\n\n- 参数列表与被重写方法的参数列表必须完全相同。\n- 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。\n- 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。\n- 父类的成员方法只能被它的子类重写。\n- 声明为 final 的方法不能被重写。\n- 声明为 static 的方法不能被重写，但是能够被再次声明。\n- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。\n- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。\n- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。\n- 构造方法不能被重写。\n- 如果不能继承一个类，则不能重写该类的方法。\n\n#### 2.1.2Super 关键字的使用\n\n当需要在子类中调用父类的被重写方法时，要使用 super 关键字。\n\n### 2.2重载(Overload)\n\n重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。\n\n每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。\n\n最常用的地方就是构造器的重载。\n\n#### 2.2.1重载规则:\n\n- 被重载的方法必须改变参数列表(参数个数或类型不一样)；\n- 被重载的方法可以改变返回类型；\n- 被重载的方法可以改变访问修饰符；\n- 被重载的方法可以声明新的或更广的检查异常；\n- 方法能够在同一个类中或者在一个子类中被重载。\n- 无法以返回值类型作为重载函数的区分标准。\n\n### 2.3重写与重载之间的区别\n\n|  区别点  | 重载方法 |                    重写方法                    |\n| :------: | :------: | :--------------------------------------------: |\n| 参数列表 | 必须修改 |                  一定不能修改                  |\n| 返回类型 | 可以修改 |                  一定不能修改                  |\n|   异常   | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常 |\n|   访问   | 可以修改 |     一定不能做更严格的限制（可以降低限制）     |\n\n### 2.4总结：\n\n方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。\n\n- (1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。\n- (2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。\n- (3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。\n\n![](Java面向对象/5.png)\n\n## 3.Java 多态\n\n多态是同一个行为具有多个不同表现形式或形态的能力。\n\n多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：\n\n### 3.1多态的优点\n\n- 1. 消除类型之间的耦合关系\n- 2. 可替换性\n- 3. 可扩充性\n- 4. 接口性\n- 5. 灵活性\n- 6. 简化性\n\n### 3.2多态存在的三个必要条件\n\n- 继承\n- 重写\n- 父类引用指向子类对象：**Parent p = new Child();**\n\n![](Java面向对象/6.png)\n\n### 3.3虚函数\n\n虚函数的存在是为了多态。\n\nJava 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。\n\n### 3.4多态的实现方式\n\n#### 方式一：重写\n\n#### 方式二：接口\n\n#### 方式三：抽象类和抽象方法\n\n## 4.Java 抽象类\n\n### 4.1抽象类\n\n在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。\n\n抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。\n\n由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。\n\n父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。\n\n在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n抽象类不能实例化：\n\n![](Java面向对象/7.png)\n\n### 4.2抽象方法\n\n如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。\n\nAbstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。\n\n抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。\n\n**声明抽象方法会造成以下两个结果：**\n\n- 如果一个类包含抽象方法，那么该类必须是抽象类。\n- 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。\n\n继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。\n\n### 4.3抽象类总结规定\n\n- 1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。\n- 2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。\n- 3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。\n- 4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。\n- 5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。\n\n## 5.Java 封装\n\n在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。\n\n封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。\n\n要访问该类的代码和数据，必须通过严格的接口控制。\n\n封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。\n\n适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。\n\n### 5.1封装的优点\n\n- 1. 良好的封装能够减少耦合。\n- 2. 类内部的结构可以自由修改。\n- 3. 可以对成员变量进行更精确的控制。\n- 4. 隐藏信息，实现细节。\n\n### 5.2实现Java封装的步骤\n\n#### 5.2.1修改属性的可见性来限制对属性的访问（一般限制为private），例如：\n\n```java\npublic class Person {\n    private String name;\n    private int age;\n}\n```\n\n这段代码中，将 **name** 和 **age** 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。\n\n#### 5.2.2对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：\n\n```java\npublic class Person{\n    private String name;\n    private int age;\n​\n    public int getAge(){\n      return age;\n    }\n​\n    public String getName(){\n      return name;\n    }\n​\n    public void setAge(int age){\n      this.age = age;\n    }\n​\n    public void setName(String name){\n      this.name = name;\n    }\n}\n```\n\n采用 **this** 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。\n\n## 6.Java 接口\n\n接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。\n\n接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。\n\n除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\n\n接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。\n\n### 6.1接口与类相似点：\n\n- 一个接口可以有多个方法。\n- 接口文件保存在 .java 结尾的文件中，文件名使用接口名。\n- 接口的字节码文件保存在 .class 结尾的文件中。\n- 接口相应的字节码文件必须在与包名称相匹配的目录结构中。\n\n### 6.2接口与类的区别：\n\n- 接口不能用于实例化对象。\n- 接口没有构造方法。\n- 接口中所有的方法必须是抽象方法。\n- 接口不能包含成员变量，除了 static 和 final 变量。\n- 接口不是被类继承了，而是要被类实现。\n- 接口支持多继承。\n\n### 6.3接口特性\n\n- 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 **public abstract**（只能是 public abstract，其他修饰符都会报错）。\n- 接口中可以含有变量，但是接口中的变量会被隐式的指定为 **public static final** 变量（并且只能是 public，用 private 修饰会报编译错误）。\n- 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。\n\n### 6.4抽象类和接口的区别\n\n- 1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。\n- 2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 **public static final** 类型的。\n- 3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。\n- 4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n### 6.5接口的声明\n\n规则：\n\n```java\n[可见度] interface 接口名称 [extends 其他的接口名] {\n        // 声明变量\n        // 抽象方法\n}\n```\n\n接口有以下特性：\n\n- 接口是隐式抽象的，当声明一个接口的时候，不必使用**abstract**关键字。\n- 接口中每一个方法也是隐式抽象的，声明时同样不需要**abstract**关键字。\n- 接口中的方法都是公有的。\n\n### 6.6接口的实现\n\n当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。\n\n类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。\n\n实现一个接口的语法，可以使用这个公式：\n\n```java\n...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...\n```\n\n重写接口中声明的方法时，需要注意以下规则：\n\n- 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。\n- 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。\n- 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。\n\n在实现接口的时候，也要注意一些规则：\n\n- 一个类可以同时实现多个接口。\n- 一个类只能继承一个类，但是能实现多个接口。\n- 一个接口能继承另一个接口，这和类之间的继承比较相似。\n\n### 6.7接口的继承\n\n一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。\n\n### 6.8接口的多继承\n\n在Java中，类的多继承是不合法，但接口允许多继承。\n\n在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：\n\n```java\npublic interface Hockey extends Sports, Event\n```\n\n### 6.9标记接口\n\n最常用的继承接口是没有包含任何方法的接口。\n\n标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。\n\n标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。\n\n例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：\n\n```java\npackage java.util;\npublic interface EventListener\n{}\n```\n\n没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：\n\n- 建立一个公共的父接口：\n\n  正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。\n\n- 向一个类添加数据类型：\n\n  这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。\n\n## 7.Java 枚举(enum)\n\nJava 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。\n\nJava 枚举类使用 enum 关键字来定义，各个常量使用逗号 **,** 来分割。\n\n例如定义一个颜色的枚举类。\n\n```\nenum Color \n{ \n    RED, GREEN, BLUE; \n} \n```\n\n实例：\n\n```java\nenum Color\n{\n    RED, GREEN, BLUE;\n}\n \npublic class Test\n{\n    // 执行输出结果\n    public static void main(String[] args)\n    {\n        Color c1 = Color.RED;\n        System.out.println(c1);\n    }\n}\n```\n\n输出：RED\n\n### 7.1内部类中使用枚举\n\n枚举类也可以声明在内部类中\n\n### 7.2迭代枚举元素\n\n可以使用 for 语句来迭代枚举元素：\n\n```java\nenum Color\n{\n    RED, GREEN, BLUE;\n}\npublic class MyClass {\n  public static void main(String[] args) {\n    for (Color myVar : Color.values()) {\n      System.out.println(myVar);\n    }\n  }\n}\n```\n\n和C++中的枚举区别很大\n\n### 7.3在 switch 中使用枚举类\n\n```java\nenum Color\n{\n    RED, GREEN, BLUE;\n}\npublic class MyClass {\n  public static void main(String[] args) {\n    Color myVar = Color.BLUE;\n\n    switch(myVar) {\n      case RED:\n        System.out.println(\"红色\");\n        break;\n      case GREEN:\n         System.out.println(\"绿色\");\n        break;\n      case BLUE:\n        System.out.println(\"蓝色\");\n        break;\n    }\n  }\n}\n```\n\n### 7.4values(), ordinal() 和 valueOf() 方法\n\nenum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。\n\nvalues(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：\n\n- values() 返回枚举类中所有的值。\n- ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。\n- valueOf()方法返回指定字符串值的枚举常量。\n\n## 8.Java 包(package)\n\n为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。\n\nC++中使用using namespace的编译指令区别！！！\n\n### 8.1包的作用\n\n- 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。\n- 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。\n- 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。\n\nJava 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。\n\n包语句的语法格式为：\n\n`package pkg1[．pkg2[．pkg3…]];`\n\n### 8.2创建包\n\n![](Java面向对象/8.png)\n\n然后可以把自己的包打包成jar包，并调用\n\n### 8.3import 关键字\n\n为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 \"import\" 语句可完成此功能。\n\n在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为：\n`port package1[.package2…].(classname|*);`\n\n### 8.4package 的目录结构\n\n类放在包中会有两种主要的结果：\n\n- 包名成为类名的一部分，正如我们前面讨论的一样。\n- 包名必须与相应的字节码所在的目录结构相吻合。\n\n下面是管理你自己 java 中文件的一种简单方式：\n\n+ 将类、接口等类型的源码放在一个文本中，这个文件的名字就是这个类型的名字，并以.java作为扩展名。例如：\n\n```java\n// 文件名 :  Car.java\n \npackage vehicle;\n \npublic class Car {\n   // 类实现  \n}\n```\n\n+ 接下来，把源文件放在一个目录中，这个目录要对应类所在包的名字。\n\n```java\n....\\vehicle\\Car.java\n```\n\n+ 现在，正确的类名和路径将会是如下样子：\n\n  - 类名 -> vehicle.Car\n  - 路径名 -> vehicle\\Car.java (在 windows 系统中)\n\n  通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是 runoob.com，所有的包名都以 com.runoob 开头。包名中的每一个部分对应一个子目录。\n\n  例如：有一个 **com.runoob.test** 的包，这个包包含一个叫做 Runoob.java 的源文件，那么相应的，应该有如下面的一连串子目录：\n\n```java\n....\\com\\runoob\\test\\Runoob.java\n```\n\n+ 编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类型的名字，并加上 .class 作为扩展后缀。 例如：\n\n```java\n// 文件名: Runoob.java\n \npackage com.runoob.test;\npublic class Runoob {\n      \n}\nclass Google {\n      \n}\n```\n\n+ 现在，我们用-d选项来编译这个文件，如下：\n\n> ```\n> $javac -d . Runoob.java\n> ```\n\n+ 这样会像下面这样放置编译了的文件：\n\n> ```\n> .\\com\\runoob\\test\\Runoob.class\n> .\\com\\runoob\\test\\Google.class\n> ```\n\n+ 你可以像下面这样来导入所有 **\\com\\runoob\\test\\** 中定义的类、接口等：\n\n> ```\n> import com.runoob.test.*;\n> ```\n\n+ 编译之后的 .class 文件应该和 .java 源文件一样，它们放置的目录应该跟包的名字对应起来。但是，并不要求 .class 文件的路径跟相应的 .java 的路径一样。你可以分开来安排源码和类的目录。\n\n> ```\n> <path-one>\\sources\\com\\runoob\\test\\Runoob.java\n> <path-two>\\classes\\com\\runoob\\test\\Google.class\n> ```\n\n这样，你可以将你的类目录分享给其他的编程人员，而不用透露自己的源码。用这种方法管理源码和类文件可以让编译器和java 虚拟机（JVM）可以找到你程序中使用的所有类型。\n\n类目录的绝对路径叫做 **class path**。设置在系统变量 **CLASSPATH** 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。\n\n<path- two>\\classes 是 class path，package 名字是 com.runoob.test,而编译器和 JVM 会在 <path-two>\\classes\\com\\runoob\\test 中找 .class 文件。\n\n一个 class path 可能会包含好几个路径，多路径应该用分隔符分开。默认情况下，编译器和 JVM 查找当前目录。JAR 文件按包含 Java 平台相关的类，所以他们的目录默认放在了 class path 中。\n\n### 8.5设置 CLASSPATH 系统变量\n\n就像安装JDK时设置系统变量一样用自己的包！！！","tags":["第一阶段"],"categories":["第一阶段"]},{"title":"Java基础语法","url":"/2020/12/26/基础语法/","content":"\n\n\n<!--more-->\n\n## Java 源程序与编译型运行区别\n\n![](./基础语法/1.png)\n\n## Java 对象和类\n\nJava作为一种面向对象语言。支持以下基本概念：\n\n- 多态\n- 继承\n- 封装\n- 抽象\n- 类\n- 对象\n- 实例\n- 方法\n- 重载\n\n### 对象和类的概念。\n\n- **对象**：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。\n- **类**：类是一个模板，它描述一类对象的行为和状态。\n\n### 一个类可以包含以下类型变量：\n\n- **局部变量**：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。\n- **成员变量**：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。\n- **类变量**：类变量也声明在类中，方法体之外，但必须声明为 static 类型。\n\n### 构造方法\n\n每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。\n\n在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。\n\n```java\npublic class Puppy{\n    public Puppy(){\n    }\n \n    public Puppy(String name){\n        // 这个构造器仅有一个参数：name\n    }\n}\n```\n\n### 源文件声明规则\n\n当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。\n\n- 一个源文件中只能有一个 public 类\n- 一个源文件可以有多个非 public 类\n- 源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。\n- 如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。\n- 如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。\n- import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。\n\n## Java 基本数据类型\n\n变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。\n\n内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。\n\n![](./基础语法/2.png)\n\n因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。\n\nJava 的两大数据类型:\n\n- 内置数据类型\n- 引用数据类型\n\n### 内置数据类型\n\nJava语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。\n\n**byte：**\n\n- byte 数据类型是8位、有符号的，以二进制补码表示的整数；\n- 最小值是 **-128（-2^7）**；\n- 最大值是 **127（2^7-1）**；\n- 默认值是 **0**；\n- byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；\n- 例子：byte a = 100，byte b = -50。\n\n**short：**\n\n- short 数据类型是 16 位、有符号的以二进制补码表示的整数\n- 最小值是 **-32768（-2^15）**；\n- 最大值是 **32767（2^15 - 1）**；\n- Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；\n- 默认值是 **0**；\n- 例子：short s = 1000，short r = -20000。\n\n**int：**\n\n- int 数据类型是32位、有符号的以二进制补码表示的整数；\n- 最小值是 **-2,147,483,648（-2^31）**；\n- 最大值是 **2,147,483,647（2^31 - 1）**；\n- 一般地整型变量默认为 int 类型；\n- 默认值是 **0** ；\n- 例子：int a = 100000, int b = -200000。\n\n**long：**\n\n- long 数据类型是 64 位、有符号的以二进制补码表示的整数；\n- 最小值是 **-9,223,372,036,854,775,808（-2^63）**；\n- 最大值是 **9,223,372,036,854,775,807（2^63 -1）**；\n- 这种类型主要使用在需要比较大整数的系统上；\n- 默认值是 **0L**；\n- 例子： long a = 100000L，Long b = -200000L。\n  \"L\"理论上不分大小写，但是若写成\"l\"容易与数字\"1\"混淆，不容易分辩。所以最好大写。\n\n**float：**\n\n- float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；\n- float 在储存大型浮点数组的时候可节省内存空间；\n- 默认值是 **0.0f**；\n- 浮点数不能用来表示精确的值，如货币；\n- 例子：float f1 = 234.5f。\n\n**double：**\n\n- double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；\n- 浮点数的默认类型为double类型；\n- double类型同样不能表示精确的值，如货币；\n- 默认值是 **0.0d**；\n- 例子：double d1 = 123.4。\n\n**boolean：**\n\n- boolean数据类型表示一位的信息；\n- 只有两个取值：true 和 false；\n- 这种类型只作为一种标志来记录 true/false 情况；\n- 默认值是 **false**；\n- 例子：boolean one = true。\n\n**char：**\n\n- char类型是一个单一的 16 位 Unicode 字符；\n- 最小值是 **\\u0000**（即为 0）；\n- 最大值是 **\\uffff**（即为65、535）；\n- char 数据类型可以储存任何字符；\n- 例子：char letter = 'A';。\n\n### 类型默认值\n\n|      **数据类型**      | **默认值** |\n| :--------------------: | :--------: |\n|          byte          |     0      |\n|         short          |     0      |\n|          int           |     0      |\n|          long          |     0L     |\n|         float          |    0.0f    |\n|         double         |    0.0d    |\n|          char          |  'u0000'   |\n| String (or any object) |    null    |\n|        boolean         |   false    |\n\n### 引用类型\n\n- 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型。变量一旦声明后，类型就不能被改变了。\n- 对象、数组都是引用数据类型。\n- 所有引用类型的默认值都是null。\n- 一个引用变量可以用来引用任何与之兼容的类型。\n- 例子：Site site = new Site(\"Runoob\")。\n\n### Java 常量\n\n常量在程序运行时是不能被修改的。\n\n在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：\n\n```\nfinal double PI = 3.1415927;\n```\n\n### 自动类型转换\n\n```\n低  ------------------------------------>  高\n\nbyte,short,char—> int —> long—> float —> double \n```\n\n数据类型转换必须满足如下规则：\n\n- 1. 不能对boolean类型进行类型转换。\n\n- 2. 不能把对象类型转换成不相关类的对象。\n\n- 3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。\n\n- 4. 转换过程中可能导致溢出或损失精度，例如：\n\n  ```\n  int i =128;   \n  byte b = (byte)i;\n  ```\n\n  因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。\n\n- 5. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：\n\n  ```\n  (int)23.7 == 23;        \n  (int)-45.89f == -45\n  ```\n\n#### 自动类型转换\n\n必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。\n\n#### 强制类型转换\n\n- 1. 条件是转换的数据类型必须是兼容的。\n- 2. 格式：(type)value type是要强制类型转换后的数据类型 实例：\n\n#### 隐含强制类型转换\n\n- 1. 整数的默认类型是 int。\n- 2. 浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f。\n\n## Java 变量类型\n\n- 类变量：独立于方法之外的变量，用 static 修饰。\n- 实例变量：独立于方法之外的变量，不过没有 static 修饰。\n- 局部变量：类的方法中的变量。\n\n![](基础语法/3.png)![](基础语法/4.png)\n\n### 实例变量\n\n- 实例变量声明在一个类中，但在方法、构造方法和语句块之外；\n- 当一个对象被实例化之后，每个实例变量的值就跟着确定；\n- 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；\n- 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；\n- 实例变量可以声明在使用前或者使用后；\n- 访问修饰符可以修饰实例变量；\n- 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；\n- 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；\n- 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。\n\n### 类变量（静态变量）\n\n- 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。\n- 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n- 静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。\n- 静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。\n- 静态变量在第一次被访问时创建，在程序结束时销毁。\n- 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。\n- 默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n- 静态变量可以通过：*ClassName.VariableName*的方式访问。\n- 类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。\n\n## Java 修饰符\n\n### 访问控制修饰符\n\nJava中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。\n\n- **default** (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。\n- **private** : 在同一类内可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**\n- **public** : 对所有类可见。使用对象：类、接口、变量、方法\n- **protected** : 对同一包内的类和所有子类可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**。\n\n我们可以通过以下表来说明访问权限：\n\n| 修饰符      | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包) | 其他包 |\n| :---------- | :----: | :------: | :------------: | :------------: | :----: |\n| `public`    |   Y    |    Y     |       Y        |       Y        |   Y    |\n| `protected` |   Y    |    Y     |       Y        |      Y/N       |   N    |\n| `default`   |   Y    |    Y     |       Y        |       N        |   N    |\n| `private`   |   Y    |    N     |       N        |       N        |   N    |\n\n#### 访问控制和继承\n\n- 父类中声明为 public 的方法在子类中也必须为 public。\n- 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。\n- 父类中声明为 private 的方法，不能够被继承。\n\n### 非访问修饰符\n\nstatic 修饰符，用来修饰类方法和类变量。\n\nfinal 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。\n\nabstract 修饰符，用来创建抽象类和抽象方法。\n\nsynchronized 和 volatile 修饰符，主要用于线程的编程。\n\n#### static 修饰符\n\n- **静态变量：**\n\n  static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。\n\n- **静态方法：**\n\n  static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。\n\n#### final 修饰符\n\n**final 变量：**\n\nfinal 表示\"最后的、最终的\"含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。\n\n**final 方法**\n\n父类中的 final 方法可以被子类继承，但是不能被子类重写。\n\n声明 final 方法的主要目的是防止该方法的内容被修改。\n\n**final 类**\n\nfinal 类不能被继承，没有类能够继承 final 类的任何特性。\n\n#### abstract 修饰符\n\n**抽象类：**\n\n抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。\n\n一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。\n\n**抽象方法**\n\n抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。\n\n抽象方法不能被声明成 final 和 static。\n\n任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。\n\n如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。\n\n抽象方法的声明以分号结尾，例如：**public abstract sample();**。\n\n#### synchronized 修饰符\n\nsynchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。\n\n#### transient 修饰符\n\n序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。\n\n该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。\n\n`public transient int limit = 55;   // 不会持久化 `\n\n`public int b; // 持久化`\n\n#### volatile 修饰符\n\nvolatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。\n\n一个 volatile 对象引用可能是 null。\n\n## Java 运算符\n\n### 算术运算符\n\n|  +   |     加法 - 相加运算符两侧的值     |           A + B 等于 30            |\n| :--: | :-------------------------------: | :--------------------------------: |\n|  -   |    减法 - 左操作数减去右操作数    |           A – B 等于 -10           |\n|  *   |     乘法 - 相乘操作符两侧的值     |            A * B等于200            |\n|  /   |    除法 - 左操作数除以右操作数    |            保留整数部分            |\n|  ％  | 取余 - 左操作数除以右操作数的余数 |              B%A等于0              |\n|  ++  |       自增: 操作数的值增加1       | B++ 或 ++B 等于 21（区别详见下文） |\n|  --  |       自减: 操作数的值减少1       | B-- 或 --B 等于 19（区别详见下文） |\n\n自增和自减前后缀区别：\n\n```cpp\nint i = 0;\nint x = ++i;//先+1再用\nint y = i++;//先用再加1\n//x=y=1,i=2\n```\n\n![](基础语法/5.png)![](基础语法/6.png)\n\n### 关系运算符\n\n| 运算符 |                             描述                             |       例子       |\n| :----: | :----------------------------------------------------------: | :--------------: |\n|   ==   |     检查如果两个操作数的值是否相等，如果相等则条件为真。     | （A == B）为假。 |\n|   !=   |   检查如果两个操作数的值是否相等，如果值不相等则条件为真。   | (A != B) 为真。  |\n|   >    |  检查左操作数的值是否大于右操作数的值，如果是那么条件为真。  |  （A> B）为假。  |\n|   <    |  检查左操作数的值是否小于右操作数的值，如果是那么条件为真。  |  （A <B）为真。  |\n|   >=   | 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 | （A> = B）为假。 |\n|   <=   | 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 | （A <= B）为真。 |\n\n### 位运算符\n\nJava定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。\n\n| 操作符 |                             描述                             |              例子              |\n| :----: | :----------------------------------------------------------: | :----------------------------: |\n|   ＆   |            如果相对应位都是1，则结果为1，否则为0             | （A＆B），得到12，即0000 1100  |\n|   \\|   |           如果相对应位都是 0，则结果为 0，否则为 1           | （A \\| B）得到61，即 0011 1101 |\n|   ^    |            如果相对应位值相同，则结果为0，否则为1            | （A ^ B）得到49，即 0011 0001  |\n|   〜   |     按位取反运算符翻转操作数的每一位，即0变成1，1变成0。     |  （〜A）得到-61，即1100 0011   |\n|   <<   |     按位左移运算符。左操作数按位左移右操作数指定的位数。     |  A << 2得到240，即 1111 0000   |\n|   >>   |     按位右移运算符。左操作数按位右移右操作数指定的位数。     |      A >> 2得到15即 1111       |\n|  >>>   | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 |     A>>>2得到15即0000 1111     |\n\n\\>> && \\>>>的区别\n\n![](基础语法/7.png)![](基础语法/8.png)\n\n前者高位补的是原来的值（即符号位）——算术右移（汇编中的概念）\n\n后者补0——逻辑右移（汇编中的概念）\n\n### 逻辑运算符\n\n| 操作符 |                             描述                             |        例子         |\n| :----: | :----------------------------------------------------------: | :-----------------: |\n|   &&   |   称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。   |  （A && B）为假。   |\n| \\| \\|  | 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 | （A \\| \\| B）为真。 |\n|   ！   | 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 | ！（A && B）为真。  |\n\n和C++，C一样也是短路计算，比如求a&&b，a，b均是表达式，当a的值为0，b的值就不会去计算。\n\n![](基础语法/9.png)\n\n输出a=0\n\n### 赋值运算符\n\n| 操作符  |                             描述                             |                   例子                   |\n| :-----: | :----------------------------------------------------------: | :--------------------------------------: |\n|    =    |        简单的赋值运算符，将右操作数的值赋给左侧操作数        |     C = A + B将把A + B得到的值赋给C      |\n|   + =   |   加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数   |          C + = A等价于C = C + A          |\n|   - =   |   减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数   |          C - = A等价于C = C - A          |\n|   * =   |   乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数   |          C * = A等价于C = C * A          |\n|   / =   |   除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数   | C / = A，C 与 A 同类型时等价于 C = C / A |\n| （％）= | 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 |           C％= A等价于C = C％A           |\n|  << =   |                       左移位赋值运算符                       |         C << = 2等价于C = C << 2         |\n|  >> =   |                       右移位赋值运算符                       |         C >> = 2等价于C = C >> 2         |\n|   ＆=   |                       按位与赋值运算符                       |           C＆= 2等价于C = C＆2           |\n|   ^ =   |                      按位异或赋值操作符                      |          C ^ = 2等价于C = C ^ 2          |\n|  \\| =   |                       按位或赋值操作符                       |         C \\| = 2等价于C = C \\| 2         |\n\n和C，C++一样\n\n### 条件运算符（?:）\n\n条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。\n\n```\nvariable x = (expression) ? value if true : value if false\n```\n\nC++中也有这种写法\n\n### instanceof 运算符\n\n该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。\n\n```\n( Object reference variable ) instanceof  (class/interface type)\n```\n\n如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。\n\n下面是一个例子：\n\n```\nString name = \"James\";\nboolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真\n```\n\n如果被比较的对象兼容于右侧类型,该运算符仍然返回true。\n\n```cpp\nclass Vehicle {}\n \npublic class Car extends Vehicle {\n   public static void main(String[] args){\n      Vehicle a = new Car();\n      boolean result =  a instanceof Car;\n      System.out.println( result);\n   }\n}\n```\n\n### Java运算符优先级\n\n|   类别   |                   操作符                   |  关联性  |\n| :------: | :----------------------------------------: | :------: |\n|   后缀   |             () [] . (点操作符)             |  左到右  |\n|   一元   |               expr++ expr--                | 从左到右 |\n|   一元   |          ++expr --expr + - ～ ！           | 从右到左 |\n|   乘性   |                   * /％                    |  左到右  |\n|   加性   |                    + -                     |  左到右  |\n|   移位   |                 >> >>>  <<                 |  左到右  |\n|   关系   |                 > >= < <=                  |  左到右  |\n|   相等   |                   == !=                    |  左到右  |\n|  按位与  |                     ＆                     |  左到右  |\n| 按位异或 |                     ^                      |  左到右  |\n|  按位或  |                     \\|                     |  左到右  |\n|  逻辑与  |                     &&                     |  左到右  |\n|  逻辑或  |                   \\| \\|                    |  左到右  |\n|   条件   |                    ？：                    | 从右到左 |\n|   赋值   | = + = - = * = / =％= >> = << =＆= ^ = \\| = | 从右到左 |\n|   逗号   |                     ，                     |  左到右  |\n\n关联性也就是C++中所谓的结合性\n\n## Java 循环结构 - for, while 及 do...while\n\n这块和C++几乎一样\n\n### while 循环\n\n```cpp\nwhile( 布尔表达式 ) {  //循环内容 }\n```\n\n### do…while 循环（至少执行一次循环）\n\n```cpp\ndo {\n       //代码语句\n}while(布尔表达式);\n```\n\n### for循环\n\n```cpp\nfor(初始化; 布尔表达式; 更新) {\n    //代码语句\n}\n```\n\n### Java 增强 for 循环（C++11也新增）\n\nC++中叫基于范围的循环，python中就是这种循环\n\n```cpp\nfor(声明语句 : 表达式)\n{\n   //代码句子\n}\n```\n\n**声明语句：**声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。\n\n**表达式：**表达式是要访问的数组名，或者是返回值为数组的方法。\n\n![](基础语法/10.png)![](基础语法/11.png)\n\n### break 关键字\n\nbreak 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。\n\nbreak 跳出最里层的循环，并且继续执行该循环下面的语句。\n\n### continue 关键字\n\ncontinue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。\n\n在 for 循环中，continue 语句使程序立即跳转到更新语句。\n\n在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。\n\n## Java 条件语句 - if...else\n\n### if\n\n\n\n语法：\n\n```cpp\nif(布尔表达式)\n{\n   //如果布尔表达式为true将执行的语句\n}\n```\n\n### if...else语句\n\n```cpp\nif(布尔表达式){\n   //如果布尔表达式的值为true\n}else{\n   //如果布尔表达式的值为false\n}\n```\n\n可嵌套，和C++一模一样\n\n## Java switch case 语句\n\nswitch case 语句语法格式如下：\n\n```java\nswitch(expression){\n    case value :\n       //语句\n       break; //可选\n    case value :\n       //语句\n       break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n       //语句\n}\n```\n\n## Java Number & Math 类\n\n一般地，当需要使用数字的时候，我们通常使用内置数据类型，如：**byte、int、long、double** 等。\n\n然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，Java 语言为每一个内置数据类型提供了对应的包装类。\n\n所有的包装类**（Integer、Long、Byte、Double、Float、Short）**都是抽象类 Number 的子类。\n\n|  包装类   | 基本数据类型 |\n| :-------: | :----------: |\n|  Boolean  |   boolean    |\n|   Byte    |     byte     |\n|   Short   |    short     |\n|  Integer  |     int      |\n|   Long    |     long     |\n| Character |     char     |\n|   Float   |    float     |\n|  Double   |    double    |\n\n![](基础语法/12.png)\n\n这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。\n\n```java\npublic class Test{\n \n   public static void main(String args[]){\n      Integer x = 5;\n      x =  x + 10;\n      System.out.println(x); \n   }\n}\n```\n\n当 x 被赋为整型值时，由于x是一个对象，所以编译器要对x进行装箱。然后，为了使x能进行加运算，所以要对x进行拆箱。\n\n## Java Math 类\n\nJava 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。\n\nMath 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。\n\n示例：\n\n```cpp\npublic class Test {  \n    public static void main (String []args)  \n    {  \n        System.out.println(\"90 度的正弦值：\" + Math.sin(Math.PI/2));  \n        System.out.println(\"0度的余弦值：\" + Math.cos(0));  \n        System.out.println(\"60度的正切值：\" + Math.tan(Math.PI/3));  \n        System.out.println(\"1的反正切值： \" + Math.atan(1));  \n        System.out.println(\"π/2的角度值：\" + Math.toDegrees(Math.PI/2));  \n        System.out.println(Math.PI);  \n    }  \n}\n```\n\n## Number & Math 类方法\n\n| 序号 | 方法与描述                                                   |\n| :--- | :----------------------------------------------------------- |\n| 1    | [xxxValue()](https://www.runoob.com/java/number-xxxvalue.html) 将 Number 对象转换为xxx数据类型的值并返回。 |\n| 2    | [compareTo()](https://www.runoob.com/java/number-compareto.html) 将number对象与参数比较。 |\n| 3    | [equals()](https://www.runoob.com/java/number-equals.html) 判断number对象是否与参数相等。 |\n| 4    | [valueOf()](https://www.runoob.com/java/number-valueof.html) 返回一个 Number 对象指定的内置数据类型 |\n| 5    | [toString()](https://www.runoob.com/java/number-tostring.html) 以字符串形式返回值。 |\n| 6    | [parseInt()](https://www.runoob.com/java/number-parseInt.html) 将字符串解析为int类型。 |\n| 7    | [abs()](https://www.runoob.com/java/number-abs.html) 返回参数的绝对值。 |\n| 8    | [ceil()](https://www.runoob.com/java/number-ceil.html) 返回大于等于( >= )给定参数的的最小整数，类型为双精度浮点型。 |\n| 9    | [floor()](https://www.runoob.com/java/number-floor.html) 返回小于等于（<=）给定参数的最大整数 。 |\n| 10   | [rint()](https://www.runoob.com/java/number-rint.html) 返回与参数最接近的整数。返回类型为double。 |\n| 11   | [round()](https://www.runoob.com/java/number-round.html) 它表示**四舍五入**，算法为 **Math.floor(x+0.5)**，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。 |\n| 12   | [min()](https://www.runoob.com/java/number-min.html) 返回两个参数中的最小值。 |\n| 13   | [max()](https://www.runoob.com/java/number-max.html) 返回两个参数中的最大值。 |\n| 14   | [exp()](https://www.runoob.com/java/number-exp.html) 返回自然数底数e的参数次方。 |\n| 15   | [log()](https://www.runoob.com/java/number-log.html) 返回参数的自然数底数的对数值。 |\n| 16   | [pow()](https://www.runoob.com/java/number-pow.html) 返回第一个参数的第二个参数次方。 |\n| 17   | [sqrt()](https://www.runoob.com/java/number-sqrt.html) 求参数的算术平方根。 |\n| 18   | [sin()](https://www.runoob.com/java/number-sin.html) 求指定double类型参数的正弦值。 |\n| 19   | [cos()](https://www.runoob.com/java/number-cos.html) 求指定double类型参数的余弦值。 |\n| 20   | [tan()](https://www.runoob.com/java/number-tan.html) 求指定double类型参数的正切值。 |\n| 21   | [asin()](https://www.runoob.com/java/number-asin.html) 求指定double类型参数的反正弦值。 |\n| 22   | [acos()](https://www.runoob.com/java/number-acos.html) 求指定double类型参数的反余弦值。 |\n| 23   | [atan()](https://www.runoob.com/java/number-atan.html) 求指定double类型参数的反正切值。 |\n| 24   | [atan2()](https://www.runoob.com/java/number-atan2.html) 将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。 |\n| 25   | [toDegrees()](https://www.runoob.com/java/number-todegrees.html) 将参数转化为角度。 |\n| 26   | [toRadians()](https://www.runoob.com/java/number-toradians.html) 将角度转换为弧度。 |\n| 27   | [random()](https://www.runoob.com/java/number-random.html) 返回一个随机数。 |\n\n## Java Character 类\n\nCharacter 类用于对单个字符进行操作。\n\nCharacter 类在对象中包装一个基本类型 **char** 的值\n\n### 转义序列\n\n| 转义序列 |           描述           |\n| :------: | :----------------------: |\n|    \\t    | 在文中该处插入一个tab键  |\n|    \\b    | 在文中该处插入一个后退键 |\n|    \\n    |      在文中该处换行      |\n|    \\r    |    在文中该处插入回车    |\n|    \\f    |   在文中该处插入换页符   |\n|    \\'    |   在文中该处插入单引号   |\n|    \\\"    |   在文中该处插入双引号   |\n|    \\\\    |   在文中该处插入反斜杠   |\n\n### Character 方法\n\nC++中是cctype头文件中的方法。\n\n| 序号 | 方法与描述                                      |\n| :--- | :---------------------------------------------- |\n| 1    | isLetter() 是否是一个字母                       |\n| 2    | isDigit()是否是一个数字字符                     |\n| 3    | isWhitespace()是否是一个空白字符                |\n| 4    | isUpperCase() 是否是大写字母                    |\n| 5    | isLowerCase()是否是小写字母                     |\n| 6    | toUpperCase() 指定字母的大写形式                |\n| 7    | toLowerCase() 指定字母的小写形式                |\n| 8    | toString返回字符的字符串形式，字符串的长度仅为1 |\n\n## Java String 类\n\n字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。\n\n### 创建字符串\n\nString 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：\n\n```java\nString s1 = \"Runoob\";              // String 直接创建\nString s2 = \"Runoob\";              // String 直接创建\nString s3 = s1;                    // 相同引用\nString s4 = new String(\"Runoob\");   // String 对象创建\nString s5 = new String(\"Runoob\");   // String 对象创建\n```\n\n![](基础语法/13.png)\n\n### 字符串长度\n\nString 类的一个访问器方法是 length() 方法，它返回字符串对象包含的字符数。\n\n！！！没有size方法，C++STL中有size和length\n\n### 连接字符串\n\nString 类提供了连接两个字符串的方法：\n\n+ 返回 string2 连接 string1 的新字符串。也可以对字符串常量使用 concat() 方法，如：\n\n+ 更常用的是使用'+'操作符来连接字符串\n\n![](基础语法/14.png)![](基础语法/15.png)\n\n### 创建格式化字符串\n\n我们知道输出格式化数字可以使用 printf() 和 format() 方法。\n\nString 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。\n\nString 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。\n\n### String 方法\n\n参看 [Java String API](https://www.runoob.com/manual/jdk1.6/java/lang/String.html) 文档:\n\n## Java StringBuffer 和 StringBuilder 类\n\n当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。\n\n和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。\n\n![](基础语法/16.png)\n\n在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。\n\nStringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。\n\n由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。\n\n![](基础语法/17.png)\n\n然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。\n\n### StringBuffer 方法\n\n| 序号 |                           方法描述                           |\n| :--: | :----------------------------------------------------------: |\n|  1   |                int capacity() 返回当前容量。                 |\n|  2   | char charAt(int index) 返回此序列中指定索引处的 `char` 值。  |\n|  3   | void ensureCapacity(int minimumCapacity) 确保容量至少等于指定的最小值。 |\n|  4   | void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 `dst`。 |\n|  5   | int indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。 |\n|  6   | int indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。 |\n|  7   | int lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。 |\n|  8   | int lastIndexOf(String str, int fromIndex) 返回 String 对象中子字符串最后出现的位置。 |\n|  9   |              int length()  返回长度（字符数）。              |\n|  10  | void setCharAt(int index, char ch) 将给定索引处的字符设置为 `ch`。 |\n|  11  |      void setLength(int newLength) 设置字符序列的长度。      |\n|  12  | CharSequence subSequence(int start, int end) 返回一个新的字符序列，该字符序列是此序列的子序列。 |\n|  13  | String substring(int start) 返回一个新的 `String`，它包含此字符序列当前所包含的字符子序列。 |\n|  14  | String substring(int start, int end) 返回一个新的 `String`，它包含此序列当前所包含的字符子序列。 |\n|  15  |     String toString() 返回此序列中数据的字符串表示形式。     |\n\n## Java 数组\n\n### 声明数组变量\n\n```cpp\ndataType[] arrayRefVar;   // 首选的方法\n \n或\n \ndataType arrayRefVar[];  // 效果相同，但不是首选方法 \n//dataType arrayRefVar[] 风格是来自 C/C++ 语言 ，在Java中采用是为了让 C/C++ 程序员能够快速理解java语言。\n```\n\n### 创建数组\n\nJava语言使用new操作符来创建数组，语法如下：\n\n`arrayRefVar = new dataType[arraySize];`\n\n上面的语法语句做了两件事：\n\n- 一、使用 dataType[arraySize] 创建了一个数组。\n- 二、把新创建的数组的引用赋值给变量 arrayRefVar。\n\n可以理解成返回的是指针，C/C++中就有这种概念。\n\n### 数组作为函数的参数\n\n```cpp\npublic static void printArray(int[] array) {\n  for (int i = 0; i < array.length; i++) {\n    System.out.print(array[i] + \" \");\n  }\n}\n```\n\n### 数组作为函数的返回值\n\n```cpp\npublic static int[] reverse(int[] list) {\n  int[] result = new int[list.length];\n \n  for (int i = 0, j = result.length - 1; i < list.length; i++, j--) {\n    result[j] = list[i];\n  }\n  return result;\n}\n```\n\n实际本质是在堆申请内存空间之后，返回的是引用，也就是数组在堆内存中的位置。\n\n### 多维数组\n\n多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组，例如：\n\n`String str[][] = new String[3][4];`\n\n### Arrays 类\n\njava.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。\n\n具有以下功能：\n\n- 给数组赋值：通过 fill 方法。\n- 对数组排序：通过 sort 方法,按升序。\n- 比较数组：通过 equals 方法比较数组中元素值是否相等。\n- 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。\n\n| 序号 | 方法和说明                                                   |\n| :--: | :----------------------------------------------------------- |\n|  1   | **public static int binarySearch(Object[] a, Object key)** 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(*插入点*) - 1)。 |\n|  2   | **public static boolean equals(long[] a, long[] a2)** 如果两个指定的 long 型数组彼此*相等*，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |\n|  3   | **public static void fill(int[] a, int val)** 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |\n|  4   | **public static void sort(Object[] a)** 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |\n\n## Java 日期时间\n\njava.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。\n\n第一个构造函数使用当前日期和时间来初始化对象。\n\n第一个构造函数使用当前日期和时间来初始化对象。`Date( )`\n\n第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。`Date(long millisec)`\n\n| 序号 | 方法和描述                                                   |\n| :--- | :----------------------------------------------------------- |\n| 1    | **boolean after(Date date)** 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。 |\n| 2    | **boolean before(Date date)** 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。 |\n| 3    | **Object clone( )** 返回此对象的副本。                       |\n| 4    | **int compareTo(Date date)** 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。 |\n| 5    | **int compareTo(Object obj)** 若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。 |\n| 6    | **boolean equals(Object date)** 当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。 |\n| 7    | **long getTime( )** 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 |\n| 8    | **int hashCode( )**  返回此对象的哈希码值。                  |\n| 9    | **void setTime(long time)**   用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。 |\n| 10   | **String toString( )** 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。 |\n\n### 获取当前日期时间\n\n![](基础语法/18.png)![](基础语法/19.png)\n\n### 日期比较\n\nJava使用以下三种方法来比较两个日期：\n\n- 使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。\n- 使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。\n- 使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。\n\n### 使用 SimpleDateFormat 格式化日期\n\nSimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如：\n\n`SimpleDateFormat ft = new SimpleDateFormat (\"yyyy-MM-dd hh:mm:ss\");`\n\n这一行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。\n\n**注意**:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。\n\n![](基础语法/20.png)![](基础语法/21.png)\n\n### 解析字符串为时间\n\nSimpleDateFormat 类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat 对象的格式化存储来解析字符串。例如：\n\n```java\nimport java.util.*;\nimport java.text.*;\n  \npublic class DateDemo {\n \n   public static void main(String args[]) {\n      SimpleDateFormat ft = new SimpleDateFormat (\"yyyy-MM-dd\"); \n \n      String input = args.length == 0 ? \"1818-11-11\" : args[0]; \n \n      System.out.print(input + \" Parses as \"); \n \n      Date t; \n \n      try { \n          t = ft.parse(input); \n          System.out.println(t); \n      } catch (ParseException e) { \n          System.out.println(\"Unparseable using \" + ft); \n      }\n   }\n}\n```\n\n### Java 休眠(sleep)\n\nsleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。\n\n你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。\n\n### Calendar类\n\n我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用Calendar 类。\n\nCalendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。\n\nCalendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。\n\n### GregorianCalendar类\n\nCalendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。\n\nCalendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。\n\n## Java 正则表达式\n\nava 正则表达式和 Perl 的是最为相似的。\n\njava.util.regex 包主要包括以下三个类：\n\n- Pattern 类：\n\n  pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。\n\n- Matcher 类：\n\n  Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。\n\n- PatternSyntaxException：\n\n  PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。\n\n  \n\n## Java 方法\n\n### 方法的定义\n\n```java\n修饰符 返回值类型 方法名(参数类型 参数名){\n    ...\n    方法体\n    ...\n    return 返回值;\n}\n```\n\n- **修饰符：**修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。\n- **返回值类型 ：**方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字**void**。\n- **方法名：**是方法的实际名称。方法名和参数表共同构成方法签名。\n- **参数类型：**参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。\n- **方法体：**方法体包含具体的语句，定义该方法的功能。\n\n### 方法的重载\n\n就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。\n\nJava编译器根据方法签名判断哪个方法应该被调用。\n\n方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。\n\n重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。\n\n### 构造方法\n\n当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。\n\n不管你是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，默认构造方法的访问修改符和类的访问修改符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。\n\n一旦你定义了自己的构造方法，默认构造方法就会失效。\n\n### 可变参数\n\nJDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。\n\n方法的可变参数的声明如下所示：\n\n`typeName... parameterName`\n\n在方法声明中，在指定参数类型后加一个省略号(...) 。\n\n一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。\n\n### finalize() 方法\n\nJava 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。\n\n例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。\n\n在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。\n\nfinalize() 一般格式是：\n\n```java\nprotected void finalize()\n{\n   // 在这里终结代码\n}\n```\n\n关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。\n\n当然，Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法。\n\n## Java 流(Stream)、文件(File)和IO\n\n### 读取控制台输入\n\nJava 的控制台输入由 System.in 完成。\n\n为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。\n\n下面是创建 BufferedReader 的基本语法：\n\n```java\nBufferedReader br = new BufferedReader(new \n                      InputStreamReader(System.in));\n```\n\nBufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。\n\n### 读写文件\n\n如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。\n\n下图是一个描述输入流和输出流的类层次图。\n\n![](基础语法/22.png)\n\n### FileInputStream\n\n该流用于从文件读取数据，它的对象可以用关键字 new 来创建。\n\n有多种构造方法可用来创建对象。\n\n可以使用字符串类型的文件名来创建一个输入流对象来读取文件：\n\n```\nInputStream f = new FileInputStream(\"C:/java/hello\");\n```\n\n也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：\n\n```\nFile f = new File(\"C:/java/hello\"); InputStream out = new FileInputStream(f);\n```\n\n| **序号** | **方法及描述**                                               |\n| :------- | :----------------------------------------------------------- |\n| 1        | **public void close() throws IOException{}** 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。 |\n| 2        | **protected void finalize()throws IOException {}** 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。 |\n| 3        | **public int read(int r)throws IOException{}** 这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。 |\n| 4        | **public int read(byte[] r) throws IOException{}** 这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。 |\n| 5        | **public int available() throws IOException{}** 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。 |\n\n### FileOutputStream\n\n该类用来创建一个文件并向文件中写数据。\n\n如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。\n\n有两个构造方法可以用来创建 FileOutputStream 对象。\n\n使用字符串类型的文件名来创建一个输出流对象：\n\n```\nOutputStream f = new FileOutputStream(\"C:/java/hello\")\n```\n\n也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：\n\n```\nFile f = new File(\"C:/java/hello\"); OutputStream f = new FileOutputStream(f);\n```\n\n### Java中的目录\n\n#### 创建目录：\n\nFile类中有两个方法可以用来创建文件夹：\n\n- **mkdir( )**方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。\n- **mkdirs()**方法创建一个文件夹和它的所有父文件夹。\n\n### 读取目录\n\n一个目录其实就是一个 File 对象，它包含其他文件和文件夹。\n\n如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。\n\n可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。\n\n删除文件可以使用 **java.io.File.delete()** 方法。\n\n### 删除目录或文件\n\n需要注意的是当删除某一目录时，必须保证该目录下没有其他文件才能正确删除，否则将删除失败。\n\n## Java Scanner 类\n\njava.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。\n\n下面是创建 Scanner 对象的基本语法：\n\n```\nScanner s = new Scanner(System.in);\n```\n\n通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据：\n\n#### next() 与 nextLine() 区别\n\nnext():\n\n- 1、一定要读取到有效字符后才可以结束输入。\n- 2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。\n- 3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。\n- next() 不能得到带有空格的字符串。\n\nnextLine()：\n\n- 1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。\n- 2、可以获得空白。\n\n## Java 异常处理\n\n异常发生的原因有很多，通常包含以下几大类：\n\n- 用户输入了非法数据。\n- 要打开的文件不存在。\n- 网络通信时连接中断，或者JVM内存溢出。\n\n这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。-\n\n要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：\n\n- **检查性异常：**最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。\n- **运行时异常：** 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。\n- **错误：** 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。\n\n### Exception 类的层次\n\n所有的异常类是从 java.lang.Exception 类继承的子类。\n\nException 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。\n\nJava 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。\n\nError 用来指示运行时环境发生的错误。\n\n例如，JVM 内存溢出。一般地，程序不会从错误中恢复。\n\n异常类有两个主要的子类：IOException 类和 RuntimeException 类。\n\n![](基础语法/23.jpg)\n\n### Java 内置异常类\n\nJava 语言定义了一些异常类在 java.lang 标准包中。\n\n标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。\n\nJava 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常。\n\n### 异常方法\n\n下面的列表是 Throwable 类的主要方法:\n\n| **序号** | **方法及说明**                                               |\n| :------- | :----------------------------------------------------------- |\n| 1        | **public String getMessage()** 返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。 |\n| 2        | **public Throwable getCause()** 返回一个Throwable 对象代表异常原因。 |\n| 3        | **public String toString()** 使用getMessage()的结果返回类的串级名字。 |\n| 4        | **public void printStackTrace()** 打印toString()结果和栈层次到System.err，即错误输出流。 |\n| 5        | **public StackTraceElement [] getStackTrace()** 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。 |\n| 6        | **public Throwable fillInStackTrace()** 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。 |\n\n### 捕获异常\n\n使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。\n\ntry/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：\n\n```\ntry\n{\n   // 程序代码\n}catch(ExceptionName e1)\n{\n   //Catch 块\n}\n```\n\n### 多重捕获块\n\n一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。\n\n```java\ntry{\n   // 程序代码\n}catch(异常类型1 异常的变量名1){\n  // 程序代码\n}catch(异常类型2 异常的变量名2){\n  // 程序代码\n}catch(异常类型3 异常的变量名3){\n  // 程序代码\n}\n```\n\n### throws/throw 关键字：\n\n如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。\n\n也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。\n\n下面方法的声明抛出一个 RemoteException 异常：\n\n```java\nimport java.io.*;\npublic class className\n{\n  public void deposit(double amount) throws RemoteException\n  {\n    // Method implementation\n    throw new RemoteException();\n  }\n  //Remainder of class definition\n}\n```\n\n下面的例子中声明有两个元素的一个数组，当代码试图访问数组的第三个元素的时候就会抛出一个异常。\n\n### finally关键字\n\nfinally 关键字用来创建在 try 代码块后面执行的代码块。\n\n无论是否发生异常，finally 代码块中的代码总会被执行。\n\n在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。\n\nfinally 代码块出现在 catch 代码块最后，语法如下:\n\n```java\ntry{\n  // 程序代码\n}catch(异常类型1 异常的变量名1){\n  // 程序代码\n}catch(异常类型2 异常的变量名2){\n  // 程序代码\n}finally{\n  // 程序代码\n}\n```\n\n- catch 不能独立于 try 存在。\n- 在 try/catch 后面添加 finally 块并非强制性要求的。\n- try 代码后不能既没 catch 块也没 finally 块。\n- try, catch, finally 块之间不能添加任何代码。\n\n### 声明自定义异常\n\n在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。\n\n- 所有异常都必须是 Throwable 的子类。\n- 如果希望写一个检查性异常类，则需要继承 Exception 类。\n- 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。\n\n### 通用异常\n\n在Java中定义了两种类型的异常和错误。\n\n- **JVM(Java****虚拟机****)** **异常：**由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。\n- **程序级异常：**由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。","tags":["第一阶段"],"categories":["第一阶段"]}]