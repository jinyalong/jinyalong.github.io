[{"title":"Java基础语法","url":"/2020/12/26/基础语法/","content":"\n\n\n<!--more-->\n\n# Java 源程序与编译型运行区别\n\n![](./基础语法/1.png)\n\n# Java 对象和类\n\nJava作为一种面向对象语言。支持以下基本概念：\n\n- 多态\n- 继承\n- 封装\n- 抽象\n- 类\n- 对象\n- 实例\n- 方法\n- 重载\n\n## 对象和类的概念。\n\n- **对象**：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。\n- **类**：类是一个模板，它描述一类对象的行为和状态。\n\n## 一个类可以包含以下类型变量：\n\n- **局部变量**：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。\n- **成员变量**：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。\n- **类变量**：类变量也声明在类中，方法体之外，但必须声明为 static 类型。\n\n## 构造方法\n\n每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。\n\n在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。\n\n```java\npublic class Puppy{\n    public Puppy(){\n    }\n \n    public Puppy(String name){\n        // 这个构造器仅有一个参数：name\n    }\n}\n```\n\n## 源文件声明规则\n\n当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。\n\n- 一个源文件中只能有一个 public 类\n- 一个源文件可以有多个非 public 类\n- 源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。\n- 如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。\n- 如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。\n- import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。\n\n# Java 基本数据类型\n\n变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。\n\n内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。\n\n![](./基础语法/2.png)\n\n因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。\n\nJava 的两大数据类型:\n\n- 内置数据类型\n- 引用数据类型\n\n## 内置数据类型\n\nJava语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。\n\n**byte：**\n\n- byte 数据类型是8位、有符号的，以二进制补码表示的整数；\n- 最小值是 **-128（-2^7）**；\n- 最大值是 **127（2^7-1）**；\n- 默认值是 **0**；\n- byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；\n- 例子：byte a = 100，byte b = -50。\n\n**short：**\n\n- short 数据类型是 16 位、有符号的以二进制补码表示的整数\n- 最小值是 **-32768（-2^15）**；\n- 最大值是 **32767（2^15 - 1）**；\n- Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；\n- 默认值是 **0**；\n- 例子：short s = 1000，short r = -20000。\n\n**int：**\n\n- int 数据类型是32位、有符号的以二进制补码表示的整数；\n- 最小值是 **-2,147,483,648（-2^31）**；\n- 最大值是 **2,147,483,647（2^31 - 1）**；\n- 一般地整型变量默认为 int 类型；\n- 默认值是 **0** ；\n- 例子：int a = 100000, int b = -200000。\n\n**long：**\n\n- long 数据类型是 64 位、有符号的以二进制补码表示的整数；\n- 最小值是 **-9,223,372,036,854,775,808（-2^63）**；\n- 最大值是 **9,223,372,036,854,775,807（2^63 -1）**；\n- 这种类型主要使用在需要比较大整数的系统上；\n- 默认值是 **0L**；\n- 例子： long a = 100000L，Long b = -200000L。\n  \"L\"理论上不分大小写，但是若写成\"l\"容易与数字\"1\"混淆，不容易分辩。所以最好大写。\n\n**float：**\n\n- float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；\n- float 在储存大型浮点数组的时候可节省内存空间；\n- 默认值是 **0.0f**；\n- 浮点数不能用来表示精确的值，如货币；\n- 例子：float f1 = 234.5f。\n\n**double：**\n\n- double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；\n- 浮点数的默认类型为double类型；\n- double类型同样不能表示精确的值，如货币；\n- 默认值是 **0.0d**；\n- 例子：double d1 = 123.4。\n\n**boolean：**\n\n- boolean数据类型表示一位的信息；\n- 只有两个取值：true 和 false；\n- 这种类型只作为一种标志来记录 true/false 情况；\n- 默认值是 **false**；\n- 例子：boolean one = true。\n\n**char：**\n\n- char类型是一个单一的 16 位 Unicode 字符；\n- 最小值是 **\\u0000**（即为 0）；\n- 最大值是 **\\uffff**（即为65、535）；\n- char 数据类型可以储存任何字符；\n- 例子：char letter = 'A';。\n\n## 类型默认值\n\n|      **数据类型**      | **默认值** |\n| :--------------------: | :--------: |\n|          byte          |     0      |\n|         short          |     0      |\n|          int           |     0      |\n|          long          |     0L     |\n|         float          |    0.0f    |\n|         double         |    0.0d    |\n|          char          |  'u0000'   |\n| String (or any object) |    null    |\n|        boolean         |   false    |\n\n## 引用类型\n\n- 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型。变量一旦声明后，类型就不能被改变了。\n- 对象、数组都是引用数据类型。\n- 所有引用类型的默认值都是null。\n- 一个引用变量可以用来引用任何与之兼容的类型。\n- 例子：Site site = new Site(\"Runoob\")。\n\n## Java 常量\n\n常量在程序运行时是不能被修改的。\n\n在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：\n\n```\nfinal double PI = 3.1415927;\n```\n\n## 自动类型转换\n\n```\n低  ------------------------------------>  高\n\nbyte,short,char—> int —> long—> float —> double \n```\n\n数据类型转换必须满足如下规则：\n\n- 1. 不能对boolean类型进行类型转换。\n\n- 2. 不能把对象类型转换成不相关类的对象。\n\n- 3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。\n\n- 4. 转换过程中可能导致溢出或损失精度，例如：\n\n  ```\n  int i =128;   \n  byte b = (byte)i;\n  ```\n\n  因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。\n\n- 5. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：\n\n  ```\n  (int)23.7 == 23;        \n  (int)-45.89f == -45\n  ```\n\n### 自动类型转换\n\n必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。\n\n### 强制类型转换\n\n- 1. 条件是转换的数据类型必须是兼容的。\n- 2. 格式：(type)value type是要强制类型转换后的数据类型 实例：\n\n### 隐含强制类型转换\n\n- 1. 整数的默认类型是 int。\n- 2. 浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f。\n\n# Java 变量类型\n\n- 类变量：独立于方法之外的变量，用 static 修饰。\n- 实例变量：独立于方法之外的变量，不过没有 static 修饰。\n- 局部变量：类的方法中的变量。\n\n![](基础语法/3.png)![](基础语法/4.png)\n\n## 实例变量\n\n- 实例变量声明在一个类中，但在方法、构造方法和语句块之外；\n- 当一个对象被实例化之后，每个实例变量的值就跟着确定；\n- 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；\n- 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；\n- 实例变量可以声明在使用前或者使用后；\n- 访问修饰符可以修饰实例变量；\n- 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；\n- 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；\n- 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。\n\n## 类变量（静态变量）\n\n- 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。\n- 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n- 静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。\n- 静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。\n- 静态变量在第一次被访问时创建，在程序结束时销毁。\n- 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。\n- 默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n- 静态变量可以通过：*ClassName.VariableName*的方式访问。\n- 类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。\n\n# Java 修饰符\n\n## 访问控制修饰符\n\nJava中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。\n\n- **default** (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。\n- **private** : 在同一类内可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**\n- **public** : 对所有类可见。使用对象：类、接口、变量、方法\n- **protected** : 对同一包内的类和所有子类可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**。\n\n我们可以通过以下表来说明访问权限：\n\n| 修饰符      | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包) | 其他包 |\n| :---------- | :----: | :------: | :------------: | :------------: | :----: |\n| `public`    |   Y    |    Y     |       Y        |       Y        |   Y    |\n| `protected` |   Y    |    Y     |       Y        |      Y/N       |   N    |\n| `default`   |   Y    |    Y     |       Y        |       N        |   N    |\n| `private`   |   Y    |    N     |       N        |       N        |   N    |\n\n### 访问控制和继承\n\n- 父类中声明为 public 的方法在子类中也必须为 public。\n- 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。\n- 父类中声明为 private 的方法，不能够被继承。\n\n## 非访问修饰符\n\nstatic 修饰符，用来修饰类方法和类变量。\n\nfinal 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。\n\nabstract 修饰符，用来创建抽象类和抽象方法。\n\nsynchronized 和 volatile 修饰符，主要用于线程的编程。\n\n### static 修饰符\n\n- **静态变量：**\n\n  static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。\n\n- **静态方法：**\n\n  static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。\n\n### final 修饰符\n\n**final 变量：**\n\nfinal 表示\"最后的、最终的\"含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。\n\n**final 方法**\n\n父类中的 final 方法可以被子类继承，但是不能被子类重写。\n\n声明 final 方法的主要目的是防止该方法的内容被修改。\n\n**final 类**\n\nfinal 类不能被继承，没有类能够继承 final 类的任何特性。\n\n### abstract 修饰符\n\n**抽象类：**\n\n抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。\n\n一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。\n\n**抽象方法**\n\n抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。\n\n抽象方法不能被声明成 final 和 static。\n\n任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。\n\n如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。\n\n抽象方法的声明以分号结尾，例如：**public abstract sample();**。\n\n### synchronized 修饰符\n\nsynchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。\n\n### transient 修饰符\n\n序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。\n\n该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。\n\n`public transient int limit = 55;   // 不会持久化 `\n\n`public int b; // 持久化`\n\n### volatile 修饰符\n\nvolatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。\n\n一个 volatile 对象引用可能是 null。\n\n# Java 运算符\n\n## 算术运算符\n\n|  +   |     加法 - 相加运算符两侧的值     |           A + B 等于 30            |\n| :--: | :-------------------------------: | :--------------------------------: |\n|  -   |    减法 - 左操作数减去右操作数    |           A – B 等于 -10           |\n|  *   |     乘法 - 相乘操作符两侧的值     |            A * B等于200            |\n|  /   |    除法 - 左操作数除以右操作数    |            保留整数部分            |\n|  ％  | 取余 - 左操作数除以右操作数的余数 |              B%A等于0              |\n|  ++  |       自增: 操作数的值增加1       | B++ 或 ++B 等于 21（区别详见下文） |\n|  --  |       自减: 操作数的值减少1       | B-- 或 --B 等于 19（区别详见下文） |\n\n自增和自减前后缀区别：\n\n```cpp\nint i = 0;\nint x = ++i;//先+1再用\nint y = i++;//先用再加1\n//x=y=1,i=2\n```\n\n![](基础语法/5.png)![](基础语法/6.png)\n\n## 关系运算符\n\n| 运算符 |                             描述                             |       例子       |\n| :----: | :----------------------------------------------------------: | :--------------: |\n|   ==   |     检查如果两个操作数的值是否相等，如果相等则条件为真。     | （A == B）为假。 |\n|   !=   |   检查如果两个操作数的值是否相等，如果值不相等则条件为真。   | (A != B) 为真。  |\n|   >    |  检查左操作数的值是否大于右操作数的值，如果是那么条件为真。  |  （A> B）为假。  |\n|   <    |  检查左操作数的值是否小于右操作数的值，如果是那么条件为真。  |  （A <B）为真。  |\n|   >=   | 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 | （A> = B）为假。 |\n|   <=   | 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 | （A <= B）为真。 |\n\n## 位运算符\n\nJava定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。\n\n| 操作符 |                             描述                             |              例子              |\n| :----: | :----------------------------------------------------------: | :----------------------------: |\n|   ＆   |            如果相对应位都是1，则结果为1，否则为0             | （A＆B），得到12，即0000 1100  |\n|   \\|   |           如果相对应位都是 0，则结果为 0，否则为 1           | （A \\| B）得到61，即 0011 1101 |\n|   ^    |            如果相对应位值相同，则结果为0，否则为1            | （A ^ B）得到49，即 0011 0001  |\n|   〜   |     按位取反运算符翻转操作数的每一位，即0变成1，1变成0。     |  （〜A）得到-61，即1100 0011   |\n|   <<   |     按位左移运算符。左操作数按位左移右操作数指定的位数。     |  A << 2得到240，即 1111 0000   |\n|   >>   |     按位右移运算符。左操作数按位右移右操作数指定的位数。     |      A >> 2得到15即 1111       |\n|  >>>   | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 |     A>>>2得到15即0000 1111     |\n\n\\>> && \\>>>的区别\n\n![](基础语法/7.png)![](基础语法/8.png)\n\n前者高位补的是原来的值（即符号位）——算术右移（汇编中的概念）\n\n后者补0——逻辑右移（汇编中的概念）\n\n## 逻辑运算符\n\n| 操作符 |                             描述                             |        例子         |\n| :----: | :----------------------------------------------------------: | :-----------------: |\n|   &&   |   称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。   |  （A && B）为假。   |\n| \\| \\|  | 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 | （A \\| \\| B）为真。 |\n|   ！   | 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 | ！（A && B）为真。  |\n\n和C++，C一样也是短路计算，比如求a&&b，a，b均是表达式，当a的值为0，b的值就不会去计算。\n\n![](基础语法/9.png)\n\n输出a=0\n\n## 赋值运算符\n\n| 操作符  |                             描述                             |                   例子                   |\n| :-----: | :----------------------------------------------------------: | :--------------------------------------: |\n|    =    |        简单的赋值运算符，将右操作数的值赋给左侧操作数        |     C = A + B将把A + B得到的值赋给C      |\n|   + =   |   加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数   |          C + = A等价于C = C + A          |\n|   - =   |   减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数   |          C - = A等价于C = C - A          |\n|   * =   |   乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数   |          C * = A等价于C = C * A          |\n|   / =   |   除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数   | C / = A，C 与 A 同类型时等价于 C = C / A |\n| （％）= | 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 |           C％= A等价于C = C％A           |\n|  << =   |                       左移位赋值运算符                       |         C << = 2等价于C = C << 2         |\n|  >> =   |                       右移位赋值运算符                       |         C >> = 2等价于C = C >> 2         |\n|   ＆=   |                       按位与赋值运算符                       |           C＆= 2等价于C = C＆2           |\n|   ^ =   |                      按位异或赋值操作符                      |          C ^ = 2等价于C = C ^ 2          |\n|  \\| =   |                       按位或赋值操作符                       |         C \\| = 2等价于C = C \\| 2         |\n\n和C，C++一样\n\n## 条件运算符（?:）\n\n条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。\n\n```\nvariable x = (expression) ? value if true : value if false\n```\n\nC++中也有这种写法\n\n## instanceof 运算符\n\n该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。\n\n```\n( Object reference variable ) instanceof  (class/interface type)\n```\n\n如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。\n\n下面是一个例子：\n\n```\nString name = \"James\";\nboolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真\n```\n\n如果被比较的对象兼容于右侧类型,该运算符仍然返回true。\n\n```cpp\nclass Vehicle {}\n \npublic class Car extends Vehicle {\n   public static void main(String[] args){\n      Vehicle a = new Car();\n      boolean result =  a instanceof Car;\n      System.out.println( result);\n   }\n}\n```\n\n## Java运算符优先级\n\n|   类别   |                   操作符                   |  关联性  |\n| :------: | :----------------------------------------: | :------: |\n|   后缀   |             () [] . (点操作符)             |  左到右  |\n|   一元   |               expr++ expr--                | 从左到右 |\n|   一元   |          ++expr --expr + - ～ ！           | 从右到左 |\n|   乘性   |                   * /％                    |  左到右  |\n|   加性   |                    + -                     |  左到右  |\n|   移位   |                 >> >>>  <<                 |  左到右  |\n|   关系   |                 > >= < <=                  |  左到右  |\n|   相等   |                   == !=                    |  左到右  |\n|  按位与  |                     ＆                     |  左到右  |\n| 按位异或 |                     ^                      |  左到右  |\n|  按位或  |                     \\|                     |  左到右  |\n|  逻辑与  |                     &&                     |  左到右  |\n|  逻辑或  |                   \\| \\|                    |  左到右  |\n|   条件   |                    ？：                    | 从右到左 |\n|   赋值   | = + = - = * = / =％= >> = << =＆= ^ = \\| = | 从右到左 |\n|   逗号   |                     ，                     |  左到右  |\n\n关联性也就是C++中所谓的结合性\n\n# Java 循环结构 - for, while 及 do...while\n\n这块和C++几乎一样\n\n## while 循环\n\n```cpp\nwhile( 布尔表达式 ) {  //循环内容 }\n```\n\n## do…while 循环（至少执行一次循环）\n\n```cpp\ndo {\n       //代码语句\n}while(布尔表达式);\n```\n\n## for循环\n\n```cpp\nfor(初始化; 布尔表达式; 更新) {\n    //代码语句\n}\n```\n\n## Java 增强 for 循环（C++11也新增）\n\nC++中叫基于范围的循环，python中就是这种循环\n\n```cpp\nfor(声明语句 : 表达式)\n{\n   //代码句子\n}\n```\n\n**声明语句：**声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。\n\n**表达式：**表达式是要访问的数组名，或者是返回值为数组的方法。\n\n![](基础语法/10.png)![](基础语法/11.png)\n\n## break 关键字\n\nbreak 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。\n\nbreak 跳出最里层的循环，并且继续执行该循环下面的语句。\n\n## continue 关键字\n\ncontinue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。\n\n在 for 循环中，continue 语句使程序立即跳转到更新语句。\n\n在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。\n\n# Java 条件语句 - if...else\n\n## if\n\n\n\n语法：\n\n```cpp\nif(布尔表达式)\n{\n   //如果布尔表达式为true将执行的语句\n}\n```\n\n## if...else语句\n\n```cpp\nif(布尔表达式){\n   //如果布尔表达式的值为true\n}else{\n   //如果布尔表达式的值为false\n}\n```\n\n可嵌套，和C++一模一样\n\n# Java switch case 语句\n\nswitch case 语句语法格式如下：\n\n```java\nswitch(expression){\n    case value :\n       //语句\n       break; //可选\n    case value :\n       //语句\n       break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n       //语句\n}\n```\n\n# Java Number & Math 类\n\n一般地，当需要使用数字的时候，我们通常使用内置数据类型，如：**byte、int、long、double** 等。\n\n然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，Java 语言为每一个内置数据类型提供了对应的包装类。\n\n所有的包装类**（Integer、Long、Byte、Double、Float、Short）**都是抽象类 Number 的子类。\n\n|  包装类   | 基本数据类型 |\n| :-------: | :----------: |\n|  Boolean  |   boolean    |\n|   Byte    |     byte     |\n|   Short   |    short     |\n|  Integer  |     int      |\n|   Long    |     long     |\n| Character |     char     |\n|   Float   |    float     |\n|  Double   |    double    |\n\n![](基础语法/12.png)\n\n这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。\n\n```java\npublic class Test{\n \n   public static void main(String args[]){\n      Integer x = 5;\n      x =  x + 10;\n      System.out.println(x); \n   }\n}\n```\n\n当 x 被赋为整型值时，由于x是一个对象，所以编译器要对x进行装箱。然后，为了使x能进行加运算，所以要对x进行拆箱。\n\n## Java Math 类\n\nJava 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。\n\nMath 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。\n\n示例：\n\n```cpp\npublic class Test {  \n    public static void main (String []args)  \n    {  \n        System.out.println(\"90 度的正弦值：\" + Math.sin(Math.PI/2));  \n        System.out.println(\"0度的余弦值：\" + Math.cos(0));  \n        System.out.println(\"60度的正切值：\" + Math.tan(Math.PI/3));  \n        System.out.println(\"1的反正切值： \" + Math.atan(1));  \n        System.out.println(\"π/2的角度值：\" + Math.toDegrees(Math.PI/2));  \n        System.out.println(Math.PI);  \n    }  \n}\n```\n\n## Number & Math 类方法\n\n| 序号 | 方法与描述                                                   |\n| :--- | :----------------------------------------------------------- |\n| 1    | [xxxValue()](https://www.runoob.com/java/number-xxxvalue.html) 将 Number 对象转换为xxx数据类型的值并返回。 |\n| 2    | [compareTo()](https://www.runoob.com/java/number-compareto.html) 将number对象与参数比较。 |\n| 3    | [equals()](https://www.runoob.com/java/number-equals.html) 判断number对象是否与参数相等。 |\n| 4    | [valueOf()](https://www.runoob.com/java/number-valueof.html) 返回一个 Number 对象指定的内置数据类型 |\n| 5    | [toString()](https://www.runoob.com/java/number-tostring.html) 以字符串形式返回值。 |\n| 6    | [parseInt()](https://www.runoob.com/java/number-parseInt.html) 将字符串解析为int类型。 |\n| 7    | [abs()](https://www.runoob.com/java/number-abs.html) 返回参数的绝对值。 |\n| 8    | [ceil()](https://www.runoob.com/java/number-ceil.html) 返回大于等于( >= )给定参数的的最小整数，类型为双精度浮点型。 |\n| 9    | [floor()](https://www.runoob.com/java/number-floor.html) 返回小于等于（<=）给定参数的最大整数 。 |\n| 10   | [rint()](https://www.runoob.com/java/number-rint.html) 返回与参数最接近的整数。返回类型为double。 |\n| 11   | [round()](https://www.runoob.com/java/number-round.html) 它表示**四舍五入**，算法为 **Math.floor(x+0.5)**，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。 |\n| 12   | [min()](https://www.runoob.com/java/number-min.html) 返回两个参数中的最小值。 |\n| 13   | [max()](https://www.runoob.com/java/number-max.html) 返回两个参数中的最大值。 |\n| 14   | [exp()](https://www.runoob.com/java/number-exp.html) 返回自然数底数e的参数次方。 |\n| 15   | [log()](https://www.runoob.com/java/number-log.html) 返回参数的自然数底数的对数值。 |\n| 16   | [pow()](https://www.runoob.com/java/number-pow.html) 返回第一个参数的第二个参数次方。 |\n| 17   | [sqrt()](https://www.runoob.com/java/number-sqrt.html) 求参数的算术平方根。 |\n| 18   | [sin()](https://www.runoob.com/java/number-sin.html) 求指定double类型参数的正弦值。 |\n| 19   | [cos()](https://www.runoob.com/java/number-cos.html) 求指定double类型参数的余弦值。 |\n| 20   | [tan()](https://www.runoob.com/java/number-tan.html) 求指定double类型参数的正切值。 |\n| 21   | [asin()](https://www.runoob.com/java/number-asin.html) 求指定double类型参数的反正弦值。 |\n| 22   | [acos()](https://www.runoob.com/java/number-acos.html) 求指定double类型参数的反余弦值。 |\n| 23   | [atan()](https://www.runoob.com/java/number-atan.html) 求指定double类型参数的反正切值。 |\n| 24   | [atan2()](https://www.runoob.com/java/number-atan2.html) 将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。 |\n| 25   | [toDegrees()](https://www.runoob.com/java/number-todegrees.html) 将参数转化为角度。 |\n| 26   | [toRadians()](https://www.runoob.com/java/number-toradians.html) 将角度转换为弧度。 |\n| 27   | [random()](https://www.runoob.com/java/number-random.html) 返回一个随机数。 |\n\n# Java Character 类\n\nCharacter 类用于对单个字符进行操作。\n\nCharacter 类在对象中包装一个基本类型 **char** 的值\n\n## 转义序列\n\n| 转义序列 |           描述           |\n| :------: | :----------------------: |\n|    \\t    | 在文中该处插入一个tab键  |\n|    \\b    | 在文中该处插入一个后退键 |\n|    \\n    |      在文中该处换行      |\n|    \\r    |    在文中该处插入回车    |\n|    \\f    |   在文中该处插入换页符   |\n|    \\'    |   在文中该处插入单引号   |\n|    \\\"    |   在文中该处插入双引号   |\n|    \\\\    |   在文中该处插入反斜杠   |\n\n## Character 方法\n\nC++中是cctype头文件中的方法。\n\n| 序号 | 方法与描述                                      |\n| :--- | :---------------------------------------------- |\n| 1    | isLetter() 是否是一个字母                       |\n| 2    | isDigit()是否是一个数字字符                     |\n| 3    | isWhitespace()是否是一个空白字符                |\n| 4    | isUpperCase() 是否是大写字母                    |\n| 5    | isLowerCase()是否是小写字母                     |\n| 6    | toUpperCase() 指定字母的大写形式                |\n| 7    | toLowerCase() 指定字母的小写形式                |\n| 8    | toString返回字符的字符串形式，字符串的长度仅为1 |\n\n# Java String 类\n\n字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。\n\n## 创建字符串\n\nString 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：\n\n```java\nString s1 = \"Runoob\";              // String 直接创建\nString s2 = \"Runoob\";              // String 直接创建\nString s3 = s1;                    // 相同引用\nString s4 = new String(\"Runoob\");   // String 对象创建\nString s5 = new String(\"Runoob\");   // String 对象创建\n```\n\n![](基础语法/13.png)\n\n## 字符串长度\n\nString 类的一个访问器方法是 length() 方法，它返回字符串对象包含的字符数。\n\n！！！没有size方法，C++STL中有size和length\n\n## 连接字符串\n\nString 类提供了连接两个字符串的方法：\n\n+ 返回 string2 连接 string1 的新字符串。也可以对字符串常量使用 concat() 方法，如：\n\n+ 更常用的是使用'+'操作符来连接字符串\n\n![](基础语法/14.png)![](基础语法/15.png)\n\n## 创建格式化字符串\n\n我们知道输出格式化数字可以使用 printf() 和 format() 方法。\n\nString 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。\n\nString 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。\n\n## String 方法\n\n参看 [Java String API](https://www.runoob.com/manual/jdk1.6/java/lang/String.html) 文档:\n\n# Java StringBuffer 和 StringBuilder 类\n\n当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。\n\n和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。\n\n![](基础语法/16.png)\n\n在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。\n\nStringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。\n\n由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。\n\n![](基础语法/17.png)\n\n然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。\n\n## StringBuffer 方法\n\n| 序号 |                           方法描述                           |\n| :--: | :----------------------------------------------------------: |\n|  1   |                int capacity() 返回当前容量。                 |\n|  2   | char charAt(int index) 返回此序列中指定索引处的 `char` 值。  |\n|  3   | void ensureCapacity(int minimumCapacity) 确保容量至少等于指定的最小值。 |\n|  4   | void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 `dst`。 |\n|  5   | int indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。 |\n|  6   | int indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。 |\n|  7   | int lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。 |\n|  8   | int lastIndexOf(String str, int fromIndex) 返回 String 对象中子字符串最后出现的位置。 |\n|  9   |              int length()  返回长度（字符数）。              |\n|  10  | void setCharAt(int index, char ch) 将给定索引处的字符设置为 `ch`。 |\n|  11  |      void setLength(int newLength) 设置字符序列的长度。      |\n|  12  | CharSequence subSequence(int start, int end) 返回一个新的字符序列，该字符序列是此序列的子序列。 |\n|  13  | String substring(int start) 返回一个新的 `String`，它包含此字符序列当前所包含的字符子序列。 |\n|  14  | String substring(int start, int end) 返回一个新的 `String`，它包含此序列当前所包含的字符子序列。 |\n|  15  |     String toString() 返回此序列中数据的字符串表示形式。     |\n\n# Java 数组\n\n## 声明数组变量\n\n```cpp\ndataType[] arrayRefVar;   // 首选的方法\n \n或\n \ndataType arrayRefVar[];  // 效果相同，但不是首选方法 \n//dataType arrayRefVar[] 风格是来自 C/C++ 语言 ，在Java中采用是为了让 C/C++ 程序员能够快速理解java语言。\n```\n\n## 创建数组\n\nJava语言使用new操作符来创建数组，语法如下：\n\n`arrayRefVar = new dataType[arraySize];`\n\n上面的语法语句做了两件事：\n\n- 一、使用 dataType[arraySize] 创建了一个数组。\n- 二、把新创建的数组的引用赋值给变量 arrayRefVar。\n\n可以理解成返回的是指针，C/C++中就有这种概念。\n\n## 数组作为函数的参数\n\n```cpp\npublic static void printArray(int[] array) {\n  for (int i = 0; i < array.length; i++) {\n    System.out.print(array[i] + \" \");\n  }\n}\n```\n\n## 数组作为函数的返回值\n\n```cpp\npublic static int[] reverse(int[] list) {\n  int[] result = new int[list.length];\n \n  for (int i = 0, j = result.length - 1; i < list.length; i++, j--) {\n    result[j] = list[i];\n  }\n  return result;\n}\n```\n\n实际本质是在堆盛情内存空间之后，返回的是引用，也就是数组在堆内存中的位置。\n\n## 多维数组\n\n多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组，例如：\n\n`String str[][] = new String[3][4];`\n\n## Arrays 类\n\njava.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。\n\n具有以下功能：\n\n- 给数组赋值：通过 fill 方法。\n- 对数组排序：通过 sort 方法,按升序。\n- 比较数组：通过 equals 方法比较数组中元素值是否相等。\n- 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。\n\n| 序号 | 方法和说明                                                   |\n| :--: | :----------------------------------------------------------- |\n|  1   | **public static int binarySearch(Object[] a, Object key)** 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(*插入点*) - 1)。 |\n|  2   | **public static boolean equals(long[] a, long[] a2)** 如果两个指定的 long 型数组彼此*相等*，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |\n|  3   | **public static void fill(int[] a, int val)** 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |\n|  4   | **public static void sort(Object[] a)** 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |\n\n# Java 日期时间\n\njava.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。\n\n第一个构造函数使用当前日期和时间来初始化对象。\n\n第一个构造函数使用当前日期和时间来初始化对象。`Date( )`\n\n第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。`Date(long millisec)`\n\n| 序号 | 方法和描述                                                   |\n| :--- | :----------------------------------------------------------- |\n| 1    | **boolean after(Date date)** 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。 |\n| 2    | **boolean before(Date date)** 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。 |\n| 3    | **Object clone( )** 返回此对象的副本。                       |\n| 4    | **int compareTo(Date date)** 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。 |\n| 5    | **int compareTo(Object obj)** 若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。 |\n| 6    | **boolean equals(Object date)** 当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。 |\n| 7    | **long getTime( )** 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 |\n| 8    | **int hashCode( )**  返回此对象的哈希码值。                  |\n| 9    | **void setTime(long time)**   用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。 |\n| 10   | **String toString( )** 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。 |\n\n## 获取当前日期时间\n\n![](基础语法/18.png)![](基础语法/19.png)\n\n## 日期比较\n\nJava使用以下三种方法来比较两个日期：\n\n- 使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。\n- 使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。\n- 使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。\n\n## 使用 SimpleDateFormat 格式化日期\n\nSimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如：\n\n`SimpleDateFormat ft = new SimpleDateFormat (\"yyyy-MM-dd hh:mm:ss\");`\n\n这一行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。\n\n**注意**:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。\n\n![](基础语法/20.png)![](基础语法/21.png)\n\n## 解析字符串为时间\n\nSimpleDateFormat 类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat 对象的格式化存储来解析字符串。例如：\n\n```java\nimport java.util.*;\nimport java.text.*;\n  \npublic class DateDemo {\n \n   public static void main(String args[]) {\n      SimpleDateFormat ft = new SimpleDateFormat (\"yyyy-MM-dd\"); \n \n      String input = args.length == 0 ? \"1818-11-11\" : args[0]; \n \n      System.out.print(input + \" Parses as \"); \n \n      Date t; \n \n      try { \n          t = ft.parse(input); \n          System.out.println(t); \n      } catch (ParseException e) { \n          System.out.println(\"Unparseable using \" + ft); \n      }\n   }\n}\n```\n\n## Java 休眠(sleep)\n\nsleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。\n\n你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。\n\n## Calendar类\n\n我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用Calendar 类。\n\nCalendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。\n\nCalendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。\n\n## GregorianCalendar类\n\nCalendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。\n\nCalendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。\n\n# Java 正则表达式\n\nava 正则表达式和 Perl 的是最为相似的。\n\njava.util.regex 包主要包括以下三个类：\n\n- Pattern 类：\n\n  pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。\n\n- Matcher 类：\n\n  Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。\n\n- PatternSyntaxException：\n\n  PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。\n\n  \n\n# Java 方法\n\n## 方法的定义\n\n```java\n修饰符 返回值类型 方法名(参数类型 参数名){\n    ...\n    方法体\n    ...\n    return 返回值;\n}\n```\n\n- **修饰符：**修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。\n- **返回值类型 ：**方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字**void**。\n- **方法名：**是方法的实际名称。方法名和参数表共同构成方法签名。\n- **参数类型：**参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。\n- **方法体：**方法体包含具体的语句，定义该方法的功能。\n\n## 方法的重载\n\n就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。\n\nJava编译器根据方法签名判断哪个方法应该被调用。\n\n方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。\n\n重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。\n\n## 构造方法\n\n当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。\n\n不管你是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，默认构造方法的访问修改符和类的访问修改符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。\n\n一旦你定义了自己的构造方法，默认构造方法就会失效。\n\n## 可变参数\n\nJDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。\n\n方法的可变参数的声明如下所示：\n\n`typeName... parameterName`\n\n在方法声明中，在指定参数类型后加一个省略号(...) 。\n\n一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。\n\n## finalize() 方法\n\nJava 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。\n\n例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。\n\n在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。\n\nfinalize() 一般格式是：\n\n```java\nprotected void finalize()\n{\n   // 在这里终结代码\n}\n```\n\n关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。\n\n当然，Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法。\n\n# Java 流(Stream)、文件(File)和IO\n\n## 读取控制台输入\n\nJava 的控制台输入由 System.in 完成。\n\n为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。\n\n下面是创建 BufferedReader 的基本语法：\n\n```java\nBufferedReader br = new BufferedReader(new \n                      InputStreamReader(System.in));\n```\n\nBufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。\n\n## 读写文件\n\n如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。\n\n下图是一个描述输入流和输出流的类层次图。\n\n![](基础语法/22.png)\n\n## FileInputStream\n\n该流用于从文件读取数据，它的对象可以用关键字 new 来创建。\n\n有多种构造方法可用来创建对象。\n\n可以使用字符串类型的文件名来创建一个输入流对象来读取文件：\n\n```\nInputStream f = new FileInputStream(\"C:/java/hello\");\n```\n\n也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：\n\n```\nFile f = new File(\"C:/java/hello\"); InputStream out = new FileInputStream(f);\n```\n\n| **序号** | **方法及描述**                                               |\n| :------- | :----------------------------------------------------------- |\n| 1        | **public void close() throws IOException{}** 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。 |\n| 2        | **protected void finalize()throws IOException {}** 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。 |\n| 3        | **public int read(int r)throws IOException{}** 这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。 |\n| 4        | **public int read(byte[] r) throws IOException{}** 这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。 |\n| 5        | **public int available() throws IOException{}** 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。 |\n\n## FileOutputStream\n\n该类用来创建一个文件并向文件中写数据。\n\n如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。\n\n有两个构造方法可以用来创建 FileOutputStream 对象。\n\n使用字符串类型的文件名来创建一个输出流对象：\n\n```\nOutputStream f = new FileOutputStream(\"C:/java/hello\")\n```\n\n也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：\n\n```\nFile f = new File(\"C:/java/hello\"); OutputStream f = new FileOutputStream(f);\n```\n\n## Java中的目录\n\n### 创建目录：\n\nFile类中有两个方法可以用来创建文件夹：\n\n- **mkdir( )**方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。\n- **mkdirs()**方法创建一个文件夹和它的所有父文件夹。\n\n## 读取目录\n\n一个目录其实就是一个 File 对象，它包含其他文件和文件夹。\n\n如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。\n\n可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。\n\n删除文件可以使用 **java.io.File.delete()** 方法。\n\n## 删除目录或文件\n\n需要注意的是当删除某一目录时，必须保证该目录下没有其他文件才能正确删除，否则将删除失败。\n\n# Java Scanner 类\n\njava.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。\n\n下面是创建 Scanner 对象的基本语法：\n\n```\nScanner s = new Scanner(System.in);\n```\n\n通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据：\n\n### next() 与 nextLine() 区别\n\nnext():\n\n- 1、一定要读取到有效字符后才可以结束输入。\n- 2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。\n- 3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。\n- next() 不能得到带有空格的字符串。\n\nnextLine()：\n\n- 1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。\n- 2、可以获得空白。\n\n# Java 异常处理\n\n异常发生的原因有很多，通常包含以下几大类：\n\n- 用户输入了非法数据。\n- 要打开的文件不存在。\n- 网络通信时连接中断，或者JVM内存溢出。\n\n这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。-\n\n要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：\n\n- **检查性异常：**最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。\n- **运行时异常：** 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。\n- **错误：** 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。\n\n## Exception 类的层次\n\n所有的异常类是从 java.lang.Exception 类继承的子类。\n\nException 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。\n\nJava 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。\n\nError 用来指示运行时环境发生的错误。\n\n例如，JVM 内存溢出。一般地，程序不会从错误中恢复。\n\n异常类有两个主要的子类：IOException 类和 RuntimeException 类。\n\n![](基础语法/23.jpg)\n\n## Java 内置异常类\n\nJava 语言定义了一些异常类在 java.lang 标准包中。\n\n标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。\n\nJava 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常。\n\n## 异常方法\n\n下面的列表是 Throwable 类的主要方法:\n\n| **序号** | **方法及说明**                                               |\n| :------- | :----------------------------------------------------------- |\n| 1        | **public String getMessage()** 返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。 |\n| 2        | **public Throwable getCause()** 返回一个Throwable 对象代表异常原因。 |\n| 3        | **public String toString()** 使用getMessage()的结果返回类的串级名字。 |\n| 4        | **public void printStackTrace()** 打印toString()结果和栈层次到System.err，即错误输出流。 |\n| 5        | **public StackTraceElement [] getStackTrace()** 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。 |\n| 6        | **public Throwable fillInStackTrace()** 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。 |\n\n## 捕获异常\n\n使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。\n\ntry/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：\n\n```\ntry\n{\n   // 程序代码\n}catch(ExceptionName e1)\n{\n   //Catch 块\n}\n```\n\n## 多重捕获块\n\n一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。\n\n```java\ntry{\n   // 程序代码\n}catch(异常类型1 异常的变量名1){\n  // 程序代码\n}catch(异常类型2 异常的变量名2){\n  // 程序代码\n}catch(异常类型3 异常的变量名3){\n  // 程序代码\n}\n```\n\n## throws/throw 关键字：\n\n如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。\n\n也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。\n\n下面方法的声明抛出一个 RemoteException 异常：\n\n```java\nimport java.io.*;\npublic class className\n{\n  public void deposit(double amount) throws RemoteException\n  {\n    // Method implementation\n    throw new RemoteException();\n  }\n  //Remainder of class definition\n}\n```\n\n## finally关键字\n\nJava 教程\n\n[Java 教程](https://www.runoob.com/java/java-tutorial.html)[Java 简介](https://www.runoob.com/java/java-intro.html)[Java 开发环境配置](https://www.runoob.com/java/java-environment-setup.html)[Java 基础语法](https://www.runoob.com/java/java-basic-syntax.html)[Java 对象和类](https://www.runoob.com/java/java-object-classes.html)[Java 基本数据类型](https://www.runoob.com/java/java-basic-datatypes.html)[Java 变量类型](https://www.runoob.com/java/java-variable-types.html)[Java 修饰符](https://www.runoob.com/java/java-modifier-types.html)[Java 运算符](https://www.runoob.com/java/java-operators.html)[Java 循环结构](https://www.runoob.com/java/java-loop.html)[Java 条件语句](https://www.runoob.com/java/java-if-else-switch.html)[Java switch case](https://www.runoob.com/java/java-switch-case.html)[Java Number & Math 类](https://www.runoob.com/java/java-number.html)[Java Character 类](https://www.runoob.com/java/java-character.html)[Java String 类](https://www.runoob.com/java/java-string.html)[Java StringBuffer](https://www.runoob.com/java/java-stringbuffer.html)[Java 数组](https://www.runoob.com/java/java-array.html)[Java 日期时间](https://www.runoob.com/java/java-date-time.html)[Java 正则表达式](https://www.runoob.com/java/java-regular-expressions.html)[Java 方法](https://www.runoob.com/java/java-methods.html)[Java Stream、File、IO](https://www.runoob.com/java/java-files-io.html)[Java Scanner 类](https://www.runoob.com/java/java-scanner-class.html)[Java 异常处理](https://www.runoob.com/java/java-exceptions.html)\n\n## Java 面向对象\n\n[Java 继承](https://www.runoob.com/java/java-inheritance.html)[Java Override/Overload](https://www.runoob.com/java/java-override-overload.html)[Java 多态](https://www.runoob.com/java/java-polymorphism.html)[Java 抽象类](https://www.runoob.com/java/java-abstraction.html)[Java 封装](https://www.runoob.com/java/java-encapsulation.html)[Java 接口](https://www.runoob.com/java/java-interfaces.html)[Java 枚举](https://www.runoob.com/java/java-enum.html)[Java 包(package)](https://www.runoob.com/java/java-package.html)\n\n## Java 高级教程\n\n[Java 数据结构](https://www.runoob.com/java/java-data-structures.html)[Java 集合框架](https://www.runoob.com/java/java-collections.html)[Java ArrayList](https://www.runoob.com/java/java-arraylist.html)[Java LinkedList](https://www.runoob.com/java/java-linkedlist.html)[Java HashSet](https://www.runoob.com/java/java-hashset.html)[Java HashMap](https://www.runoob.com/java/java-hashmap.html)[Java Iterator](https://www.runoob.com/java/java-iterator.html)[Java Object](https://www.runoob.com/java/java-object.html)[Java 泛型](https://www.runoob.com/java/java-generics.html)[Java 序列化](https://www.runoob.com/java/java-serialization.html)[Java 网络编程](https://www.runoob.com/java/java-networking.html)[Java 发送邮件](https://www.runoob.com/java/java-sending-email.html)[Java 多线程编程](https://www.runoob.com/java/java-multithreading.html)[Java Applet 基础](https://www.runoob.com/java/java-applet-basics.html)[Java 文档注释](https://www.runoob.com/java/java-documentation.html)[Java 实例](https://www.runoob.com/java/java-examples.html)[Java 8 新特性](https://www.runoob.com/java/java8-new-features.html)[Java MySQL 连接](https://www.runoob.com/java/java-mysql-connect.html)[Java 9 新特性](https://www.runoob.com/java/java9-new-features.html)[Java 测验](https://www.runoob.com/quiz/java-quiz.html)\n\n [Java Scanner 类](https://www.runoob.com/java/java-scanner-class.html)\n\n[Java 继承](https://www.runoob.com/java/java-inheritance.html) \n\n# Java 异常处理\n\n异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。\n\n比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用System.out.println(11/0)，那么你是因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。\n\n异常发生的原因有很多，通常包含以下几大类：\n\n- 用户输入了非法数据。\n- 要打开的文件不存在。\n- 网络通信时连接中断，或者JVM内存溢出。\n\n这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。-\n\n要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：\n\n- **检查性异常：**最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。\n- **运行时异常：** 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。\n- **错误：** 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。\n\n------\n\n## Exception 类的层次\n\n所有的异常类是从 java.lang.Exception 类继承的子类。\n\nException 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。\n\nJava 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。\n\nError 用来指示运行时环境发生的错误。\n\n例如，JVM 内存溢出。一般地，程序不会从错误中恢复。\n\n异常类有两个主要的子类：IOException 类和 RuntimeException 类。\n\n![img](https://www.runoob.com/wp-content/uploads/2013/12/12-130Q1234I6223.jpg)\n\n在 Java 内置类中(接下来会说明)，有大部分常用检查性和非检查性异常。\n\n------\n\n## Java 内置异常类\n\nJava 语言定义了一些异常类在 java.lang 标准包中。\n\n标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。\n\nJava 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常。\n\n| **异常**                        | **描述**                                                     |\n| :------------------------------ | :----------------------------------------------------------- |\n| ArithmeticException             | 当出现异常的运算条件时，抛出此异常。例如，一个整数\"除以零\"时，抛出此类的一个实例。 |\n| ArrayIndexOutOfBoundsException  | 用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。 |\n| ArrayStoreException             | 试图将错误类型的对象存储到一个对象数组时抛出的异常。         |\n| ClassCastException              | 当试图将对象强制转换为不是实例的子类时，抛出该异常。         |\n| IllegalArgumentException        | 抛出的异常表明向方法传递了一个不合法或不正确的参数。         |\n| IllegalMonitorStateException    | 抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。 |\n| IllegalStateException           | 在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。 |\n| IllegalThreadStateException     | 线程没有处于请求操作所要求的适当状态时抛出的异常。           |\n| IndexOutOfBoundsException       | 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 |\n| NegativeArraySizeException      | 如果应用程序试图创建大小为负的数组，则抛出该异常。           |\n| NullPointerException            | 当应用程序试图在需要对象的地方使用 `null` 时，抛出该异常     |\n| NumberFormatException           | 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。 |\n| SecurityException               | 由安全管理器抛出的异常，指示存在安全侵犯。                   |\n| StringIndexOutOfBoundsException | 此异常由 `String` 方法抛出，指示索引或者为负，或者超出字符串的大小。 |\n| UnsupportedOperationException   | 当不支持请求的操作时，抛出该异常。                           |\n\n下面的表中列出了 Java 定义在 java.lang 包中的检查性异常类。\n\n| **异常**                   | **描述**                                                     |\n| :------------------------- | :----------------------------------------------------------- |\n| ClassNotFoundException     | 应用程序试图加载类时，找不到相应的类，抛出该异常。           |\n| CloneNotSupportedException | 当调用 `Object` 类中的 `clone` 方法克隆对象，但该对象的类无法实现 `Cloneable` 接口时，抛出该异常。 |\n| IllegalAccessException     | 拒绝访问一个类的时候，抛出该异常。                           |\n| InstantiationException     | 当试图使用 `Class` 类中的 `newInstance` 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。 |\n| InterruptedException       | 一个线程被另一个线程中断，抛出该异常。                       |\n| NoSuchFieldException       | 请求的变量不存在                                             |\n| NoSuchMethodException      | 请求的方法不存在                                             |\n\n------\n\n## 异常方法\n\n下面的列表是 Throwable 类的主要方法:\n\n| **序号** | **方法及说明**                                               |\n| :------- | :----------------------------------------------------------- |\n| 1        | **public String getMessage()** 返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。 |\n| 2        | **public Throwable getCause()** 返回一个Throwable 对象代表异常原因。 |\n| 3        | **public String toString()** 使用getMessage()的结果返回类的串级名字。 |\n| 4        | **public void printStackTrace()** 打印toString()结果和栈层次到System.err，即错误输出流。 |\n| 5        | **public StackTraceElement [] getStackTrace()** 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。 |\n| 6        | **public Throwable fillInStackTrace()** 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。 |\n\n------\n\n## 捕获异常\n\n使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。\n\ntry/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：\n\n```\ntry\n{\n   // 程序代码\n}catch(ExceptionName e1)\n{\n   //Catch 块\n}\n```\n\nCatch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。\n\n如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。\n\n### 实例\n\n下面的例子中声明有两个元素的一个数组，当代码试图访问数组的第三个元素的时候就会抛出一个异常。\n\n## ExcepTest.java 文件代码：\n\n// 文件名 : ExcepTest.java import java.io.*; public class ExcepTest{    public static void main(String args[]){      try{         int a[] = new int[2];         System.out.println(\"Access element three :\" + a[3]);      }catch(ArrayIndexOutOfBoundsException e){         System.out.println(\"Exception thrown  :\" + e);      }      System.out.println(\"Out of the block\");   } }\n\n以上代码编译运行输出结果如下：\n\n```\nException thrown  :java.lang.ArrayIndexOutOfBoundsException: 3\nOut of the block\n```\n\n------\n\n## 多重捕获块\n\n一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。\n\n多重捕获块的语法如下所示：\n\ntry{   // 程序代码 }catch(异常类型1 异常的变量名1){  // 程序代码 }catch(异常类型2 异常的变量名2){  // 程序代码 }catch(异常类型3 异常的变量名3){  // 程序代码 }\n\n上面的代码段包含了 3 个 catch块。\n\n可以在 try 语句后面添加任意数量的 catch 块。\n\n如果保护代码中发生异常，异常被抛给第一个 catch 块。\n\n如果抛出异常的数据类型与 ExceptionType1 匹配，它在这里就会被捕获。\n\n如果不匹配，它会被传递给第二个 catch 块。\n\n如此，直到异常被捕获或者通过所有的 catch 块。\n\n### 实例\n\n该实例展示了怎么使用多重 try/catch。\n\ntry {    file = new FileInputStream(fileName);    x = (byte) file.read(); } catch(FileNotFoundException f) { // Not valid!    f.printStackTrace();    return -1; } catch(IOException i) {    i.printStackTrace();    return -1; }\n\n------\n\n## throws/throw 关键字：\n\n如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。\n\n也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。\n\n下面方法的声明抛出一个 RemoteException 异常：\n\nimport java.io.*; public class className {  public void deposit(double amount) throws RemoteException  {    // Method implementation    throw new RemoteException();  }  //Remainder of class definition }\n\n一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。\n\n例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException：\n\nimport java.io.*; public class className {   public void withdraw(double amount) throws RemoteException,                              InsufficientFundsException   {       // Method implementation   }   //Remainder of class definition }\n\n------\n\n## finally关键字\n\nfinally 关键字用来创建在 try 代码块后面执行的代码块。\n\n无论是否发生异常，finally 代码块中的代码总会被执行。\n\n在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。\n\nfinally 代码块出现在 catch 代码块最后，语法如下:\n\n```java\ntry{\n  // 程序代码\n}catch(异常类型1 异常的变量名1){\n  // 程序代码\n}catch(异常类型2 异常的变量名2){\n  // 程序代码\n}finally{\n  // 程序代码\n}\n```\n\n- catch 不能独立于 try 存在。\n- 在 try/catch 后面添加 finally 块并非强制性要求的。\n- try 代码后不能既没 catch 块也没 finally 块。\n- try, catch, finally 块之间不能添加任何代码。\n\n## 声明自定义异常\n\n在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。\n\n- 所有异常都必须是 Throwable 的子类。\n- 如果希望写一个检查性异常类，则需要继承 Exception 类。\n- 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。\n\n## 通用异常\n\n在Java中定义了两种类型的异常和错误。\n\n- **JVM(Java****虚拟机****)** **异常：**由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。\n- **程序级异常：**由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。","tags":["Java"],"categories":["JAVA学习"]}]