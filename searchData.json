[{"title":"Java数据结构","url":"/2020/12/27/Java数据结构/","content":"\n## 前言\n\n我有过数据结构的基础，学C++时都实现了一遍数据结构，所以相当于做记录，更偏向实际应用。\n\n本博客相当于是笔记，只为了给自己以后方便查资料等，并不是自己写的内容，因为我也是正在学。\n\n基本复制来的加上自己手敲代码给自己加深印象。\n\n资源来自[菜鸟网](https://www.runoob.com/java/java-tutorial.html)\n\n## Java 数据结构\n\nJava工具包提供了强大的数据结构。在Java中的数据结构主要包括以下几种接口和类：\n\n- 枚举（Enumeration）\n- 位集合（BitSet）\n- 向量（Vector）\n- 栈（Stack）\n- 字典（Dictionary）\n- 哈希表（Hashtable）\n- 属性（Properties）\n\n### 枚举（Enumeration）\n\n枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。 枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。\n\n例如，枚举定义了一个叫nextElement 的方法，该方法用来得到一个包含多元素的数据结构的下一个元素。\n\nEnumeration接口中定义了一些方法，通过这些方法可以枚举（一次获得一个）对象集合中的元素。\n\n这种传统接口已被迭代器取代，虽然Enumeration 还未被遗弃，但在现代代码中已经被很少使用了。尽管如此，它还是使用在诸如Vector和Properties这些传统类所定义的方法中，除此之外，还用在一些API类，并且在应用程序中也广泛被使用。 下表总结了一些Enumeration声明的方法：\n\n| **序号** |                         **方法描述**                         |\n| :------- | :----------------------------------------------------------: |\n| 1        | **boolean hasMoreElements( )**  测试此枚举是否包含更多的元素。 |\n| 2        | **Object nextElement( )** 如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素。 |\n\n实例：\n\n```cpp\npackage hello;\nimport java.util.Vector;\nimport java.util.Enumeration;\npublic class EnumerationTest {\n    public static void main(String args[]) {\n        Enumeration<String> days;\n        Vector<String> week = new Vector<String>();\n        week.add(\"Sunday\");\n        week.add(\"Monday\");\n        week.add(\"Tuesday\");\n        week.add(\"Wednesday\");\n        week.add(\"Thursday\");\n        week.add(\"Friday\");\n        week.add(\"Saturday\");\n        days = week.elements();\n        while(days.hasMoreElements()){\n            System.out.println(days.nextElement());\n        }\n    }\n}\n\n```\n\n运行结果：\n\n![](Java数据结构/1.png)\n\n### 位集合（BitSet）\n\n位集合类实现了一组可以单独设置和清除的位或标志。\n\n该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一\"位\"，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。\n\n一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。这和位向量（vector of bits）比较类似。\n\n这是一个传统的类，但它在Java 2中被完全重新设计。\n\nBitSet定义了两个构造方法。\n\n第一个构造方法创建一个默认的对象：\n\n```\nBitSet()\n```\n\n第二个方法允许用户指定初始大小。所有位初始化为0。\n\n```\nBitSet(int size)\n```\n\n### 向量（Vector）\n\n向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。\n\n和数组一样，Vector对象的元素也能通过索引访问。\n\n使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。\n\nVector 类实现了一个动态数组。和 ArrayList 很相似，但是两者是不同的：\n\n- Vector 是同步访问的。\n- Vector 包含了许多传统的方法，这些方法不属于集合框架。\n\nVector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。\n\nVector 类支持 4 种构造方法。\n\n第一种构造方法创建一个默认的向量，默认大小为 10：\n\n```\nVector()\n```\n\n第二种构造方法创建指定大小的向量。\n\n```\nVector(int size)\n```\n\n第三种构造方法创建指定大小的向量，并且增量用 incr 指定。增量表示向量每次增加的元素数目。\n\n```\nVector(int size,int incr)\n```\n\n第四种构造方法创建一个包含集合 c 元素的向量：\n\n```\nVector(Collection c)\n```\n\n一堆接口：比较两个接口，其他接口用到再写：\n\n int size()   返回此向量中的组件数。\n\n Enumeration elements()  返回此向量的组件的枚举。\n\nint capacity() 返回此向量的当前容量。\n\n**容量可以构造时指定，而size表示容器中现在有的对象个数。**\n\n### 栈（Stack）\n\n栈（Stack）实现了一个后进先出（LIFO）的数据结构。\n\n你可以把栈理解为对象的垂直分布的栈，当你添加一个新元素时，就将新元素放在其他元素的顶部。\n\n当你从栈中取元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。\n\n**除了由Vector定义的所有方法，自己也定义了一些方法：**\n\n堆栈只定义了默认构造函数，用来创建一个空栈。 堆栈除了包括由Vector定义的所有方法，也定义了自己的一些方法。\n\n```\nStack()\n```\n\n| 序号 |                           方法描述                           |\n| :--: | :----------------------------------------------------------: |\n|  1   |             boolean empty()  测试堆栈是否为空。              |\n|  2   |   Object peek( ) 查看堆栈顶部的对象，但不从堆栈中移除它。    |\n|  3   | Object pop( ) 移除堆栈顶部的对象，并作为此函数的值返回该对象。 |\n|  4   |        Object push(Object element) 把项压入堆栈顶部。        |\n|  5   | int search(Object element) 返回对象在堆栈中的位置，以 1 为基数。 |\n\n### 字典（Dictionary）\n\n字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。\n\n当你想要通过特定的键而不是整数索引来访问数据的时候，这时候应该使用Dictionary。\n\n由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。\n\n类似于C++的map\n\nDictionary 类是一个抽象类，用来存储键/值对，作用和Map类相似。\n\n给出键和值，你就可以将值存储在Dictionary对象中。一旦该值被存储，就可以通过它的键来获取它。所以和Map一样， Dictionary 也可以作为一个键/值对列表。\n\nDictionary定义的抽象方法如下表所示：\n\n| **序号** |                         **方法描述**                         |\n| :------: | :----------------------------------------------------------: |\n|    1     |  **Enumeration elements( )** 返回此 dictionary 中值的枚举。  |\n|    2     | **Object get(Object key)** 返回此 dictionary 中该键所映射到的值。 |\n|    3     | **boolean isEmpty( )** 测试此 dictionary 是否不存在从键到值的映射。 |\n|    4     |   **Enumeration keys( )** 返回此 dictionary 中的键的枚举。   |\n|    5     | **Object put(Object key, Object value)** 将指定 key 映射到此 dictionary 中指定 value。 |\n|    6     | **Object remove(Object key)** 从此 dictionary 中移除 key （及其相应的 value）。 |\n|    7     |  **int size( )** 返回此 dictionary 中条目（不同键）的数量。  |\n\nDictionary类已经过时了。在实际开发中，你可以实现Map接口来获取键/值的存储功能。\n\n### 哈希表（Hashtable）\n\nHashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。\n\n例如，在地址列表的哈希表中，你可以根据邮政编码作为键来存储和排序数据，而不是通过人名。\n\n哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。\n\n#### Java Hashtable 类\n\nHashtable是原始的java.util的一部分， 是一个Dictionary具体的实现 。\n\n然而，Java 2 重构的Hashtable实现了Map接口，因此，Hashtable现在集成到了集合框架中。它和HashMap类很相似，但是它支持同步。\n\n像HashMap一样，Hashtable在哈希表中存储键/值对。当使用一个哈希表，要指定用作键的对象，以及要链接到该键的值。\n\n然后，该键经过哈希处理，所得到的散列码被用作存储在该表中值的索引。\n\nHashtable定义了四个构造方法。第一个是默认构造方法：\n\n```\nHashtable()\n```\n\n第二个构造函数创建指定大小的哈希表：\n\n```\nHashtable(int size)\n```\n\n第三个构造方法创建了一个指定大小的哈希表，并且通过fillRatio指定填充比例。\n\n填充比例必须介于0.0和1.0之间，它决定了哈希表在重新调整大小之前的充满程度：\n\n```\nHashtable(int size,float fillRatio)\n```\n\n第四个构造方法创建了一个以M中元素为初始化元素的哈希表。\n\n哈希表的容量被设置为M的两倍。\n\n```\nHashtable(Map m)\n```\n\n### 属性（Properties）\n\nProperties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。\n\nProperties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。\n\n#### Java Properties 类\n\nProperties 继承于 Hashtable。表示一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。\n\nProperties 类被许多 Java 类使用。例如，在获取环境变量时它就作为 System.getProperties() 方法的返回值。\n\nProperties 定义如下实例变量.这个变量持有一个 Properties 对象相关的默认属性列表。\n\n```\nProperties defaults;\n```\n\nProperties类定义了两个构造方法. 第一个构造方法没有默认值。\n\n```\nProperties()\n```\n\n第二个构造方法使用propDefault 作为默认值。两种情况下，属性列表都为空：\n\n```\nProperties(Properties propDefault)\n```\n\n## 总结\n\n先大致过一遍，后面搞项目练手时不至于遇到就卡住！","tags":["数据结构","Java"],"categories":["Java进阶学习"]},{"title":"Java面向对象","url":"/2020/12/27/Java面向对象/","content":"\n<!--more-->\n\nJAVA是一门纯面向对象的语言。\n\n## 1.Java 继承\n\n### 1.1继承的概念\n\n继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。\n\n继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。\n\n所以继承需要符合的关系是：is-a，父类更通用，子类更具体。\n\n### 1.2类的继承格式\n\n在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：\n\n```java\nclass 父类 {\n}\n \nclass 子类 extends 父类 {\n}\n```\n\n### 1.3为什么需要继承\n\n一个简单例子：\n\n不使用继承，代码重复：\n\n![](Java面向对象/1.png)\n\n![](Java面向对象/2.png)\n\n使用继承之后：\n\n![](Java面向对象/3.png)\n\n从这两段代码可以看出来，代码存在重复了，导致后果就是代码量大且臃肿，而且维护性不高(维护性主要是后期需要修改的时候，就需要修改很多的代码，容易出错)，所以要从根本上解决这两段代码的问题，就需要继承，将两段代码中相同的部分提取出来组成 一个父类.\n\n### 1.4继承类型\n\n需要注意的是 Java 不支持多继承，但支持多重继承。(C++支持多继承)\n\n![](E:\\Blog\\source\\_posts\\Java面向对象\\4.png)\n\n### 1.5继承的特性\n\n- 子类拥有父类非 private 的属性、方法。\n- 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\n- 子类可以用自己的方式实现父类的方法。\n- Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。\n- 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。\n\n### 1.6 继承关键字\n\n继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 **java.lang** 包中，所以不需要 **import**）祖先类。\n\n#### 1.6.1extends关键字\n\n在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。\n\n#### 1.6.2implements关键字\n\n使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。\n\n#### 1.6.3super 与 this 关键字\n\nsuper关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。\n\nthis关键字：指向自己的引用。\n\n#### 1.6.4final关键字\n\nfinal 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：\n\n#### 1.6.5 构造器\n\n子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 **super** 关键字调用父类的构造器并配以适当的参数列表。\n\n如果父类构造器没有参数，则在子类的构造器中不需要使用 **super** 关键字调用父类构造器，系统会自动调用父类的无参构造器。\n\n## 2.Java 重写(Override)与重载(Overload)\n\n### 2.1重写(Override)\n\n重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。**即外壳不变，核心重写！**\n\n重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。\n\n重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。\n\n在编译阶段，只检查参数的引用类型。\n\n然而在运行时，Java 虚拟机(JVM)指定对象的类型并且运行该对象的方法。\n\n#### 2.1.1方法的重写规则\n\n- 参数列表与被重写方法的参数列表必须完全相同。\n- 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。\n- 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。\n- 父类的成员方法只能被它的子类重写。\n- 声明为 final 的方法不能被重写。\n- 声明为 static 的方法不能被重写，但是能够被再次声明。\n- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。\n- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。\n- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。\n- 构造方法不能被重写。\n- 如果不能继承一个类，则不能重写该类的方法。\n\n#### 2.1.2Super 关键字的使用\n\n当需要在子类中调用父类的被重写方法时，要使用 super 关键字。\n\n### 2.2重载(Overload)\n\n重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。\n\n每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。\n\n最常用的地方就是构造器的重载。\n\n#### 2.2.1重载规则:\n\n- 被重载的方法必须改变参数列表(参数个数或类型不一样)；\n- 被重载的方法可以改变返回类型；\n- 被重载的方法可以改变访问修饰符；\n- 被重载的方法可以声明新的或更广的检查异常；\n- 方法能够在同一个类中或者在一个子类中被重载。\n- 无法以返回值类型作为重载函数的区分标准。\n\n### 2.3重写与重载之间的区别\n\n|  区别点  | 重载方法 |                    重写方法                    |\n| :------: | :------: | :--------------------------------------------: |\n| 参数列表 | 必须修改 |                  一定不能修改                  |\n| 返回类型 | 可以修改 |                  一定不能修改                  |\n|   异常   | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常 |\n|   访问   | 可以修改 |     一定不能做更严格的限制（可以降低限制）     |\n\n### 2.4总结：\n\n方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。\n\n- (1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。\n- (2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。\n- (3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。\n\n![](Java面向对象/5.png)\n\n## 3.Java 多态\n\n多态是同一个行为具有多个不同表现形式或形态的能力。\n\n多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：\n\n### 3.1多态的优点\n\n- 1. 消除类型之间的耦合关系\n- 2. 可替换性\n- 3. 可扩充性\n- 4. 接口性\n- 5. 灵活性\n- 6. 简化性\n\n### 3.2多态存在的三个必要条件\n\n- 继承\n- 重写\n- 父类引用指向子类对象：**Parent p = new Child();**\n\n![](Java面向对象/6.png)\n\n### 3.3虚函数\n\n虚函数的存在是为了多态。\n\nJava 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。\n\n### 3.4多态的实现方式\n\n#### 方式一：重写\n\n#### 方式二：接口\n\n#### 方式三：抽象类和抽象方法\n\n## 4.Java 抽象类\n\n### 4.1抽象类\n\n在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。\n\n抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。\n\n由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。\n\n父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。\n\n在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n抽象类不能实例化：\n\n![](Java面向对象/7.png)\n\n### 4.2抽象方法\n\n如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。\n\nAbstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。\n\n抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。\n\n**声明抽象方法会造成以下两个结果：**\n\n- 如果一个类包含抽象方法，那么该类必须是抽象类。\n- 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。\n\n继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。\n\n### 4.3抽象类总结规定\n\n- 1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。\n- 2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。\n- 3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。\n- 4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。\n- 5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。\n\n## 5.Java 封装\n\n在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。\n\n封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。\n\n要访问该类的代码和数据，必须通过严格的接口控制。\n\n封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。\n\n适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。\n\n### 5.1封装的优点\n\n- 1. 良好的封装能够减少耦合。\n- 2. 类内部的结构可以自由修改。\n- 3. 可以对成员变量进行更精确的控制。\n- 4. 隐藏信息，实现细节。\n\n### 5.2实现Java封装的步骤\n\n#### 5.2.1修改属性的可见性来限制对属性的访问（一般限制为private），例如：\n\n```java\npublic class Person {\n    private String name;\n    private int age;\n}\n```\n\n这段代码中，将 **name** 和 **age** 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。\n\n#### 5.2.2对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：\n\n```java\npublic class Person{\n    private String name;\n    private int age;\n​\n    public int getAge(){\n      return age;\n    }\n​\n    public String getName(){\n      return name;\n    }\n​\n    public void setAge(int age){\n      this.age = age;\n    }\n​\n    public void setName(String name){\n      this.name = name;\n    }\n}\n```\n\n采用 **this** 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。\n\n## 6.Java 接口\n\n接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。\n\n接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。\n\n除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\n\n接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。\n\n### 6.1接口与类相似点：\n\n- 一个接口可以有多个方法。\n- 接口文件保存在 .java 结尾的文件中，文件名使用接口名。\n- 接口的字节码文件保存在 .class 结尾的文件中。\n- 接口相应的字节码文件必须在与包名称相匹配的目录结构中。\n\n### 6.2接口与类的区别：\n\n- 接口不能用于实例化对象。\n- 接口没有构造方法。\n- 接口中所有的方法必须是抽象方法。\n- 接口不能包含成员变量，除了 static 和 final 变量。\n- 接口不是被类继承了，而是要被类实现。\n- 接口支持多继承。\n\n### 6.3接口特性\n\n- 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 **public abstract**（只能是 public abstract，其他修饰符都会报错）。\n- 接口中可以含有变量，但是接口中的变量会被隐式的指定为 **public static final** 变量（并且只能是 public，用 private 修饰会报编译错误）。\n- 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。\n\n### 6.4抽象类和接口的区别\n\n- 1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。\n- 2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 **public static final** 类型的。\n- 3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。\n- 4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n### 6.5接口的声明\n\n规则：\n\n```java\n[可见度] interface 接口名称 [extends 其他的接口名] {\n        // 声明变量\n        // 抽象方法\n}\n```\n\n接口有以下特性：\n\n- 接口是隐式抽象的，当声明一个接口的时候，不必使用**abstract**关键字。\n- 接口中每一个方法也是隐式抽象的，声明时同样不需要**abstract**关键字。\n- 接口中的方法都是公有的。\n\n### 6.6接口的实现\n\n当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。\n\n类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。\n\n实现一个接口的语法，可以使用这个公式：\n\n```java\n...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...\n```\n\n重写接口中声明的方法时，需要注意以下规则：\n\n- 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。\n- 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。\n- 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。\n\n在实现接口的时候，也要注意一些规则：\n\n- 一个类可以同时实现多个接口。\n- 一个类只能继承一个类，但是能实现多个接口。\n- 一个接口能继承另一个接口，这和类之间的继承比较相似。\n\n### 6.7接口的继承\n\n一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。\n\n### 6.8接口的多继承\n\n在Java中，类的多继承是不合法，但接口允许多继承。\n\n在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：\n\n```java\npublic interface Hockey extends Sports, Event\n```\n\n### 6.9标记接口\n\n最常用的继承接口是没有包含任何方法的接口。\n\n标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。\n\n标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。\n\n例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：\n\n```java\npackage java.util;\npublic interface EventListener\n{}\n```\n\n没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：\n\n- 建立一个公共的父接口：\n\n  正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。\n\n- 向一个类添加数据类型：\n\n  这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。\n\n## 7.Java 枚举(enum)\n\nJava 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。\n\nJava 枚举类使用 enum 关键字来定义，各个常量使用逗号 **,** 来分割。\n\n例如定义一个颜色的枚举类。\n\n```\nenum Color \n{ \n    RED, GREEN, BLUE; \n} \n```\n\n实例：\n\n```java\nenum Color\n{\n    RED, GREEN, BLUE;\n}\n \npublic class Test\n{\n    // 执行输出结果\n    public static void main(String[] args)\n    {\n        Color c1 = Color.RED;\n        System.out.println(c1);\n    }\n}\n```\n\n输出：RED\n\n### 7.1内部类中使用枚举\n\n枚举类也可以声明在内部类中\n\n### 7.2迭代枚举元素\n\n可以使用 for 语句来迭代枚举元素：\n\n```java\nenum Color\n{\n    RED, GREEN, BLUE;\n}\npublic class MyClass {\n  public static void main(String[] args) {\n    for (Color myVar : Color.values()) {\n      System.out.println(myVar);\n    }\n  }\n}\n```\n\n和C++中的枚举区别很大\n\n### 7.3在 switch 中使用枚举类\n\n```java\nenum Color\n{\n    RED, GREEN, BLUE;\n}\npublic class MyClass {\n  public static void main(String[] args) {\n    Color myVar = Color.BLUE;\n\n    switch(myVar) {\n      case RED:\n        System.out.println(\"红色\");\n        break;\n      case GREEN:\n         System.out.println(\"绿色\");\n        break;\n      case BLUE:\n        System.out.println(\"蓝色\");\n        break;\n    }\n  }\n}\n```\n\n### 7.4values(), ordinal() 和 valueOf() 方法\n\nenum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。\n\nvalues(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：\n\n- values() 返回枚举类中所有的值。\n- ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。\n- valueOf()方法返回指定字符串值的枚举常量。\n\n## 8.Java 包(package)\n\n为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。\n\nC++中使用using namespace的编译指令区别！！！\n\n### 8.1包的作用\n\n- 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。\n- 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。\n- 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。\n\nJava 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。\n\n包语句的语法格式为：\n\n`package pkg1[．pkg2[．pkg3…]];`\n\n### 8.2创建包\n\n![](Java面向对象/8.png)\n\n然后可以把自己的包打包成jar包，并调用\n\n### 8.3import 关键字\n\n为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 \"import\" 语句可完成此功能。\n\n在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为：\n`port package1[.package2…].(classname|*);`\n\n### 8.4package 的目录结构\n\n类放在包中会有两种主要的结果：\n\n- 包名成为类名的一部分，正如我们前面讨论的一样。\n- 包名必须与相应的字节码所在的目录结构相吻合。\n\n下面是管理你自己 java 中文件的一种简单方式：\n\n+ 将类、接口等类型的源码放在一个文本中，这个文件的名字就是这个类型的名字，并以.java作为扩展名。例如：\n\n```java\n// 文件名 :  Car.java\n \npackage vehicle;\n \npublic class Car {\n   // 类实现  \n}\n```\n\n+ 接下来，把源文件放在一个目录中，这个目录要对应类所在包的名字。\n\n```java\n....\\vehicle\\Car.java\n```\n\n+ 现在，正确的类名和路径将会是如下样子：\n\n  - 类名 -> vehicle.Car\n  - 路径名 -> vehicle\\Car.java (在 windows 系统中)\n\n  通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是 runoob.com，所有的包名都以 com.runoob 开头。包名中的每一个部分对应一个子目录。\n\n  例如：有一个 **com.runoob.test** 的包，这个包包含一个叫做 Runoob.java 的源文件，那么相应的，应该有如下面的一连串子目录：\n\n```java\n....\\com\\runoob\\test\\Runoob.java\n```\n\n+ 编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类型的名字，并加上 .class 作为扩展后缀。 例如：\n\n```java\n// 文件名: Runoob.java\n \npackage com.runoob.test;\npublic class Runoob {\n      \n}\nclass Google {\n      \n}\n```\n\n+ 现在，我们用-d选项来编译这个文件，如下：\n\n> ```\n> $javac -d . Runoob.java\n> ```\n\n+ 这样会像下面这样放置编译了的文件：\n\n> ```\n> .\\com\\runoob\\test\\Runoob.class\n> .\\com\\runoob\\test\\Google.class\n> ```\n\n+ 你可以像下面这样来导入所有 **\\com\\runoob\\test\\** 中定义的类、接口等：\n\n> ```\n> import com.runoob.test.*;\n> ```\n\n+ 编译之后的 .class 文件应该和 .java 源文件一样，它们放置的目录应该跟包的名字对应起来。但是，并不要求 .class 文件的路径跟相应的 .java 的路径一样。你可以分开来安排源码和类的目录。\n\n> ```\n> <path-one>\\sources\\com\\runoob\\test\\Runoob.java\n> <path-two>\\classes\\com\\runoob\\test\\Google.class\n> ```\n\n这样，你可以将你的类目录分享给其他的编程人员，而不用透露自己的源码。用这种方法管理源码和类文件可以让编译器和java 虚拟机（JVM）可以找到你程序中使用的所有类型。\n\n类目录的绝对路径叫做 **class path**。设置在系统变量 **CLASSPATH** 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。\n\n<path- two>\\classes 是 class path，package 名字是 com.runoob.test,而编译器和 JVM 会在 <path-two>\\classes\\com\\runoob\\test 中找 .class 文件。\n\n一个 class path 可能会包含好几个路径，多路径应该用分隔符分开。默认情况下，编译器和 JVM 查找当前目录。JAR 文件按包含 Java 平台相关的类，所以他们的目录默认放在了 class path 中。\n\n### 8.5设置 CLASSPATH 系统变量\n\n就像安装JDK时设置系统变量一样用自己的包！！！","tags":["Java"],"categories":["JAVA学习"]},{"title":"Java基础语法","url":"/2020/12/26/基础语法/","content":"\n\n\n<!--more-->\n\n## Java 源程序与编译型运行区别\n\n![](./基础语法/1.png)\n\n## Java 对象和类\n\nJava作为一种面向对象语言。支持以下基本概念：\n\n- 多态\n- 继承\n- 封装\n- 抽象\n- 类\n- 对象\n- 实例\n- 方法\n- 重载\n\n### 对象和类的概念。\n\n- **对象**：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。\n- **类**：类是一个模板，它描述一类对象的行为和状态。\n\n### 一个类可以包含以下类型变量：\n\n- **局部变量**：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。\n- **成员变量**：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。\n- **类变量**：类变量也声明在类中，方法体之外，但必须声明为 static 类型。\n\n### 构造方法\n\n每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。\n\n在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。\n\n```java\npublic class Puppy{\n    public Puppy(){\n    }\n \n    public Puppy(String name){\n        // 这个构造器仅有一个参数：name\n    }\n}\n```\n\n### 源文件声明规则\n\n当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。\n\n- 一个源文件中只能有一个 public 类\n- 一个源文件可以有多个非 public 类\n- 源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。\n- 如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。\n- 如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。\n- import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。\n\n## Java 基本数据类型\n\n变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。\n\n内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。\n\n![](./基础语法/2.png)\n\n因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。\n\nJava 的两大数据类型:\n\n- 内置数据类型\n- 引用数据类型\n\n### 内置数据类型\n\nJava语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。\n\n**byte：**\n\n- byte 数据类型是8位、有符号的，以二进制补码表示的整数；\n- 最小值是 **-128（-2^7）**；\n- 最大值是 **127（2^7-1）**；\n- 默认值是 **0**；\n- byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；\n- 例子：byte a = 100，byte b = -50。\n\n**short：**\n\n- short 数据类型是 16 位、有符号的以二进制补码表示的整数\n- 最小值是 **-32768（-2^15）**；\n- 最大值是 **32767（2^15 - 1）**；\n- Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；\n- 默认值是 **0**；\n- 例子：short s = 1000，short r = -20000。\n\n**int：**\n\n- int 数据类型是32位、有符号的以二进制补码表示的整数；\n- 最小值是 **-2,147,483,648（-2^31）**；\n- 最大值是 **2,147,483,647（2^31 - 1）**；\n- 一般地整型变量默认为 int 类型；\n- 默认值是 **0** ；\n- 例子：int a = 100000, int b = -200000。\n\n**long：**\n\n- long 数据类型是 64 位、有符号的以二进制补码表示的整数；\n- 最小值是 **-9,223,372,036,854,775,808（-2^63）**；\n- 最大值是 **9,223,372,036,854,775,807（2^63 -1）**；\n- 这种类型主要使用在需要比较大整数的系统上；\n- 默认值是 **0L**；\n- 例子： long a = 100000L，Long b = -200000L。\n  \"L\"理论上不分大小写，但是若写成\"l\"容易与数字\"1\"混淆，不容易分辩。所以最好大写。\n\n**float：**\n\n- float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；\n- float 在储存大型浮点数组的时候可节省内存空间；\n- 默认值是 **0.0f**；\n- 浮点数不能用来表示精确的值，如货币；\n- 例子：float f1 = 234.5f。\n\n**double：**\n\n- double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；\n- 浮点数的默认类型为double类型；\n- double类型同样不能表示精确的值，如货币；\n- 默认值是 **0.0d**；\n- 例子：double d1 = 123.4。\n\n**boolean：**\n\n- boolean数据类型表示一位的信息；\n- 只有两个取值：true 和 false；\n- 这种类型只作为一种标志来记录 true/false 情况；\n- 默认值是 **false**；\n- 例子：boolean one = true。\n\n**char：**\n\n- char类型是一个单一的 16 位 Unicode 字符；\n- 最小值是 **\\u0000**（即为 0）；\n- 最大值是 **\\uffff**（即为65、535）；\n- char 数据类型可以储存任何字符；\n- 例子：char letter = 'A';。\n\n### 类型默认值\n\n|      **数据类型**      | **默认值** |\n| :--------------------: | :--------: |\n|          byte          |     0      |\n|         short          |     0      |\n|          int           |     0      |\n|          long          |     0L     |\n|         float          |    0.0f    |\n|         double         |    0.0d    |\n|          char          |  'u0000'   |\n| String (or any object) |    null    |\n|        boolean         |   false    |\n\n### 引用类型\n\n- 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型。变量一旦声明后，类型就不能被改变了。\n- 对象、数组都是引用数据类型。\n- 所有引用类型的默认值都是null。\n- 一个引用变量可以用来引用任何与之兼容的类型。\n- 例子：Site site = new Site(\"Runoob\")。\n\n### Java 常量\n\n常量在程序运行时是不能被修改的。\n\n在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：\n\n```\nfinal double PI = 3.1415927;\n```\n\n### 自动类型转换\n\n```\n低  ------------------------------------>  高\n\nbyte,short,char—> int —> long—> float —> double \n```\n\n数据类型转换必须满足如下规则：\n\n- 1. 不能对boolean类型进行类型转换。\n\n- 2. 不能把对象类型转换成不相关类的对象。\n\n- 3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。\n\n- 4. 转换过程中可能导致溢出或损失精度，例如：\n\n  ```\n  int i =128;   \n  byte b = (byte)i;\n  ```\n\n  因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。\n\n- 5. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：\n\n  ```\n  (int)23.7 == 23;        \n  (int)-45.89f == -45\n  ```\n\n#### 自动类型转换\n\n必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。\n\n#### 强制类型转换\n\n- 1. 条件是转换的数据类型必须是兼容的。\n- 2. 格式：(type)value type是要强制类型转换后的数据类型 实例：\n\n#### 隐含强制类型转换\n\n- 1. 整数的默认类型是 int。\n- 2. 浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f。\n\n## Java 变量类型\n\n- 类变量：独立于方法之外的变量，用 static 修饰。\n- 实例变量：独立于方法之外的变量，不过没有 static 修饰。\n- 局部变量：类的方法中的变量。\n\n![](基础语法/3.png)![](基础语法/4.png)\n\n### 实例变量\n\n- 实例变量声明在一个类中，但在方法、构造方法和语句块之外；\n- 当一个对象被实例化之后，每个实例变量的值就跟着确定；\n- 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；\n- 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；\n- 实例变量可以声明在使用前或者使用后；\n- 访问修饰符可以修饰实例变量；\n- 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；\n- 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；\n- 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。\n\n### 类变量（静态变量）\n\n- 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。\n- 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n- 静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。\n- 静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。\n- 静态变量在第一次被访问时创建，在程序结束时销毁。\n- 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。\n- 默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n- 静态变量可以通过：*ClassName.VariableName*的方式访问。\n- 类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。\n\n## Java 修饰符\n\n### 访问控制修饰符\n\nJava中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。\n\n- **default** (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。\n- **private** : 在同一类内可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**\n- **public** : 对所有类可见。使用对象：类、接口、变量、方法\n- **protected** : 对同一包内的类和所有子类可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**。\n\n我们可以通过以下表来说明访问权限：\n\n| 修饰符      | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包) | 其他包 |\n| :---------- | :----: | :------: | :------------: | :------------: | :----: |\n| `public`    |   Y    |    Y     |       Y        |       Y        |   Y    |\n| `protected` |   Y    |    Y     |       Y        |      Y/N       |   N    |\n| `default`   |   Y    |    Y     |       Y        |       N        |   N    |\n| `private`   |   Y    |    N     |       N        |       N        |   N    |\n\n#### 访问控制和继承\n\n- 父类中声明为 public 的方法在子类中也必须为 public。\n- 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。\n- 父类中声明为 private 的方法，不能够被继承。\n\n### 非访问修饰符\n\nstatic 修饰符，用来修饰类方法和类变量。\n\nfinal 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。\n\nabstract 修饰符，用来创建抽象类和抽象方法。\n\nsynchronized 和 volatile 修饰符，主要用于线程的编程。\n\n#### static 修饰符\n\n- **静态变量：**\n\n  static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。\n\n- **静态方法：**\n\n  static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。\n\n#### final 修饰符\n\n**final 变量：**\n\nfinal 表示\"最后的、最终的\"含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。\n\n**final 方法**\n\n父类中的 final 方法可以被子类继承，但是不能被子类重写。\n\n声明 final 方法的主要目的是防止该方法的内容被修改。\n\n**final 类**\n\nfinal 类不能被继承，没有类能够继承 final 类的任何特性。\n\n#### abstract 修饰符\n\n**抽象类：**\n\n抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。\n\n一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。\n\n**抽象方法**\n\n抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。\n\n抽象方法不能被声明成 final 和 static。\n\n任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。\n\n如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。\n\n抽象方法的声明以分号结尾，例如：**public abstract sample();**。\n\n#### synchronized 修饰符\n\nsynchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。\n\n#### transient 修饰符\n\n序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。\n\n该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。\n\n`public transient int limit = 55;   // 不会持久化 `\n\n`public int b; // 持久化`\n\n#### volatile 修饰符\n\nvolatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。\n\n一个 volatile 对象引用可能是 null。\n\n## Java 运算符\n\n### 算术运算符\n\n|  +   |     加法 - 相加运算符两侧的值     |           A + B 等于 30            |\n| :--: | :-------------------------------: | :--------------------------------: |\n|  -   |    减法 - 左操作数减去右操作数    |           A – B 等于 -10           |\n|  *   |     乘法 - 相乘操作符两侧的值     |            A * B等于200            |\n|  /   |    除法 - 左操作数除以右操作数    |            保留整数部分            |\n|  ％  | 取余 - 左操作数除以右操作数的余数 |              B%A等于0              |\n|  ++  |       自增: 操作数的值增加1       | B++ 或 ++B 等于 21（区别详见下文） |\n|  --  |       自减: 操作数的值减少1       | B-- 或 --B 等于 19（区别详见下文） |\n\n自增和自减前后缀区别：\n\n```cpp\nint i = 0;\nint x = ++i;//先+1再用\nint y = i++;//先用再加1\n//x=y=1,i=2\n```\n\n![](基础语法/5.png)![](基础语法/6.png)\n\n### 关系运算符\n\n| 运算符 |                             描述                             |       例子       |\n| :----: | :----------------------------------------------------------: | :--------------: |\n|   ==   |     检查如果两个操作数的值是否相等，如果相等则条件为真。     | （A == B）为假。 |\n|   !=   |   检查如果两个操作数的值是否相等，如果值不相等则条件为真。   | (A != B) 为真。  |\n|   >    |  检查左操作数的值是否大于右操作数的值，如果是那么条件为真。  |  （A> B）为假。  |\n|   <    |  检查左操作数的值是否小于右操作数的值，如果是那么条件为真。  |  （A <B）为真。  |\n|   >=   | 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 | （A> = B）为假。 |\n|   <=   | 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 | （A <= B）为真。 |\n\n### 位运算符\n\nJava定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。\n\n| 操作符 |                             描述                             |              例子              |\n| :----: | :----------------------------------------------------------: | :----------------------------: |\n|   ＆   |            如果相对应位都是1，则结果为1，否则为0             | （A＆B），得到12，即0000 1100  |\n|   \\|   |           如果相对应位都是 0，则结果为 0，否则为 1           | （A \\| B）得到61，即 0011 1101 |\n|   ^    |            如果相对应位值相同，则结果为0，否则为1            | （A ^ B）得到49，即 0011 0001  |\n|   〜   |     按位取反运算符翻转操作数的每一位，即0变成1，1变成0。     |  （〜A）得到-61，即1100 0011   |\n|   <<   |     按位左移运算符。左操作数按位左移右操作数指定的位数。     |  A << 2得到240，即 1111 0000   |\n|   >>   |     按位右移运算符。左操作数按位右移右操作数指定的位数。     |      A >> 2得到15即 1111       |\n|  >>>   | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 |     A>>>2得到15即0000 1111     |\n\n\\>> && \\>>>的区别\n\n![](基础语法/7.png)![](基础语法/8.png)\n\n前者高位补的是原来的值（即符号位）——算术右移（汇编中的概念）\n\n后者补0——逻辑右移（汇编中的概念）\n\n### 逻辑运算符\n\n| 操作符 |                             描述                             |        例子         |\n| :----: | :----------------------------------------------------------: | :-----------------: |\n|   &&   |   称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。   |  （A && B）为假。   |\n| \\| \\|  | 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 | （A \\| \\| B）为真。 |\n|   ！   | 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 | ！（A && B）为真。  |\n\n和C++，C一样也是短路计算，比如求a&&b，a，b均是表达式，当a的值为0，b的值就不会去计算。\n\n![](基础语法/9.png)\n\n输出a=0\n\n### 赋值运算符\n\n| 操作符  |                             描述                             |                   例子                   |\n| :-----: | :----------------------------------------------------------: | :--------------------------------------: |\n|    =    |        简单的赋值运算符，将右操作数的值赋给左侧操作数        |     C = A + B将把A + B得到的值赋给C      |\n|   + =   |   加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数   |          C + = A等价于C = C + A          |\n|   - =   |   减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数   |          C - = A等价于C = C - A          |\n|   * =   |   乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数   |          C * = A等价于C = C * A          |\n|   / =   |   除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数   | C / = A，C 与 A 同类型时等价于 C = C / A |\n| （％）= | 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 |           C％= A等价于C = C％A           |\n|  << =   |                       左移位赋值运算符                       |         C << = 2等价于C = C << 2         |\n|  >> =   |                       右移位赋值运算符                       |         C >> = 2等价于C = C >> 2         |\n|   ＆=   |                       按位与赋值运算符                       |           C＆= 2等价于C = C＆2           |\n|   ^ =   |                      按位异或赋值操作符                      |          C ^ = 2等价于C = C ^ 2          |\n|  \\| =   |                       按位或赋值操作符                       |         C \\| = 2等价于C = C \\| 2         |\n\n和C，C++一样\n\n### 条件运算符（?:）\n\n条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。\n\n```\nvariable x = (expression) ? value if true : value if false\n```\n\nC++中也有这种写法\n\n### instanceof 运算符\n\n该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。\n\n```\n( Object reference variable ) instanceof  (class/interface type)\n```\n\n如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。\n\n下面是一个例子：\n\n```\nString name = \"James\";\nboolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真\n```\n\n如果被比较的对象兼容于右侧类型,该运算符仍然返回true。\n\n```cpp\nclass Vehicle {}\n \npublic class Car extends Vehicle {\n   public static void main(String[] args){\n      Vehicle a = new Car();\n      boolean result =  a instanceof Car;\n      System.out.println( result);\n   }\n}\n```\n\n### Java运算符优先级\n\n|   类别   |                   操作符                   |  关联性  |\n| :------: | :----------------------------------------: | :------: |\n|   后缀   |             () [] . (点操作符)             |  左到右  |\n|   一元   |               expr++ expr--                | 从左到右 |\n|   一元   |          ++expr --expr + - ～ ！           | 从右到左 |\n|   乘性   |                   * /％                    |  左到右  |\n|   加性   |                    + -                     |  左到右  |\n|   移位   |                 >> >>>  <<                 |  左到右  |\n|   关系   |                 > >= < <=                  |  左到右  |\n|   相等   |                   == !=                    |  左到右  |\n|  按位与  |                     ＆                     |  左到右  |\n| 按位异或 |                     ^                      |  左到右  |\n|  按位或  |                     \\|                     |  左到右  |\n|  逻辑与  |                     &&                     |  左到右  |\n|  逻辑或  |                   \\| \\|                    |  左到右  |\n|   条件   |                    ？：                    | 从右到左 |\n|   赋值   | = + = - = * = / =％= >> = << =＆= ^ = \\| = | 从右到左 |\n|   逗号   |                     ，                     |  左到右  |\n\n关联性也就是C++中所谓的结合性\n\n## Java 循环结构 - for, while 及 do...while\n\n这块和C++几乎一样\n\n### while 循环\n\n```cpp\nwhile( 布尔表达式 ) {  //循环内容 }\n```\n\n### do…while 循环（至少执行一次循环）\n\n```cpp\ndo {\n       //代码语句\n}while(布尔表达式);\n```\n\n### for循环\n\n```cpp\nfor(初始化; 布尔表达式; 更新) {\n    //代码语句\n}\n```\n\n### Java 增强 for 循环（C++11也新增）\n\nC++中叫基于范围的循环，python中就是这种循环\n\n```cpp\nfor(声明语句 : 表达式)\n{\n   //代码句子\n}\n```\n\n**声明语句：**声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。\n\n**表达式：**表达式是要访问的数组名，或者是返回值为数组的方法。\n\n![](基础语法/10.png)![](基础语法/11.png)\n\n### break 关键字\n\nbreak 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。\n\nbreak 跳出最里层的循环，并且继续执行该循环下面的语句。\n\n### continue 关键字\n\ncontinue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。\n\n在 for 循环中，continue 语句使程序立即跳转到更新语句。\n\n在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。\n\n## Java 条件语句 - if...else\n\n### if\n\n\n\n语法：\n\n```cpp\nif(布尔表达式)\n{\n   //如果布尔表达式为true将执行的语句\n}\n```\n\n### if...else语句\n\n```cpp\nif(布尔表达式){\n   //如果布尔表达式的值为true\n}else{\n   //如果布尔表达式的值为false\n}\n```\n\n可嵌套，和C++一模一样\n\n## Java switch case 语句\n\nswitch case 语句语法格式如下：\n\n```java\nswitch(expression){\n    case value :\n       //语句\n       break; //可选\n    case value :\n       //语句\n       break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n       //语句\n}\n```\n\n## Java Number & Math 类\n\n一般地，当需要使用数字的时候，我们通常使用内置数据类型，如：**byte、int、long、double** 等。\n\n然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，Java 语言为每一个内置数据类型提供了对应的包装类。\n\n所有的包装类**（Integer、Long、Byte、Double、Float、Short）**都是抽象类 Number 的子类。\n\n|  包装类   | 基本数据类型 |\n| :-------: | :----------: |\n|  Boolean  |   boolean    |\n|   Byte    |     byte     |\n|   Short   |    short     |\n|  Integer  |     int      |\n|   Long    |     long     |\n| Character |     char     |\n|   Float   |    float     |\n|  Double   |    double    |\n\n![](基础语法/12.png)\n\n这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。\n\n```java\npublic class Test{\n \n   public static void main(String args[]){\n      Integer x = 5;\n      x =  x + 10;\n      System.out.println(x); \n   }\n}\n```\n\n当 x 被赋为整型值时，由于x是一个对象，所以编译器要对x进行装箱。然后，为了使x能进行加运算，所以要对x进行拆箱。\n\n## Java Math 类\n\nJava 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。\n\nMath 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。\n\n示例：\n\n```cpp\npublic class Test {  \n    public static void main (String []args)  \n    {  \n        System.out.println(\"90 度的正弦值：\" + Math.sin(Math.PI/2));  \n        System.out.println(\"0度的余弦值：\" + Math.cos(0));  \n        System.out.println(\"60度的正切值：\" + Math.tan(Math.PI/3));  \n        System.out.println(\"1的反正切值： \" + Math.atan(1));  \n        System.out.println(\"π/2的角度值：\" + Math.toDegrees(Math.PI/2));  \n        System.out.println(Math.PI);  \n    }  \n}\n```\n\n## Number & Math 类方法\n\n| 序号 | 方法与描述                                                   |\n| :--- | :----------------------------------------------------------- |\n| 1    | [xxxValue()](https://www.runoob.com/java/number-xxxvalue.html) 将 Number 对象转换为xxx数据类型的值并返回。 |\n| 2    | [compareTo()](https://www.runoob.com/java/number-compareto.html) 将number对象与参数比较。 |\n| 3    | [equals()](https://www.runoob.com/java/number-equals.html) 判断number对象是否与参数相等。 |\n| 4    | [valueOf()](https://www.runoob.com/java/number-valueof.html) 返回一个 Number 对象指定的内置数据类型 |\n| 5    | [toString()](https://www.runoob.com/java/number-tostring.html) 以字符串形式返回值。 |\n| 6    | [parseInt()](https://www.runoob.com/java/number-parseInt.html) 将字符串解析为int类型。 |\n| 7    | [abs()](https://www.runoob.com/java/number-abs.html) 返回参数的绝对值。 |\n| 8    | [ceil()](https://www.runoob.com/java/number-ceil.html) 返回大于等于( >= )给定参数的的最小整数，类型为双精度浮点型。 |\n| 9    | [floor()](https://www.runoob.com/java/number-floor.html) 返回小于等于（<=）给定参数的最大整数 。 |\n| 10   | [rint()](https://www.runoob.com/java/number-rint.html) 返回与参数最接近的整数。返回类型为double。 |\n| 11   | [round()](https://www.runoob.com/java/number-round.html) 它表示**四舍五入**，算法为 **Math.floor(x+0.5)**，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。 |\n| 12   | [min()](https://www.runoob.com/java/number-min.html) 返回两个参数中的最小值。 |\n| 13   | [max()](https://www.runoob.com/java/number-max.html) 返回两个参数中的最大值。 |\n| 14   | [exp()](https://www.runoob.com/java/number-exp.html) 返回自然数底数e的参数次方。 |\n| 15   | [log()](https://www.runoob.com/java/number-log.html) 返回参数的自然数底数的对数值。 |\n| 16   | [pow()](https://www.runoob.com/java/number-pow.html) 返回第一个参数的第二个参数次方。 |\n| 17   | [sqrt()](https://www.runoob.com/java/number-sqrt.html) 求参数的算术平方根。 |\n| 18   | [sin()](https://www.runoob.com/java/number-sin.html) 求指定double类型参数的正弦值。 |\n| 19   | [cos()](https://www.runoob.com/java/number-cos.html) 求指定double类型参数的余弦值。 |\n| 20   | [tan()](https://www.runoob.com/java/number-tan.html) 求指定double类型参数的正切值。 |\n| 21   | [asin()](https://www.runoob.com/java/number-asin.html) 求指定double类型参数的反正弦值。 |\n| 22   | [acos()](https://www.runoob.com/java/number-acos.html) 求指定double类型参数的反余弦值。 |\n| 23   | [atan()](https://www.runoob.com/java/number-atan.html) 求指定double类型参数的反正切值。 |\n| 24   | [atan2()](https://www.runoob.com/java/number-atan2.html) 将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。 |\n| 25   | [toDegrees()](https://www.runoob.com/java/number-todegrees.html) 将参数转化为角度。 |\n| 26   | [toRadians()](https://www.runoob.com/java/number-toradians.html) 将角度转换为弧度。 |\n| 27   | [random()](https://www.runoob.com/java/number-random.html) 返回一个随机数。 |\n\n## Java Character 类\n\nCharacter 类用于对单个字符进行操作。\n\nCharacter 类在对象中包装一个基本类型 **char** 的值\n\n### 转义序列\n\n| 转义序列 |           描述           |\n| :------: | :----------------------: |\n|    \\t    | 在文中该处插入一个tab键  |\n|    \\b    | 在文中该处插入一个后退键 |\n|    \\n    |      在文中该处换行      |\n|    \\r    |    在文中该处插入回车    |\n|    \\f    |   在文中该处插入换页符   |\n|    \\'    |   在文中该处插入单引号   |\n|    \\\"    |   在文中该处插入双引号   |\n|    \\\\    |   在文中该处插入反斜杠   |\n\n### Character 方法\n\nC++中是cctype头文件中的方法。\n\n| 序号 | 方法与描述                                      |\n| :--- | :---------------------------------------------- |\n| 1    | isLetter() 是否是一个字母                       |\n| 2    | isDigit()是否是一个数字字符                     |\n| 3    | isWhitespace()是否是一个空白字符                |\n| 4    | isUpperCase() 是否是大写字母                    |\n| 5    | isLowerCase()是否是小写字母                     |\n| 6    | toUpperCase() 指定字母的大写形式                |\n| 7    | toLowerCase() 指定字母的小写形式                |\n| 8    | toString返回字符的字符串形式，字符串的长度仅为1 |\n\n## Java String 类\n\n字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。\n\n### 创建字符串\n\nString 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：\n\n```java\nString s1 = \"Runoob\";              // String 直接创建\nString s2 = \"Runoob\";              // String 直接创建\nString s3 = s1;                    // 相同引用\nString s4 = new String(\"Runoob\");   // String 对象创建\nString s5 = new String(\"Runoob\");   // String 对象创建\n```\n\n![](基础语法/13.png)\n\n### 字符串长度\n\nString 类的一个访问器方法是 length() 方法，它返回字符串对象包含的字符数。\n\n！！！没有size方法，C++STL中有size和length\n\n### 连接字符串\n\nString 类提供了连接两个字符串的方法：\n\n+ 返回 string2 连接 string1 的新字符串。也可以对字符串常量使用 concat() 方法，如：\n\n+ 更常用的是使用'+'操作符来连接字符串\n\n![](基础语法/14.png)![](基础语法/15.png)\n\n### 创建格式化字符串\n\n我们知道输出格式化数字可以使用 printf() 和 format() 方法。\n\nString 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。\n\nString 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。\n\n### String 方法\n\n参看 [Java String API](https://www.runoob.com/manual/jdk1.6/java/lang/String.html) 文档:\n\n## Java StringBuffer 和 StringBuilder 类\n\n当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。\n\n和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。\n\n![](基础语法/16.png)\n\n在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。\n\nStringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。\n\n由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。\n\n![](基础语法/17.png)\n\n然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。\n\n### StringBuffer 方法\n\n| 序号 |                           方法描述                           |\n| :--: | :----------------------------------------------------------: |\n|  1   |                int capacity() 返回当前容量。                 |\n|  2   | char charAt(int index) 返回此序列中指定索引处的 `char` 值。  |\n|  3   | void ensureCapacity(int minimumCapacity) 确保容量至少等于指定的最小值。 |\n|  4   | void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 `dst`。 |\n|  5   | int indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。 |\n|  6   | int indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。 |\n|  7   | int lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。 |\n|  8   | int lastIndexOf(String str, int fromIndex) 返回 String 对象中子字符串最后出现的位置。 |\n|  9   |              int length()  返回长度（字符数）。              |\n|  10  | void setCharAt(int index, char ch) 将给定索引处的字符设置为 `ch`。 |\n|  11  |      void setLength(int newLength) 设置字符序列的长度。      |\n|  12  | CharSequence subSequence(int start, int end) 返回一个新的字符序列，该字符序列是此序列的子序列。 |\n|  13  | String substring(int start) 返回一个新的 `String`，它包含此字符序列当前所包含的字符子序列。 |\n|  14  | String substring(int start, int end) 返回一个新的 `String`，它包含此序列当前所包含的字符子序列。 |\n|  15  |     String toString() 返回此序列中数据的字符串表示形式。     |\n\n## Java 数组\n\n### 声明数组变量\n\n```cpp\ndataType[] arrayRefVar;   // 首选的方法\n \n或\n \ndataType arrayRefVar[];  // 效果相同，但不是首选方法 \n//dataType arrayRefVar[] 风格是来自 C/C++ 语言 ，在Java中采用是为了让 C/C++ 程序员能够快速理解java语言。\n```\n\n### 创建数组\n\nJava语言使用new操作符来创建数组，语法如下：\n\n`arrayRefVar = new dataType[arraySize];`\n\n上面的语法语句做了两件事：\n\n- 一、使用 dataType[arraySize] 创建了一个数组。\n- 二、把新创建的数组的引用赋值给变量 arrayRefVar。\n\n可以理解成返回的是指针，C/C++中就有这种概念。\n\n### 数组作为函数的参数\n\n```cpp\npublic static void printArray(int[] array) {\n  for (int i = 0; i < array.length; i++) {\n    System.out.print(array[i] + \" \");\n  }\n}\n```\n\n### 数组作为函数的返回值\n\n```cpp\npublic static int[] reverse(int[] list) {\n  int[] result = new int[list.length];\n \n  for (int i = 0, j = result.length - 1; i < list.length; i++, j--) {\n    result[j] = list[i];\n  }\n  return result;\n}\n```\n\n实际本质是在堆盛情内存空间之后，返回的是引用，也就是数组在堆内存中的位置。\n\n### 多维数组\n\n多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组，例如：\n\n`String str[][] = new String[3][4];`\n\n### Arrays 类\n\njava.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。\n\n具有以下功能：\n\n- 给数组赋值：通过 fill 方法。\n- 对数组排序：通过 sort 方法,按升序。\n- 比较数组：通过 equals 方法比较数组中元素值是否相等。\n- 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。\n\n| 序号 | 方法和说明                                                   |\n| :--: | :----------------------------------------------------------- |\n|  1   | **public static int binarySearch(Object[] a, Object key)** 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(*插入点*) - 1)。 |\n|  2   | **public static boolean equals(long[] a, long[] a2)** 如果两个指定的 long 型数组彼此*相等*，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |\n|  3   | **public static void fill(int[] a, int val)** 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |\n|  4   | **public static void sort(Object[] a)** 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |\n\n## Java 日期时间\n\njava.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。\n\n第一个构造函数使用当前日期和时间来初始化对象。\n\n第一个构造函数使用当前日期和时间来初始化对象。`Date( )`\n\n第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。`Date(long millisec)`\n\n| 序号 | 方法和描述                                                   |\n| :--- | :----------------------------------------------------------- |\n| 1    | **boolean after(Date date)** 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。 |\n| 2    | **boolean before(Date date)** 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。 |\n| 3    | **Object clone( )** 返回此对象的副本。                       |\n| 4    | **int compareTo(Date date)** 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。 |\n| 5    | **int compareTo(Object obj)** 若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。 |\n| 6    | **boolean equals(Object date)** 当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。 |\n| 7    | **long getTime( )** 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 |\n| 8    | **int hashCode( )**  返回此对象的哈希码值。                  |\n| 9    | **void setTime(long time)**   用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。 |\n| 10   | **String toString( )** 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。 |\n\n### 获取当前日期时间\n\n![](基础语法/18.png)![](基础语法/19.png)\n\n### 日期比较\n\nJava使用以下三种方法来比较两个日期：\n\n- 使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。\n- 使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。\n- 使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。\n\n### 使用 SimpleDateFormat 格式化日期\n\nSimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如：\n\n`SimpleDateFormat ft = new SimpleDateFormat (\"yyyy-MM-dd hh:mm:ss\");`\n\n这一行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。\n\n**注意**:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。\n\n![](基础语法/20.png)![](基础语法/21.png)\n\n### 解析字符串为时间\n\nSimpleDateFormat 类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat 对象的格式化存储来解析字符串。例如：\n\n```java\nimport java.util.*;\nimport java.text.*;\n  \npublic class DateDemo {\n \n   public static void main(String args[]) {\n      SimpleDateFormat ft = new SimpleDateFormat (\"yyyy-MM-dd\"); \n \n      String input = args.length == 0 ? \"1818-11-11\" : args[0]; \n \n      System.out.print(input + \" Parses as \"); \n \n      Date t; \n \n      try { \n          t = ft.parse(input); \n          System.out.println(t); \n      } catch (ParseException e) { \n          System.out.println(\"Unparseable using \" + ft); \n      }\n   }\n}\n```\n\n### Java 休眠(sleep)\n\nsleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。\n\n你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。\n\n### Calendar类\n\n我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用Calendar 类。\n\nCalendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。\n\nCalendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。\n\n### GregorianCalendar类\n\nCalendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。\n\nCalendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。\n\n## Java 正则表达式\n\nava 正则表达式和 Perl 的是最为相似的。\n\njava.util.regex 包主要包括以下三个类：\n\n- Pattern 类：\n\n  pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。\n\n- Matcher 类：\n\n  Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。\n\n- PatternSyntaxException：\n\n  PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。\n\n  \n\n## Java 方法\n\n### 方法的定义\n\n```java\n修饰符 返回值类型 方法名(参数类型 参数名){\n    ...\n    方法体\n    ...\n    return 返回值;\n}\n```\n\n- **修饰符：**修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。\n- **返回值类型 ：**方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字**void**。\n- **方法名：**是方法的实际名称。方法名和参数表共同构成方法签名。\n- **参数类型：**参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。\n- **方法体：**方法体包含具体的语句，定义该方法的功能。\n\n### 方法的重载\n\n就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。\n\nJava编译器根据方法签名判断哪个方法应该被调用。\n\n方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。\n\n重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。\n\n### 构造方法\n\n当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。\n\n不管你是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，默认构造方法的访问修改符和类的访问修改符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。\n\n一旦你定义了自己的构造方法，默认构造方法就会失效。\n\n### 可变参数\n\nJDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。\n\n方法的可变参数的声明如下所示：\n\n`typeName... parameterName`\n\n在方法声明中，在指定参数类型后加一个省略号(...) 。\n\n一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。\n\n### finalize() 方法\n\nJava 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。\n\n例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。\n\n在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。\n\nfinalize() 一般格式是：\n\n```java\nprotected void finalize()\n{\n   // 在这里终结代码\n}\n```\n\n关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。\n\n当然，Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法。\n\n## Java 流(Stream)、文件(File)和IO\n\n### 读取控制台输入\n\nJava 的控制台输入由 System.in 完成。\n\n为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。\n\n下面是创建 BufferedReader 的基本语法：\n\n```java\nBufferedReader br = new BufferedReader(new \n                      InputStreamReader(System.in));\n```\n\nBufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。\n\n### 读写文件\n\n如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。\n\n下图是一个描述输入流和输出流的类层次图。\n\n![](基础语法/22.png)\n\n### FileInputStream\n\n该流用于从文件读取数据，它的对象可以用关键字 new 来创建。\n\n有多种构造方法可用来创建对象。\n\n可以使用字符串类型的文件名来创建一个输入流对象来读取文件：\n\n```\nInputStream f = new FileInputStream(\"C:/java/hello\");\n```\n\n也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：\n\n```\nFile f = new File(\"C:/java/hello\"); InputStream out = new FileInputStream(f);\n```\n\n| **序号** | **方法及描述**                                               |\n| :------- | :----------------------------------------------------------- |\n| 1        | **public void close() throws IOException{}** 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。 |\n| 2        | **protected void finalize()throws IOException {}** 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。 |\n| 3        | **public int read(int r)throws IOException{}** 这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。 |\n| 4        | **public int read(byte[] r) throws IOException{}** 这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。 |\n| 5        | **public int available() throws IOException{}** 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。 |\n\n### FileOutputStream\n\n该类用来创建一个文件并向文件中写数据。\n\n如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。\n\n有两个构造方法可以用来创建 FileOutputStream 对象。\n\n使用字符串类型的文件名来创建一个输出流对象：\n\n```\nOutputStream f = new FileOutputStream(\"C:/java/hello\")\n```\n\n也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：\n\n```\nFile f = new File(\"C:/java/hello\"); OutputStream f = new FileOutputStream(f);\n```\n\n### Java中的目录\n\n#### 创建目录：\n\nFile类中有两个方法可以用来创建文件夹：\n\n- **mkdir( )**方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。\n- **mkdirs()**方法创建一个文件夹和它的所有父文件夹。\n\n### 读取目录\n\n一个目录其实就是一个 File 对象，它包含其他文件和文件夹。\n\n如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。\n\n可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。\n\n删除文件可以使用 **java.io.File.delete()** 方法。\n\n### 删除目录或文件\n\n需要注意的是当删除某一目录时，必须保证该目录下没有其他文件才能正确删除，否则将删除失败。\n\n## Java Scanner 类\n\njava.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。\n\n下面是创建 Scanner 对象的基本语法：\n\n```\nScanner s = new Scanner(System.in);\n```\n\n通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据：\n\n#### next() 与 nextLine() 区别\n\nnext():\n\n- 1、一定要读取到有效字符后才可以结束输入。\n- 2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。\n- 3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。\n- next() 不能得到带有空格的字符串。\n\nnextLine()：\n\n- 1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。\n- 2、可以获得空白。\n\n## Java 异常处理\n\n异常发生的原因有很多，通常包含以下几大类：\n\n- 用户输入了非法数据。\n- 要打开的文件不存在。\n- 网络通信时连接中断，或者JVM内存溢出。\n\n这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。-\n\n要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：\n\n- **检查性异常：**最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。\n- **运行时异常：** 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。\n- **错误：** 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。\n\n### Exception 类的层次\n\n所有的异常类是从 java.lang.Exception 类继承的子类。\n\nException 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。\n\nJava 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。\n\nError 用来指示运行时环境发生的错误。\n\n例如，JVM 内存溢出。一般地，程序不会从错误中恢复。\n\n异常类有两个主要的子类：IOException 类和 RuntimeException 类。\n\n![](基础语法/23.jpg)\n\n### Java 内置异常类\n\nJava 语言定义了一些异常类在 java.lang 标准包中。\n\n标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。\n\nJava 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常。\n\n### 异常方法\n\n下面的列表是 Throwable 类的主要方法:\n\n| **序号** | **方法及说明**                                               |\n| :------- | :----------------------------------------------------------- |\n| 1        | **public String getMessage()** 返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。 |\n| 2        | **public Throwable getCause()** 返回一个Throwable 对象代表异常原因。 |\n| 3        | **public String toString()** 使用getMessage()的结果返回类的串级名字。 |\n| 4        | **public void printStackTrace()** 打印toString()结果和栈层次到System.err，即错误输出流。 |\n| 5        | **public StackTraceElement [] getStackTrace()** 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。 |\n| 6        | **public Throwable fillInStackTrace()** 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。 |\n\n### 捕获异常\n\n使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。\n\ntry/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：\n\n```\ntry\n{\n   // 程序代码\n}catch(ExceptionName e1)\n{\n   //Catch 块\n}\n```\n\n### 多重捕获块\n\n一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。\n\n```java\ntry{\n   // 程序代码\n}catch(异常类型1 异常的变量名1){\n  // 程序代码\n}catch(异常类型2 异常的变量名2){\n  // 程序代码\n}catch(异常类型3 异常的变量名3){\n  // 程序代码\n}\n```\n\n### throws/throw 关键字：\n\n如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。\n\n也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。\n\n下面方法的声明抛出一个 RemoteException 异常：\n\n```java\nimport java.io.*;\npublic class className\n{\n  public void deposit(double amount) throws RemoteException\n  {\n    // Method implementation\n    throw new RemoteException();\n  }\n  //Remainder of class definition\n}\n```\n\n下面的例子中声明有两个元素的一个数组，当代码试图访问数组的第三个元素的时候就会抛出一个异常。\n\n### finally关键字\n\nfinally 关键字用来创建在 try 代码块后面执行的代码块。\n\n无论是否发生异常，finally 代码块中的代码总会被执行。\n\n在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。\n\nfinally 代码块出现在 catch 代码块最后，语法如下:\n\n```java\ntry{\n  // 程序代码\n}catch(异常类型1 异常的变量名1){\n  // 程序代码\n}catch(异常类型2 异常的变量名2){\n  // 程序代码\n}finally{\n  // 程序代码\n}\n```\n\n- catch 不能独立于 try 存在。\n- 在 try/catch 后面添加 finally 块并非强制性要求的。\n- try 代码后不能既没 catch 块也没 finally 块。\n- try, catch, finally 块之间不能添加任何代码。\n\n### 声明自定义异常\n\n在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。\n\n- 所有异常都必须是 Throwable 的子类。\n- 如果希望写一个检查性异常类，则需要继承 Exception 类。\n- 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。\n\n### 通用异常\n\n在Java中定义了两种类型的异常和错误。\n\n- **JVM(Java****虚拟机****)** **异常：**由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。\n- **程序级异常：**由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。","tags":["Java"],"categories":["JAVA学习"]}]